/********************************* 
 * Vswm_Digit_Hf_Oe_Wcst_Pm Test *
 *********************************/

// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: true,
  color: new util.Color([(- 1), (- 1), (- 1)]),
  units: 'height',
  waitBlanking: true
});

// store info about the experiment session:
let expName = 'VSWM_Digit_HF_OE_WCST_PM';  // from the Builder filename that created this script
let expInfo = {'Enter participant ID': ''};

// Start code blocks for 'Before Experiment'
//var stroop_schedule = ['Stroop_Stim_Schedule_1.xlsx','Stroop_Stim_Schedule_4.xlsx','Stroop_Stim_Schedule_5.xlsx', 'Stroop_Stim_Schedule_8.xlsx','Stroop_Stim_Schedule_11.xlsx'];
//var x1 = '';
//var x2 = '';
//var x3 = '';

var myBrowser;
var sUsrAg;
var nIdx;
var beginning_exp = '';
var timer = '';
var timer_exp = '';
var beginning_exp = '';
var beginning_exp2 = '';

function getBrowserId () {
    var browsers = ["MSIE", "Firefox", "Safari", "Chrome", "Opera"];
    sUsrAg = window.navigator.userAgent,
    nIdx = browsers.length - 1;
    for (nIdx; nIdx > -1 && sUsrAg.indexOf(browsers [nIdx]) === -1; nIdx--);

  return browsers[nIdx];
}

myBrowser = getBrowserId();
var practice_correct = 0;
var timer_practice_wcst = '';
var beginning_practice_wcst = '';
var timer_wcst = '';
var beginning_wcst = '';
// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
flowScheduler.add(WelcomeRoutineBegin());
flowScheduler.add(WelcomeRoutineEachFrame());
flowScheduler.add(WelcomeRoutineEnd());
flowScheduler.add(overal_ef_assessment_instructionsRoutineBegin());
flowScheduler.add(overal_ef_assessment_instructionsRoutineEachFrame());
flowScheduler.add(overal_ef_assessment_instructionsRoutineEnd());
flowScheduler.add(IntroductionRoutineBegin());
flowScheduler.add(IntroductionRoutineEachFrame());
flowScheduler.add(IntroductionRoutineEnd());
flowScheduler.add(Circles_Example_1RoutineBegin());
flowScheduler.add(Circles_Example_1RoutineEachFrame());
flowScheduler.add(Circles_Example_1RoutineEnd());
flowScheduler.add(Circles_Example_2RoutineBegin());
flowScheduler.add(Circles_Example_2RoutineEachFrame());
flowScheduler.add(Circles_Example_2RoutineEnd());
flowScheduler.add(Circles_Example_3RoutineBegin());
flowScheduler.add(Circles_Example_3RoutineEachFrame());
flowScheduler.add(Circles_Example_3RoutineEnd());
flowScheduler.add(Circle_Example_4RoutineBegin());
flowScheduler.add(Circle_Example_4RoutineEachFrame());
flowScheduler.add(Circle_Example_4RoutineEnd());
flowScheduler.add(Initial_CirclesRoutineBegin());
flowScheduler.add(Initial_CirclesRoutineEachFrame());
flowScheduler.add(Initial_CirclesRoutineEnd());
flowScheduler.add(Circle_Example_5ARoutineBegin());
flowScheduler.add(Circle_Example_5ARoutineEachFrame());
flowScheduler.add(Circle_Example_5ARoutineEnd());
flowScheduler.add(Circle_Example_6RoutineBegin());
flowScheduler.add(Circle_Example_6RoutineEachFrame());
flowScheduler.add(Circle_Example_6RoutineEnd());
flowScheduler.add(Circle_Example_7RoutineBegin());
flowScheduler.add(Circle_Example_7RoutineEachFrame());
flowScheduler.add(Circle_Example_7RoutineEnd());
flowScheduler.add(Start_PracticeRoutineBegin());
flowScheduler.add(Start_PracticeRoutineEachFrame());
flowScheduler.add(Start_PracticeRoutineEnd());
const Meta_LoopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(Meta_LoopLoopBegin, Meta_LoopLoopScheduler);
flowScheduler.add(Meta_LoopLoopScheduler);
flowScheduler.add(Meta_LoopLoopEnd);
flowScheduler.add(Get_ExperimenterRoutineBegin());
flowScheduler.add(Get_ExperimenterRoutineEachFrame());
flowScheduler.add(Get_ExperimenterRoutineEnd());
flowScheduler.add(InstructionsRoutineBegin());
flowScheduler.add(InstructionsRoutineEachFrame());
flowScheduler.add(InstructionsRoutineEnd());
flowScheduler.add(get_readyRoutineBegin());
flowScheduler.add(get_readyRoutineEachFrame());
flowScheduler.add(get_readyRoutineEnd());
const trials_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trials_2LoopBegin, trials_2LoopScheduler);
flowScheduler.add(trials_2LoopScheduler);
flowScheduler.add(trials_2LoopEnd);
flowScheduler.add(real_trialsRoutineBegin());
flowScheduler.add(real_trialsRoutineEachFrame());
flowScheduler.add(real_trialsRoutineEnd());
const blocksLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(blocksLoopBegin, blocksLoopScheduler);
flowScheduler.add(blocksLoopScheduler);
flowScheduler.add(blocksLoopEnd);
flowScheduler.add(EndRoutineBegin());
flowScheduler.add(EndRoutineEachFrame());
flowScheduler.add(EndRoutineEnd());
flowScheduler.add(Welcome_2RoutineBegin());
flowScheduler.add(Welcome_2RoutineEachFrame());
flowScheduler.add(Welcome_2RoutineEnd());
flowScheduler.add(IntroA_2RoutineBegin());
flowScheduler.add(IntroA_2RoutineEachFrame());
flowScheduler.add(IntroA_2RoutineEnd());
flowScheduler.add(IntroB_2RoutineBegin());
flowScheduler.add(IntroB_2RoutineEachFrame());
flowScheduler.add(IntroB_2RoutineEnd());
flowScheduler.add(Example1RoutineBegin());
flowScheduler.add(Example1RoutineEachFrame());
flowScheduler.add(Example1RoutineEnd());
flowScheduler.add(Example2RoutineBegin());
flowScheduler.add(Example2RoutineEachFrame());
flowScheduler.add(Example2RoutineEnd());
flowScheduler.add(Quick_ReminderRoutineBegin());
flowScheduler.add(Quick_ReminderRoutineEachFrame());
flowScheduler.add(Quick_ReminderRoutineEnd());
flowScheduler.add(Practice_congruentRoutineBegin());
flowScheduler.add(Practice_congruentRoutineEachFrame());
flowScheduler.add(Practice_congruentRoutineEnd());
const practice_congruent_1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_congruent_1LoopBegin, practice_congruent_1LoopScheduler);
flowScheduler.add(practice_congruent_1LoopScheduler);
flowScheduler.add(practice_congruent_1LoopEnd);
flowScheduler.add(congruent_reminderRoutineBegin());
flowScheduler.add(congruent_reminderRoutineEachFrame());
flowScheduler.add(congruent_reminderRoutineEnd());
const practice_congruent_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_congruent_2LoopBegin, practice_congruent_2LoopScheduler);
flowScheduler.add(practice_congruent_2LoopScheduler);
flowScheduler.add(practice_congruent_2LoopEnd);
flowScheduler.add(ReadyRoutineBegin());
flowScheduler.add(ReadyRoutineEachFrame());
flowScheduler.add(ReadyRoutineEnd());
const trial_heartsLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trial_heartsLoopBegin, trial_heartsLoopScheduler);
flowScheduler.add(trial_heartsLoopScheduler);
flowScheduler.add(trial_heartsLoopEnd);
flowScheduler.add(IntroA_3RoutineBegin());
flowScheduler.add(IntroA_3RoutineEachFrame());
flowScheduler.add(IntroA_3RoutineEnd());
flowScheduler.add(IntroB_3RoutineBegin());
flowScheduler.add(IntroB_3RoutineEachFrame());
flowScheduler.add(IntroB_3RoutineEnd());
flowScheduler.add(Example3RoutineBegin());
flowScheduler.add(Example3RoutineEachFrame());
flowScheduler.add(Example3RoutineEnd());
flowScheduler.add(Example4RoutineBegin());
flowScheduler.add(Example4RoutineEachFrame());
flowScheduler.add(Example4RoutineEnd());
flowScheduler.add(Quick_Reminder_IncongruentRoutineBegin());
flowScheduler.add(Quick_Reminder_IncongruentRoutineEachFrame());
flowScheduler.add(Quick_Reminder_IncongruentRoutineEnd());
flowScheduler.add(Practice_IncongruentRoutineBegin());
flowScheduler.add(Practice_IncongruentRoutineEachFrame());
flowScheduler.add(Practice_IncongruentRoutineEnd());
const practice_incongruent_1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_incongruent_1LoopBegin, practice_incongruent_1LoopScheduler);
flowScheduler.add(practice_incongruent_1LoopScheduler);
flowScheduler.add(practice_incongruent_1LoopEnd);
flowScheduler.add(incongruent_reminderRoutineBegin());
flowScheduler.add(incongruent_reminderRoutineEachFrame());
flowScheduler.add(incongruent_reminderRoutineEnd());
const practice_incongruent_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_incongruent_2LoopBegin, practice_incongruent_2LoopScheduler);
flowScheduler.add(practice_incongruent_2LoopScheduler);
flowScheduler.add(practice_incongruent_2LoopEnd);
flowScheduler.add(Ready2RoutineBegin());
flowScheduler.add(Ready2RoutineEachFrame());
flowScheduler.add(Ready2RoutineEnd());
const trial_flowersLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trial_flowersLoopBegin, trial_flowersLoopScheduler);
flowScheduler.add(trial_flowersLoopScheduler);
flowScheduler.add(trial_flowersLoopEnd);
flowScheduler.add(IntroA_4RoutineBegin());
flowScheduler.add(IntroA_4RoutineEachFrame());
flowScheduler.add(IntroA_4RoutineEnd());
flowScheduler.add(IntroB_5RoutineBegin());
flowScheduler.add(IntroB_5RoutineEachFrame());
flowScheduler.add(IntroB_5RoutineEnd());
flowScheduler.add(IntroC_11RoutineBegin());
flowScheduler.add(IntroC_11RoutineEachFrame());
flowScheduler.add(IntroC_11RoutineEnd());
flowScheduler.add(IntroC_2RoutineBegin());
flowScheduler.add(IntroC_2RoutineEachFrame());
flowScheduler.add(IntroC_2RoutineEnd());
flowScheduler.add(Quick_Reminder_MixedRoutineBegin());
flowScheduler.add(Quick_Reminder_MixedRoutineEachFrame());
flowScheduler.add(Quick_Reminder_MixedRoutineEnd());
flowScheduler.add(Practice_mixedRoutineBegin());
flowScheduler.add(Practice_mixedRoutineEachFrame());
flowScheduler.add(Practice_mixedRoutineEnd());
const practice_mixed_1LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_mixed_1LoopBegin, practice_mixed_1LoopScheduler);
flowScheduler.add(practice_mixed_1LoopScheduler);
flowScheduler.add(practice_mixed_1LoopEnd);
flowScheduler.add(reminder_mixedRoutineBegin());
flowScheduler.add(reminder_mixedRoutineEachFrame());
flowScheduler.add(reminder_mixedRoutineEnd());
const practice_mixed_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(practice_mixed_2LoopBegin, practice_mixed_2LoopScheduler);
flowScheduler.add(practice_mixed_2LoopScheduler);
flowScheduler.add(practice_mixed_2LoopEnd);
flowScheduler.add(Ready3RoutineBegin());
flowScheduler.add(Ready3RoutineEachFrame());
flowScheduler.add(Ready3RoutineEnd());
flowScheduler.add(mixed_firstRoutineBegin());
flowScheduler.add(mixed_firstRoutineEachFrame());
flowScheduler.add(mixed_firstRoutineEnd());
const trial_mixedLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trial_mixedLoopBegin, trial_mixedLoopScheduler);
flowScheduler.add(trial_mixedLoopScheduler);
flowScheduler.add(trial_mixedLoopEnd);
flowScheduler.add(Thank_YouRoutineBegin());
flowScheduler.add(Thank_YouRoutineEachFrame());
flowScheduler.add(Thank_YouRoutineEnd());
flowScheduler.add(oe_welcomeRoutineBegin());
flowScheduler.add(oe_welcomeRoutineEachFrame());
flowScheduler.add(oe_welcomeRoutineEnd());
flowScheduler.add(even_introRoutineBegin());
flowScheduler.add(even_introRoutineEachFrame());
flowScheduler.add(even_introRoutineEnd());
flowScheduler.add(even_eg1RoutineBegin());
flowScheduler.add(even_eg1RoutineEachFrame());
flowScheduler.add(even_eg1RoutineEnd());
flowScheduler.add(even_eg2RoutineBegin());
flowScheduler.add(even_eg2RoutineEachFrame());
flowScheduler.add(even_eg2RoutineEnd());
flowScheduler.add(oe_speed_instrRoutineBegin());
flowScheduler.add(oe_speed_instrRoutineEachFrame());
flowScheduler.add(oe_speed_instrRoutineEnd());
flowScheduler.add(oe_train_startRoutineBegin());
flowScheduler.add(oe_train_startRoutineEachFrame());
flowScheduler.add(oe_train_startRoutineEnd());
const even_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(even_train_loopLoopBegin, even_train_loopLoopScheduler);
flowScheduler.add(even_train_loopLoopScheduler);
flowScheduler.add(even_train_loopLoopEnd);
flowScheduler.add(even_test_startRoutineBegin());
flowScheduler.add(even_test_startRoutineEachFrame());
flowScheduler.add(even_test_startRoutineEnd());
const even_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(even_test_loopLoopBegin, even_test_loopLoopScheduler);
flowScheduler.add(even_test_loopLoopScheduler);
flowScheduler.add(even_test_loopLoopEnd);
flowScheduler.add(odd_introRoutineBegin());
flowScheduler.add(odd_introRoutineEachFrame());
flowScheduler.add(odd_introRoutineEnd());
flowScheduler.add(odd_eg1RoutineBegin());
flowScheduler.add(odd_eg1RoutineEachFrame());
flowScheduler.add(odd_eg1RoutineEnd());
flowScheduler.add(odd_eg2RoutineBegin());
flowScheduler.add(odd_eg2RoutineEachFrame());
flowScheduler.add(odd_eg2RoutineEnd());
flowScheduler.add(oe_speed_instrRoutineBegin());
flowScheduler.add(oe_speed_instrRoutineEachFrame());
flowScheduler.add(oe_speed_instrRoutineEnd());
flowScheduler.add(oe_train_startRoutineBegin());
flowScheduler.add(oe_train_startRoutineEachFrame());
flowScheduler.add(oe_train_startRoutineEnd());
const odd_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(odd_train_loopLoopBegin, odd_train_loopLoopScheduler);
flowScheduler.add(odd_train_loopLoopScheduler);
flowScheduler.add(odd_train_loopLoopEnd);
flowScheduler.add(odd_test_startRoutineBegin());
flowScheduler.add(odd_test_startRoutineEachFrame());
flowScheduler.add(odd_test_startRoutineEnd());
const odd_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(odd_test_loopLoopBegin, odd_test_loopLoopScheduler);
flowScheduler.add(odd_test_loopLoopScheduler);
flowScheduler.add(odd_test_loopLoopEnd);
flowScheduler.add(oe_introRoutineBegin());
flowScheduler.add(oe_introRoutineEachFrame());
flowScheduler.add(oe_introRoutineEnd());
flowScheduler.add(oe_eg1RoutineBegin());
flowScheduler.add(oe_eg1RoutineEachFrame());
flowScheduler.add(oe_eg1RoutineEnd());
flowScheduler.add(oe_eg2RoutineBegin());
flowScheduler.add(oe_eg2RoutineEachFrame());
flowScheduler.add(oe_eg2RoutineEnd());
flowScheduler.add(oe_speed_instrRoutineBegin());
flowScheduler.add(oe_speed_instrRoutineEachFrame());
flowScheduler.add(oe_speed_instrRoutineEnd());
flowScheduler.add(oe_train_startRoutineBegin());
flowScheduler.add(oe_train_startRoutineEachFrame());
flowScheduler.add(oe_train_startRoutineEnd());
const oe_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(oe_train_loopLoopBegin, oe_train_loopLoopScheduler);
flowScheduler.add(oe_train_loopLoopScheduler);
flowScheduler.add(oe_train_loopLoopEnd);
flowScheduler.add(oe_test_startRoutineBegin());
flowScheduler.add(oe_test_startRoutineEachFrame());
flowScheduler.add(oe_test_startRoutineEnd());
const oe_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(oe_test_loopLoopBegin, oe_test_loopLoopScheduler);
flowScheduler.add(oe_test_loopLoopScheduler);
flowScheduler.add(oe_test_loopLoopEnd);
flowScheduler.add(Thank_YouRoutineBegin());
flowScheduler.add(Thank_YouRoutineEachFrame());
flowScheduler.add(Thank_YouRoutineEnd());
flowScheduler.add(welcomeRoutineBegin());
flowScheduler.add(welcomeRoutineEachFrame());
flowScheduler.add(welcomeRoutineEnd());
flowScheduler.add(Instructions_3RoutineBegin());
flowScheduler.add(Instructions_3RoutineEachFrame());
flowScheduler.add(Instructions_3RoutineEnd());
flowScheduler.add(ExampleRoutineBegin());
flowScheduler.add(ExampleRoutineEachFrame());
flowScheduler.add(ExampleRoutineEnd());
flowScheduler.add(lets_practiceRoutineBegin());
flowScheduler.add(lets_practiceRoutineEachFrame());
flowScheduler.add(lets_practiceRoutineEnd());
const trials_practice_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(trials_practice_loopLoopBegin, trials_practice_loopLoopScheduler);
flowScheduler.add(trials_practice_loopLoopScheduler);
flowScheduler.add(trials_practice_loopLoopEnd);
flowScheduler.add(readyRoutineBegin());
flowScheduler.add(readyRoutineEachFrame());
flowScheduler.add(readyRoutineEnd());
const blocks_2LoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(blocks_2LoopBegin, blocks_2LoopScheduler);
flowScheduler.add(blocks_2LoopScheduler);
flowScheduler.add(blocks_2LoopEnd);
flowScheduler.add(thank_you_5RoutineBegin());
flowScheduler.add(thank_you_5RoutineEachFrame());
flowScheduler.add(thank_you_5RoutineEnd());
flowScheduler.add(pm_welcomeRoutineBegin());
flowScheduler.add(pm_welcomeRoutineEachFrame());
flowScheduler.add(pm_welcomeRoutineEnd());
flowScheduler.add(plus_introRoutineBegin());
flowScheduler.add(plus_introRoutineEachFrame());
flowScheduler.add(plus_introRoutineEnd());
flowScheduler.add(plus_eg1RoutineBegin());
flowScheduler.add(plus_eg1RoutineEachFrame());
flowScheduler.add(plus_eg1RoutineEnd());
flowScheduler.add(plus_eg2RoutineBegin());
flowScheduler.add(plus_eg2RoutineEachFrame());
flowScheduler.add(plus_eg2RoutineEnd());
flowScheduler.add(pm_train_startRoutineBegin());
flowScheduler.add(pm_train_startRoutineEachFrame());
flowScheduler.add(pm_train_startRoutineEnd());
const plus_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(plus_train_loopLoopBegin, plus_train_loopLoopScheduler);
flowScheduler.add(plus_train_loopLoopScheduler);
flowScheduler.add(plus_train_loopLoopEnd);
flowScheduler.add(plus_test_startRoutineBegin());
flowScheduler.add(plus_test_startRoutineEachFrame());
flowScheduler.add(plus_test_startRoutineEnd());
const plus_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(plus_test_loopLoopBegin, plus_test_loopLoopScheduler);
flowScheduler.add(plus_test_loopLoopScheduler);
flowScheduler.add(plus_test_loopLoopEnd);
flowScheduler.add(minus_introRoutineBegin());
flowScheduler.add(minus_introRoutineEachFrame());
flowScheduler.add(minus_introRoutineEnd());
flowScheduler.add(minus_eg1RoutineBegin());
flowScheduler.add(minus_eg1RoutineEachFrame());
flowScheduler.add(minus_eg1RoutineEnd());
flowScheduler.add(minus_eg2RoutineBegin());
flowScheduler.add(minus_eg2RoutineEachFrame());
flowScheduler.add(minus_eg2RoutineEnd());
flowScheduler.add(pm_train_startRoutineBegin());
flowScheduler.add(pm_train_startRoutineEachFrame());
flowScheduler.add(pm_train_startRoutineEnd());
const minus_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(minus_train_loopLoopBegin, minus_train_loopLoopScheduler);
flowScheduler.add(minus_train_loopLoopScheduler);
flowScheduler.add(minus_train_loopLoopEnd);
flowScheduler.add(minus_test_startRoutineBegin());
flowScheduler.add(minus_test_startRoutineEachFrame());
flowScheduler.add(minus_test_startRoutineEnd());
const minus_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(minus_test_loopLoopBegin, minus_test_loopLoopScheduler);
flowScheduler.add(minus_test_loopLoopScheduler);
flowScheduler.add(minus_test_loopLoopEnd);
flowScheduler.add(pm_introRoutineBegin());
flowScheduler.add(pm_introRoutineEachFrame());
flowScheduler.add(pm_introRoutineEnd());
flowScheduler.add(pm_eg1RoutineBegin());
flowScheduler.add(pm_eg1RoutineEachFrame());
flowScheduler.add(pm_eg1RoutineEnd());
flowScheduler.add(pm_eg2RoutineBegin());
flowScheduler.add(pm_eg2RoutineEachFrame());
flowScheduler.add(pm_eg2RoutineEnd());
flowScheduler.add(pm_train_startRoutineBegin());
flowScheduler.add(pm_train_startRoutineEachFrame());
flowScheduler.add(pm_train_startRoutineEnd());
const pm_train_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(pm_train_loopLoopBegin, pm_train_loopLoopScheduler);
flowScheduler.add(pm_train_loopLoopScheduler);
flowScheduler.add(pm_train_loopLoopEnd);
flowScheduler.add(pm_test_startRoutineBegin());
flowScheduler.add(pm_test_startRoutineEachFrame());
flowScheduler.add(pm_test_startRoutineEnd());
const pm_test_loopLoopScheduler = new Scheduler(psychoJS);
flowScheduler.add(pm_test_loopLoopBegin, pm_test_loopLoopScheduler);
flowScheduler.add(pm_test_loopLoopScheduler);
flowScheduler.add(pm_test_loopLoopEnd);
flowScheduler.add(End_2RoutineBegin());
flowScheduler.add(End_2RoutineEachFrame());
flowScheduler.add(End_2RoutineEnd());
flowScheduler.add(quitPsychoJS, '', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, '', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  });

psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.DEBUG);


var frameDur;
function updateInfo() {
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2020.2.8';
  expInfo['OS'] = window.navigator.platform;

  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  
  return Scheduler.Event.NEXT;
}


var WelcomeClock;
var text_12;
var text_13;
var key_resp_8;
var end_experiment;
var timer;
var timer_exp;
var beginning_exp;
var beginning_exp2;
var overal_ef_assessment_instructionsClock;
var text_130;
var text_131;
var key_resp_57;
var image_29;
var IntroductionClock;
var text_14;
var text_16;
var key_resp_9;
var Circles_Example_1Clock;
var init_circle;
var init_circle_17;
var init_circle_18;
var init_circle_19;
var init_circle_20;
var init_circle_21;
var init_circle_22;
var init_circle_23;
var init_circle_24;
var init_circle_25;
var init_circle_26;
var init_circle_27;
var init_circle_28;
var init_circle_29;
var init_circle_30;
var init_circle_31;
var For_example;
var Circles_Example_2Clock;
var init_circle_32;
var init_circle_33;
var init_circle_34;
var C4_circle_lights_up;
var init_circle_36;
var init_circle_37;
var init_circle_38;
var init_circle_39;
var init_circle_40;
var init_circle_41;
var init_circle_42;
var init_circle_43;
var init_circle_44;
var init_circle_45;
var init_circle_46;
var init_circle_47;
var For_example_2;
var Circles_Example_3Clock;
var init_circle_35;
var init_circle_48;
var init_circle_49;
var init_circle_63;
var init_circle_50;
var circle_6_lights_up;
var init_circle_52;
var init_circle_53;
var init_circle_54;
var init_circle_55;
var init_circle_56;
var init_circle_57;
var init_circle_58;
var init_circle_59;
var init_circle_60;
var init_circle_61;
var b_For_example_4;
var Circle_Example_4Clock;
var init_circle_51;
var init_circle_62;
var init_circle_64;
var init_circle_65;
var init_circle_66;
var init_circle_80;
var init_circle_67;
var init_circle_68;
var init_circle_69;
var init_circle_70;
var init_circle_71;
var init_circle_72;
var init_circle_73;
var init_circle_74;
var circle_15_lights_up;
var init_circle_76;
var For_example_5;
var Initial_CirclesClock;
var init_circle_1;
var init_circle_2;
var init_circle_3;
var init_circle_4;
var init_circle_5;
var init_circle_6;
var init_circle_7;
var init_circle_8;
var init_circle_9;
var init_circle_10;
var init_circle_11;
var init_circle_12;
var init_circle_13;
var init_circle_14;
var init_circle_15;
var init_circle_16;
var Circle_Example_5AClock;
var first_response_C1_example;
var first_response_C2_example;
var first_response_C3_example;
var first_response_C4_example;
var first_response_C5_example;
var first_response_C6_example;
var first_response_C7_example;
var first_response_C8_example;
var first_response_C9_example;
var first_response_C10_example;
var first_response_C11_example;
var first_response_C12_example;
var first_response_C13_example;
var first_response_C14_example;
var first_response_C15_example;
var first_response_C16_example;
var first_mouse_response_example;
var polygon;
var triangle;
var push_these_circles;
var Circle_Example_6Clock;
var second_response_C1_example;
var second_response_C2_example;
var second_response_C3_example;
var second_response_C4_example;
var second_response_C5_example;
var second_response_C6_example;
var second_response_C7_example;
var second_response_C8_example;
var second_response_C9_example;
var second_response_C10_example;
var second_response_C11_example;
var second_response_C12_example;
var second_response_C13_example;
var second_response_C14_example;
var second_response_C15_example;
var second_response_C16_example;
var second_mouse_response_example;
var polygon_2;
var triangle_2;
var push_these_circles_2;
var Circle_Example_7Clock;
var third_response_C1_example;
var third_response_C2_example;
var third_response_C3_example;
var third_response_C4_example;
var third_response_C5_example;
var third_response_C6_example;
var third_response_C7_example;
var third_response_C8_example;
var third_response_C9_example;
var third_response_C10_example;
var third_response_C11_example;
var third_response_C12_example;
var third_response_C13_example;
var third_response_C14_example;
var third_response_C15_example;
var third_response_C16_example;
var third_mouse_response_example;
var polygon_3;
var triangle_3;
var push_these_circles_3;
var Start_PracticeClock;
var practice_text;
var spacebar_text;
var mouse;
var Update_loopClock;
var circle_loop;
var Check_practice_overClock;
var text_3;
var mouse_2;
var mouse_click_text;
var check_first_round_practiceClock;
var First_Circle_PresentationClock;
var first_circle_pres_C1;
var first_circle_pres_C2;
var first_circle_pres_C3;
var first_circle_pres_C4;
var first_circle_pres_C5;
var first_circle_pres_C6;
var first_circle_pres_C7;
var first_circle_pres_C8;
var first_circle_pres_C9;
var first_circle_pres_C10;
var first_circle_pres_C11;
var first_circle_pres_C12;
var first_circle_pres_C13;
var first_circle_pres_C14;
var first_circle_pres_C15;
var first_circle_pres_C16;
var Second_Circle_PresentationClock;
var second_circle_pres_C1;
var second_circle_pres_C2;
var second_circle_pres_C3;
var second_circle_pres_C4;
var second_circle_pres_C5;
var second_circle_pres_C6;
var second_circle_pres_C7;
var second_circle_pres_C8;
var second_circle_pres_C9;
var second_circle_pres_C10;
var second_circle_pres_C11;
var second_circle_pres_C12;
var second_circle_pres_C13;
var second_circle_pres_C14;
var second_circle_pres_C15;
var second_circle_pres_C16;
var Third_Circle_PresentationClock;
var third_circle_pres_C1;
var third_circle_pres_C2;
var third_circle_pres_C3;
var third_circle_pres_C4;
var third_circle_pres_C5;
var third_circle_pres_C6;
var third_circle_pres_C7;
var third_circle_pres_C8;
var third_circle_pres_C9;
var third_circle_pres_C10;
var third_circle_pres_C11;
var third_circle_pres_C12;
var third_circle_pres_C13;
var third_circle_pres_C14;
var third_circle_pres_C15;
var third_circle_pres_C16;
var Fourth_Circle_PresentationClock;
var fourth_circle_pres_C1;
var fourth_circle_pres_C2;
var fourth_circle_pres_C3;
var fourth_circle_pres_C4;
var fourth_circle_pres_C5;
var fourth_circle_pres_C6;
var fourth_circle_pres_C7;
var fourth_circle_pres_C8;
var fourth_circle_pres_C9;
var fourth_circle_pres_C10;
var fourth_circle_pres_C11;
var fourth_circle_pres_C12;
var fourth_circle_pres_C13;
var fourth_circle_pres_C14;
var fourth_circle_pres_C15;
var fourth_circle_pres_C16;
var Fifth_Circle_PresentationClock;
var fifth_circle_pres_C1;
var fifth_circle_pres_C2;
var fifth_circle_pres_C3;
var fifth_circle_pres_C4;
var fifth_circle_pres_C5;
var fifth_circle_pres_C6;
var fifth_circle_pres_C7;
var fifth_circle_pres_C8;
var fifth_circle_pres_C9;
var fifth_circle_pres_C10;
var fifth_circle_pres_C11;
var fifth_circle_pres_C12;
var fifth_circle_pres_C13;
var fifth_circle_pres_C14;
var fifth_circle_pres_C15;
var fifth_circle_pres_C16;
var Sixth_Circle_PresentationClock;
var sixth_circle_pres_C1;
var sixth_circle_pres_C2;
var sixth_circle_pres_C3;
var sixth_circle_pres_C4;
var sixth_circle_pres_C5;
var sixth_circle_pres_C6;
var sixth_circle_pres_C7;
var sixth_circle_pres_C8;
var sixth_circle_pres_C9;
var sixth_circle_pres_C10;
var sixth_circle_pres_C11;
var sixth_circle_pres_C12;
var sixth_circle_pres_C13;
var sixth_circle_pres_C14;
var sixth_circle_pres_C15;
var sixth_circle_pres_C16;
var Seventh_Circle_PresentationClock;
var seventh_circle_pres_C1;
var seventh_circle_pres_C2;
var seventh_circle_pres_C3;
var seventh_circle_pres_C4;
var seventh_circle_pres_C5;
var seventh_circle_pres_C6;
var seventh_circle_pres_C7;
var seventh_circle_pres_C8;
var seventh_circle_pres_C9;
var seventh_circle_pres_C10;
var seventh_circle_pres_C11;
var seventh_circle_pres_C12;
var seventh_circle_pres_C13;
var seventh_circle_pres_C14;
var seventh_circle_pres_C15;
var seventh_circle_pres_C16;
var Eighth_Circle_PresentationClock;
var eighth_circle_pres_C1;
var eighth_circle_pres_C2;
var eighth_circle_pres_C3;
var eighth_circle_pres_C4;
var eighth_circle_pres_C5;
var eighth_circle_pres_C6;
var eighth_circle_pres_C7;
var eighth_circle_pres_C8;
var eighth_circle_pres_C9;
var eighth_circle_pres_C10;
var eighth_circle_pres_C11;
var eighth_circle_pres_C12;
var eighth_circle_pres_C13;
var eighth_circle_pres_C14;
var eighth_circle_pres_C15;
var eighth_circle_pres_C16;
var Wait_for_First_responseClock;
var first_response_C1;
var first_response_C2;
var first_response_C3;
var first_response_C4;
var first_response_C5;
var first_response_C6;
var first_response_C7;
var first_response_C8;
var first_response_C9;
var first_response_C10;
var first_response_C11;
var first_response_C12;
var first_response_C13;
var first_response_C14;
var first_response_C15;
var first_response_C16;
var first_mouse_response;
var Wait_for_Second_responseClock;
var second_response_C1;
var second_response_C2;
var second_response_C3;
var second_response_C4;
var second_response_C5;
var second_response_C6;
var second_response_C7;
var second_response_C8;
var second_response_C9;
var second_response_C10;
var second_response_C11;
var second_response_C12;
var second_response_C13;
var second_response_C14;
var second_response_C15;
var second_response_C16;
var second_mouse_response;
var Wait_for_Third_ResponseClock;
var third_response_C1;
var third_response_C2;
var third_response_C3;
var third_response_C4;
var third_response_C5;
var third_response_C6;
var third_response_C7;
var third_response_C8;
var third_response_C9;
var third_response_C10;
var third_response_C11;
var third_response_C12;
var third_response_C13;
var third_response_C14;
var third_response_C15;
var third_response_C16;
var third_mouse_response;
var Wait_for_Fourth_ResponseClock;
var fourth_response_C1;
var fourth_response_C2;
var fourth_response_C3;
var fourth_response_C4;
var fourth_response_C5;
var fourth_response_C6;
var fourth_response_C7;
var fourth_response_C8;
var fourth_response_C9;
var fourth_response_C10;
var fourth_response_C11;
var fourth_response_C12;
var fourth_response_C13;
var fourth_response_C14;
var fourth_response_C15;
var fourth_response_C16;
var fourth_mouse_response;
var Wait_for_Fifth_ResponseClock;
var fifth_response_C1;
var fifth_response_C2;
var fifth_response_C3;
var fifth_response_C4;
var fifth_response_C5;
var fifth_response_C6;
var fifth_response_C7;
var fifth_response_C8;
var fifth_response_C9;
var fifth_response_C10;
var fifth_response_C11;
var fifth_response_C12;
var fifth_response_C13;
var fifth_response_C14;
var fifth_response_C15;
var fifth_response_C16;
var fifth_mouse_response;
var Wait_For_Sixth_ResponseClock;
var sixth_response_C1;
var sixth_response_C2;
var sixth_response_C3;
var sixth_response_C4;
var sixth_response_C5;
var sixth_response_C6;
var sixth_response_C7;
var sixth_response_C8;
var sixth_response_C9;
var sixth_response_C10;
var sixth_response_C11;
var sixth_response_C12;
var sixth_response_C13;
var sixth_response_C14;
var sixth_response_C15;
var sixth_response_C16;
var sixth_mouse_response;
var Wait_For_Seventh_ResponseClock;
var seventh_response_C1;
var seventh_response_C2;
var seventh_response_C3;
var seventh_response_C4;
var seventh_response_C5;
var seventh_response_C6;
var seventh_response_C7;
var seventh_response_C8;
var seventh_response_C9;
var seventh_response_C10;
var seventh_response_C11;
var seventh_response_C12;
var seventh_response_C13;
var seventh_response_C14;
var seventh_response_C15;
var seventh_response_C16;
var seventh_mouse_response;
var Wait_For_Eighth_ResponseClock;
var eighth_response_C1;
var eighth_response_C2;
var eighth_response_C3;
var eighth_response_C4;
var eighth_response_C5;
var eighth_response_C6;
var eighth_response_C7;
var eighth_response_C8;
var eighth_response_C9;
var eighth_response_C10;
var eighth_response_C11;
var eighth_response_C12;
var eighth_response_C13;
var eighth_response_C14;
var eighth_response_C15;
var eighth_response_C16;
var eighth_mouse_response;
var Check_outcomeClock;
var corr;
var Blank_ScreenClock;
var text;
var feedbackClock;
var text_4;
var msg;
var Repeat_InstructionsClock;
var repeat_inst;
var key_resp;
var text_5;
var check_end_experimentClock;
var Get_ExperimenterClock;
var text_11;
var b_text_15;
var InstructionsClock;
var instructions;
var key_resp_2;
var trial_counter;
var condition_counter;
var get_readyClock;
var text_6;
var key_resp_3;
var text_7;
var code_metaClock;
var Presentation_practiceClock;
var fixation_2;
var pres_text_2;
var Recall_practiceClock;
var recall_text_2;
var key_resp_4;
var allResponses_p;
var current_resp;
var pts_response_2;
var feedback_practiceClock;
var text_8;
var code_endClock;
var repeat_instructionsClock;
var text_9;
var key_resp_6;
var text_10;
var real_trialsClock;
var get_ready_real_trial;
var press_space;
var key_resp_5;
var PresentationClock;
var fixation;
var pres_text;
var RecallClock;
var recall_text;
var key_resp_7;
var allResponses;
var pts_response;
var FeedbackClock;
var EndClock;
var thank_you;
var before_closing;
var Welcome_2Clock;
var white_background_10;
var text_15;
var text_17;
var key_resp_10;
var IntroA_2Clock;
var white_background_25;
var image_11;
var text_40;
var text_46;
var key_resp_27;
var IntroB_2Clock;
var white_background_21;
var text_52;
var text_53;
var key_resp_28;
var Example1Clock;
var white_background_14;
var text_18;
var image_3;
var key_resp_11;
var text_60;
var Example2Clock;
var white_background_12;
var text_19;
var image_4;
var key_resp_12;
var text_61;
var Quick_ReminderClock;
var white_background_19;
var text_71;
var key_resp_32;
var text_72;
var Practice_congruentClock;
var white_background_7;
var text_20;
var text_21;
var key_resp_13;
var Practice_trial_congruentClock;
var white_background_17;
var text_22;
var text_64;
var image_5;
var text_28;
var key_resp_14;
var feedback_hf_congruent_1Clock;
var white_background_33;
var text_108;
var congruent_reminderClock;
var white_background_41;
var text_102;
var text_103;
var key_resp_37;
var eachResp;
var Practice_trial_congruent_2Clock;
var white_background_32;
var text_93;
var text_94;
var image_13;
var text_95;
var key_resp_21;
var feedback_hf_congruent_2Clock;
var white_background_34;
var text_114;
var ReadyClock;
var white_background_30;
var text_29;
var key_resp_15;
var text_30;
var HeartsClock;
var white_background_6;
var text_23;
var text_65;
var hearts;
var text_31;
var heart_resp;
var IntroA_3Clock;
var white_background_26;
var text_32;
var key_resp_16;
var text_33;
var image_12;
var IntroB_3Clock;
var white_background_20;
var text_47;
var text_34;
var key_resp_17;
var Example3Clock;
var white_background_13;
var text_35;
var image_6;
var key_resp_18;
var text_62;
var Example4Clock;
var white_background_11;
var text_36;
var image_7;
var key_resp_19;
var text_63;
var Quick_Reminder_IncongruentClock;
var white_background_28;
var text_75;
var key_resp_34;
var text_76;
var Practice_IncongruentClock;
var white_background_8;
var text_37;
var text_38;
var key_resp_20;
var Practice_trial_incongruentClock;
var white_background_22;
var text_39;
var text_66;
var image_8;
var text_48;
var key_resp_22;
var feedback_hf_incongruent_1Clock;
var white_background_38;
var text_113;
var incongruent_reminderClock;
var white_background_42;
var text_104;
var text_105;
var key_resp_38;
var Practice_trial_incongruent_2Clock;
var white_background_35;
var text_96;
var text_97;
var image_14;
var text_98;
var key_resp_23;
var feedback_hf_incongruent_2Clock;
var white_background_37;
var text_112;
var Ready2Clock;
var white_background_3;
var text_49;
var text_50;
var key_resp_24;
var FlowersClock;
var white_background_16;
var text_51;
var text_67;
var image;
var text_54;
var key_resp_25;
var IntroA_4Clock;
var white_background_27;
var text_55;
var key_resp_26;
var text_56;
var IntroB_5Clock;
var white_background_18;
var text_57;
var text_58;
var key_resp_29;
var IntroC_11Clock;
var white_background_23;
var text_69;
var text_70;
var key_resp_31;
var IntroC_2Clock;
var white_background_24;
var text_73;
var text_74;
var key_resp_30;
var Quick_Reminder_MixedClock;
var white_background_29;
var text_77;
var key_resp_33;
var text_78;
var Practice_mixedClock;
var white_background_2;
var text_79;
var key_resp_35;
var text_80;
var Practice_trial_mixedClock;
var white_background_15;
var text_81;
var text_82;
var image_9;
var text_83;
var key_resp_36;
var feedback_hf_mixed_1Clock;
var white_background_39;
var text_110;
var reminder_mixedClock;
var white_background_43;
var text_106;
var text_107;
var key_resp_39;
var Practice_trial_mixed_2Clock;
var white_background_36;
var text_99;
var text_100;
var image_15;
var text_101;
var key_resp_40;
var feedback_hf_mixed_2Clock;
var white_background_40;
var text_109;
var Ready3Clock;
var white_background_4;
var text_84;
var key_resp_41;
var text_85;
var mixed_firstClock;
var white_background_9;
var text_86;
var text_87;
var image_10;
var text_88;
var key_resp_42;
var MixedClock;
var white_background_5;
var text_89;
var text_90;
var image_2;
var text_91;
var key_resp_43;
var Thank_YouClock;
var text_92;
var text_111;
var oe_welcomeClock;
var oe_welcome_txt_top;
var oe_welcome_txt_bot;
var oe_welcome_key_resp;
var even_introClock;
var even_intro_txt_top;
var even_intro_txt_bot;
var even_intro_key_resp;
var even_eg1Clock;
var even_eg1_txt_top;
var even_eg1_txt_num;
var even_eg1_txt_bot;
var even_eg1_key_resp;
var even_eg2Clock;
var even_eg2_txt_top;
var even_eg2_txt_num;
var even_eg2_txt_bot;
var even_eg2_key_resp;
var oe_speed_instrClock;
var oe_speed_instr_top;
var oe_speed_instr_bot;
var oe_speed_instr_key_resp;
var oe_train_startClock;
var oe_train_start_txt;
var oe_train_start_key_resp;
var oe_trialClock;
var oe_trial_fixation;
var oe_trial_txt_num;
var oe_trial_key_resp;
var oe_feedbackClock;
var oe_feedback_txt;
var even_test_startClock;
var even_test_start_txt;
var even_test_start_key_resp;
var odd_introClock;
var odd_intro_txt_top;
var odd_intro_txt_bot;
var odd_intro_key_resp;
var odd_eg1Clock;
var odd_eg1_txt_top;
var odd_eg1_txt_num;
var odd_eg1_txt_bot;
var odd_eg1_key_resp;
var odd_eg2Clock;
var odd_eg2_txt_top;
var odd_eg2_txt_num;
var odd_eg2_txt_bot;
var odd_eg2_key_resp;
var odd_test_startClock;
var odd_test_start_txt;
var odd_test_start_key_resp;
var oe_introClock;
var oe_intro_txt_top;
var oe_intro_txt_bot;
var oe_intro_key_resp;
var oe_eg1Clock;
var oe_eg1_txt_top;
var oe_eg1_txt_num;
var oe_eg1_txt_bot;
var oe_eg1_key_resp;
var oe_eg2Clock;
var oe_eg2_txt_top;
var oe_eg2_txt_num;
var oe_eg2_txt_bot;
var oe_eg2_key_resp;
var oe_test_startClock;
var oe_test_start_txt;
var oe_test_start_key_resp;
var welcomeClock;
var text_122;
var text_123;
var key_resp_52;
var Instructions_3Clock;
var instructions_2;
var key_resp_53;
var text_124;
var ExampleClock;
var example_text;
var example;
var example_text_2;
var key_resp_54;
var lets_practiceClock;
var text_125;
var key_resp_55;
var text_126;
var trials_practice_2Clock;
var fixation_4;
var one_red_dot_2;
var two_yellow_triangles_2;
var three_green_crosses_2;
var four_blue_stars_2;
var trial_card_2;
var response_2;
var feedback_practice_2Clock;
var corr_trial_counter;
var prev;
var feedback_text_2;
var readyClock;
var text_127;
var text_128;
var key_resp_56;
var code_meta_2Clock;
var TrialsClock;
var fixation_5;
var one_red_dot;
var two_yellow_triangles;
var three_green_crosses;
var four_blue_stars;
var trial_card;
var response;
var Feedback_2Clock;
var feedback_text;
var code_end_2Clock;
var thank_you_5Clock;
var text_129;
var pm_welcomeClock;
var pm_welcome_txt_top;
var pm_welcome_txt_bot;
var pm_welcome_key_resp;
var plus_introClock;
var plus_intro_txt_top;
var plus_intro_txt_bot;
var plus_intro_key_resp;
var plus_eg1Clock;
var plus_eg1_txt_top;
var plus_eg1_txt_num;
var plus_eg1_txt_sym;
var plus_eg1_txt_bot;
var plus_eg1_key_resp;
var plus_eg1_resp_txt;
var plus_eg2Clock;
var plus_eg2_txt_top;
var plus_eg2_txt_num;
var plus_eg2_txt_sym;
var plus_eg2_txt_bot;
var plus_eg2_key_resp;
var plus_eg2_resp_txt;
var pm_train_startClock;
var pm_train_start_txt;
var pm_train_start_key_resp;
var pm_trialClock;
var pm_trial_fixation;
var pm_trial_txt_num;
var pm_trial_txt_sym;
var pm_trial_key_resp;
var pm_trial_resp_txt;
var pm_feedbackClock;
var pm_feedback_txt;
var plus_test_startClock;
var plus_test_start_txt;
var plus_test_start_key_resp;
var minus_introClock;
var minus_intro_txt_top;
var minus_intro_txt_bot;
var minus_intro_key_resp;
var minus_eg1Clock;
var minus_eg1_txt_top;
var minus_eg1_txt_num;
var minus_eg1_txt_sym;
var minus_eg1_txt_bot;
var minus_eg1_key_resp;
var minus_eg1_resp_txt;
var minus_eg2Clock;
var minus_eg2_txt_top;
var minus_eg2_txt_num;
var minus_eg2_txt_sym;
var minus_eg2_txt_bot;
var minus_eg2_key_resp;
var minus_eg2_resp_txt;
var minus_test_startClock;
var minus_test_start_txt;
var minus_test_start_key_resp;
var pm_introClock;
var pm_intro_txt_top;
var pm_intro_txt_bot;
var pm_intro_key_resp;
var pm_eg1Clock;
var pm_eg1_txt_top;
var pm_eg1_txt_num;
var pm_eg1_txt_sym;
var pm_eg1_txt_bot;
var pm_eg1_key_resp;
var pm_eg1_resp_txt;
var pm_eg2Clock;
var pm_eg2_txt_top;
var pm_eg2_txt_num;
var pm_eg2_txt_sym;
var pm_eg2_txt_bot;
var pm_eg2_key_resp;
var pm_eg2_resp_txt;
var pm_test_startClock;
var pm_test_start_txt;
var pm_test_start_key_resp;
var End_2Clock;
var thank_you_2;
var end;
var image_16;
var globalClock;
var routineTimer;
function experimentInit() {
  // Initialize components for Routine "Welcome"
  WelcomeClock = new util.Clock();
  text_12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_12',
    text: 'Welcome!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.16,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_13 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_13',
    text: 'Press space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  //x3 = expInfo["Enter participant ID"];
  //console.log(x3)
  //x2 = parseInt(x3.substr(-2));
  //console.log(x2)
  //x1 = parseInt(x2%5);
  //console.log(x1)
  
  //if (isNaN(x1)) {
  //  psychoJS.quit()
  //} 
  
  end_experiment = 0;
  timer = new util.Clock();
  timer_exp = new util.Clock();
  beginning_exp = timer.getTime();
  beginning_exp2 = timer_exp.getTime();
  psychoJS.experiment.addData("Browser", myBrowser)
  // Initialize components for Routine "overal_ef_assessment_instructions"
  overal_ef_assessment_instructionsClock = new util.Clock();
  text_130 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_130',
    text: 'Today, you will complete six computer tasks. \nIf you need to stop, please press escape twice and wait until you see this popup window before you exit.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: 1.5, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_131 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_131',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_57 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  image_29 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_29', units : undefined, 
    image : 'ef_math_saving_message.png', mask : undefined,
    ori : 0, pos : [0, (- 0.025)], size : [0.5, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -3.0 
  });
  // Initialize components for Routine "Introduction"
  IntroductionClock = new util.Clock();
  text_14 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_14',
    text: 'In this first task you will see some circles light up in order.\n\nYou will use your mouse to click on the circles in backwards order, meaning you will click the last circle first and the first circle last.',
    font: 'Arial',
    units: undefined, 
    pos: [0.0, 0.15], height: 0.05,  wrapWidth: 1.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_16 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_16',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Circles_Example_1"
  Circles_Example_1Clock = new util.Clock();
  init_circle = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_17 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_17', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_18 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_18', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  init_circle_19 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_19', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_20 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_20', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  init_circle_21 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_21', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_22 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_22', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_23 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_23', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_24 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_24', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_25 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_25', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_26 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_26', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_27 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_27', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_28 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_28', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_29 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_29', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  init_circle_30 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_30', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_31 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_31', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  For_example = new visual.TextStim({
    win: psychoJS.window,
    name: 'For_example',
    text: 'For example, if you saw the circles light up in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  // Initialize components for Routine "Circles_Example_2"
  Circles_Example_2Clock = new util.Clock();
  init_circle_32 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_32', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_33 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_33', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_34 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_34', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  C4_circle_lights_up = new visual.Polygon ({
    win: psychoJS.window, name: 'C4_circle_lights_up', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([1.0, 1.0, 1.0]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_36 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_36', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  init_circle_37 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_37', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_38 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_38', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_39 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_39', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_40 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_40', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_41 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_41', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_42 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_42', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_43 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_43', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_44 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_44', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_45 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_45', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  init_circle_46 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_46', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_47 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_47', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  For_example_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'For_example_2',
    text: 'For example, if you saw the circles light up in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  // Initialize components for Routine "Circles_Example_3"
  Circles_Example_3Clock = new util.Clock();
  init_circle_35 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_35', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_48 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_48', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_49 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_49', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  init_circle_63 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_63', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_50 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_50', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  circle_6_lights_up = new visual.Polygon ({
    win: psychoJS.window, name: 'circle_6_lights_up', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([1.0, 1.0, 1.0]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_52 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_52', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_53 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_53', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_54 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_54', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_55 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_55', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_56 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_56', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_57 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_57', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_58 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_58', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_59 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_59', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  init_circle_60 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_60', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_61 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_61', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  b_For_example_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'b_For_example_4',
    text: 'For example, if you saw the circles light up in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  // Initialize components for Routine "Circle_Example_4"
  Circle_Example_4Clock = new util.Clock();
  init_circle_51 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_51', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_62 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_62', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_64 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_64', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  init_circle_65 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_65', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_66 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_66', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  init_circle_80 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_80', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_67 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_67', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_68 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_68', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_69 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_69', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_70 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_70', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_71 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_71', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_72 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_72', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_73 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_73', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_74 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_74', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  circle_15_lights_up = new visual.Polygon ({
    win: psychoJS.window, name: 'circle_15_lights_up', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([1.0, 1.0, 1.0]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_76 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_76', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  For_example_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'For_example_5',
    text: 'For example, if you saw the circles light up in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -16.0 
  });
  
  // Initialize components for Routine "Initial_Circles"
  Initial_CirclesClock = new util.Clock();
  init_circle_1 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_2 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_3 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  init_circle_4 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_5 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  init_circle_6 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_7 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_8 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_9 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_10 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_11 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_12 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_13 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_14 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  init_circle_15 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_16 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  // Initialize components for Routine "Circle_Example_5A"
  Circle_Example_5AClock = new util.Clock();
  first_response_C1_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C1_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  first_response_C2_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C2_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  first_response_C3_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C3_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  first_response_C4_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C4_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  first_response_C5_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C5_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  first_response_C6_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C6_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  first_response_C7_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C7_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  first_response_C8_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C8_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  first_response_C9_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C9_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  first_response_C10_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C10_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  first_response_C11_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C11_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  first_response_C12_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C12_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  first_response_C13_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C13_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  first_response_C14_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C14_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  first_response_C15_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C15_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  first_response_C16_example = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C16_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  first_mouse_response_example = new core.Mouse({
    win: psychoJS.window,
  });
  first_mouse_response_example.mouseClock = new util.Clock();
  polygon = new visual.ShapeStim ({
    win: psychoJS.window, name: 'polygon', units : 'height', 
    vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
    ori: 0, pos: [0.25, (- 0.3)],
    lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -18, interpolate: true,
  });
  
  triangle = new visual.ShapeStim ({
    win: psychoJS.window, name: 'triangle', units : 'height', 
    vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
    ori: 90, pos: [0.23, (- 0.3)],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -19, interpolate: true,
  });
  
  push_these_circles = new visual.TextStim({
    win: psychoJS.window,
    name: 'push_these_circles',
    text: 'You would click on the circles in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  // Initialize components for Routine "Circle_Example_6"
  Circle_Example_6Clock = new util.Clock();
  second_response_C1_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C1_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  second_response_C2_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C2_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  second_response_C3_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C3_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  second_response_C4_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C4_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  second_response_C5_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C5_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  second_response_C6_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C6_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  second_response_C7_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C7_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  second_response_C8_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C8_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  second_response_C9_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C9_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  second_response_C10_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C10_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  second_response_C11_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C11_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  second_response_C12_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C12_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  second_response_C13_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C13_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  second_response_C14_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C14_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  second_response_C15_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C15_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  second_response_C16_example = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C16_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  second_mouse_response_example = new core.Mouse({
    win: psychoJS.window,
  });
  second_mouse_response_example.mouseClock = new util.Clock();
  polygon_2 = new visual.ShapeStim ({
    win: psychoJS.window, name: 'polygon_2', units : 'height', 
    vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
    ori: 0, pos: [(- 0.05), 0.1],
    lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -18, interpolate: true,
  });
  
  triangle_2 = new visual.ShapeStim ({
    win: psychoJS.window, name: 'triangle_2', units : 'height', 
    vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
    ori: 90, pos: [(- 0.07), 0.1],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -19, interpolate: true,
  });
  
  push_these_circles_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'push_these_circles_2',
    text: 'You would click on the circles in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  // Initialize components for Routine "Circle_Example_7"
  Circle_Example_7Clock = new util.Clock();
  third_response_C1_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C1_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  third_response_C2_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C2_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  third_response_C3_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C3_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  third_response_C4_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C4_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  third_response_C5_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C5_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  third_response_C6_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C6_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  third_response_C7_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C7_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  third_response_C8_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C8_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  third_response_C9_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C9_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  third_response_C10_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C10_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  third_response_C11_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C11_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  third_response_C12_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C12_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  third_response_C13_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C13_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  third_response_C14_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C14_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  third_response_C15_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C15_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  third_response_C16_example = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C16_example', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  third_mouse_response_example = new core.Mouse({
    win: psychoJS.window,
  });
  third_mouse_response_example.mouseClock = new util.Clock();
  polygon_3 = new visual.ShapeStim ({
    win: psychoJS.window, name: 'polygon_3', units : 'height', 
    vertices: [[-[0.05, 0.05][0]/2.0, 0], [+[0.05, 0.05][0]/2.0, 0]],
    ori: 0, pos: [0.55, 0.3],
    lineWidth: 4, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -18, interpolate: true,
  });
  
  triangle_3 = new visual.ShapeStim ({
    win: psychoJS.window, name: 'triangle_3', units : 'height', 
    vertices: [[-[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [+[0.02, 0.02][0]/2.0, -[0.02, 0.02][1]/2.0], [0, [0.02, 0.02][1]/2.0]],
    ori: 90, pos: [0.53, 0.3],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: -19, interpolate: true,
  });
  
  push_these_circles_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'push_these_circles_3',
    text: 'You would click on the circles in this order:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.85], height: 0.1,  wrapWidth: 2, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -20.0 
  });
  
  // Initialize components for Routine "Start_Practice"
  Start_PracticeClock = new util.Clock();
  practice_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'practice_text',
    text: 'Let’s practice.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: 1.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  spacebar_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'spacebar_text',
    text: 'Click the mouse to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 1.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  mouse = new core.Mouse({
    win: psychoJS.window,
  });
  mouse.mouseClock = new util.Clock();
  // Initialize components for Routine "Update_loop"
  Update_loopClock = new util.Clock();
  circle_loop = 0;
  
  // Initialize components for Routine "Check_practice_over"
  Check_practice_overClock = new util.Clock();
  text_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_3',
    text: "You'll now start the game. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: 1.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  mouse_2 = new core.Mouse({
    win: psychoJS.window,
  });
  mouse_2.mouseClock = new util.Clock();
  mouse_click_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'mouse_click_text',
    text: 'Click the mouse to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 1.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "check_first_round_practice"
  check_first_round_practiceClock = new util.Clock();
  // Initialize components for Routine "Initial_Circles"
  Initial_CirclesClock = new util.Clock();
  init_circle_1 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  init_circle_2 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  init_circle_3 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  init_circle_4 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  init_circle_5 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  init_circle_6 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  init_circle_7 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  init_circle_8 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  init_circle_9 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  init_circle_10 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  init_circle_11 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  init_circle_12 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  init_circle_13 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  init_circle_14 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  init_circle_15 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  init_circle_16 = new visual.Polygon ({
    win: psychoJS.window, name: 'init_circle_16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  // Initialize components for Routine "First_Circle_Presentation"
  First_Circle_PresentationClock = new util.Clock();
  first_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  first_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  first_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  first_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  first_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  first_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  first_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  first_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  first_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  first_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  first_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  first_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  first_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  first_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  first_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  first_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  // Initialize components for Routine "Second_Circle_Presentation"
  Second_Circle_PresentationClock = new util.Clock();
  second_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  second_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  second_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  second_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  second_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  second_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  second_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  second_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  second_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  second_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  second_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  second_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  second_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  second_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  second_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  second_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  // Initialize components for Routine "Third_Circle_Presentation"
  Third_Circle_PresentationClock = new util.Clock();
  third_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  third_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  third_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  third_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  third_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  third_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  third_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  third_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  third_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  third_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  third_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  third_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  third_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  third_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  third_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  third_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  // Initialize components for Routine "Fourth_Circle_Presentation"
  Fourth_Circle_PresentationClock = new util.Clock();
  fourth_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  fourth_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  fourth_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  fourth_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  fourth_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  fourth_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  fourth_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  fourth_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  fourth_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  fourth_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  fourth_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  fourth_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  fourth_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  fourth_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  fourth_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  fourth_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  // Initialize components for Routine "Fifth_Circle_Presentation"
  Fifth_Circle_PresentationClock = new util.Clock();
  fifth_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  fifth_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  fifth_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  fifth_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  fifth_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  fifth_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  fifth_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  fifth_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  fifth_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  fifth_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  fifth_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  fifth_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  fifth_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  fifth_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  fifth_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  fifth_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  // Initialize components for Routine "Sixth_Circle_Presentation"
  Sixth_Circle_PresentationClock = new util.Clock();
  sixth_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  sixth_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  sixth_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  sixth_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  sixth_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  sixth_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  sixth_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  sixth_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  sixth_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  sixth_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  sixth_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  sixth_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  sixth_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  sixth_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  sixth_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  sixth_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  // Initialize components for Routine "Seventh_Circle_Presentation"
  Seventh_Circle_PresentationClock = new util.Clock();
  seventh_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  seventh_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  seventh_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  seventh_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  seventh_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  seventh_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  seventh_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  seventh_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  seventh_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  seventh_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  seventh_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  seventh_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  seventh_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  seventh_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  seventh_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  seventh_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  // Initialize components for Routine "Eighth_Circle_Presentation"
  Eighth_Circle_PresentationClock = new util.Clock();
  eighth_circle_pres_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  eighth_circle_pres_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  eighth_circle_pres_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  eighth_circle_pres_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  eighth_circle_pres_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  eighth_circle_pres_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  eighth_circle_pres_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  eighth_circle_pres_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  eighth_circle_pres_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  eighth_circle_pres_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  eighth_circle_pres_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  eighth_circle_pres_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  eighth_circle_pres_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  eighth_circle_pres_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  eighth_circle_pres_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  eighth_circle_pres_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_circle_pres_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color(1.0),
    fillColor: new util.Color(1.0),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  // Initialize components for Routine "Wait_for_First_response"
  Wait_for_First_responseClock = new util.Clock();
  first_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  first_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  first_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  first_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  first_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  first_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  first_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  first_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  first_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  first_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  first_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  first_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  first_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  first_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  first_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  first_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'first_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  first_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  first_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_for_Second_response"
  Wait_for_Second_responseClock = new util.Clock();
  second_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  second_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  second_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  second_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  second_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  second_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  second_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  second_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  second_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  second_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  second_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  second_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  second_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  second_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  second_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  second_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'second_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  second_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  second_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_for_Third_Response"
  Wait_for_Third_ResponseClock = new util.Clock();
  third_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  third_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  third_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  third_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  third_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  third_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  third_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  third_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  third_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  third_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  third_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  third_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  third_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  third_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  third_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  third_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'third_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  third_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  third_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_for_Fourth_Response"
  Wait_for_Fourth_ResponseClock = new util.Clock();
  fourth_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  fourth_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  fourth_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  fourth_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  fourth_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  fourth_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  fourth_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  fourth_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  fourth_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  fourth_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  fourth_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  fourth_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  fourth_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  fourth_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  fourth_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  fourth_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'fourth_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  fourth_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  fourth_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_for_Fifth_Response"
  Wait_for_Fifth_ResponseClock = new util.Clock();
  fifth_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  fifth_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  fifth_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  fifth_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  fifth_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  fifth_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  fifth_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  fifth_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  fifth_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  fifth_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  fifth_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  fifth_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  fifth_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  fifth_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  fifth_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  fifth_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'fifth_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  fifth_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  fifth_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_For_Sixth_Response"
  Wait_For_Sixth_ResponseClock = new util.Clock();
  sixth_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  sixth_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  sixth_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  sixth_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  sixth_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  sixth_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  sixth_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  sixth_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  sixth_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  sixth_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  sixth_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  sixth_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  sixth_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  sixth_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  sixth_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  sixth_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'sixth_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  sixth_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  sixth_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_For_Seventh_Response"
  Wait_For_Seventh_ResponseClock = new util.Clock();
  seventh_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  seventh_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  seventh_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  seventh_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  seventh_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  seventh_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  seventh_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  seventh_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  seventh_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  seventh_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  seventh_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  seventh_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  seventh_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  seventh_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  seventh_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  seventh_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'seventh_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  seventh_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  seventh_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Wait_For_Eighth_Response"
  Wait_For_Eighth_ResponseClock = new util.Clock();
  eighth_response_C1 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C1', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -1, interpolate: true,
  });
  
  eighth_response_C2 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C2', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -2, interpolate: true,
  });
  
  eighth_response_C3 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C3', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -3, interpolate: true,
  });
  
  eighth_response_C4 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C4', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.3],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -4, interpolate: true,
  });
  
  eighth_response_C5 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C5', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -5, interpolate: true,
  });
  
  eighth_response_C6 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C6', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -6, interpolate: true,
  });
  
  eighth_response_C7 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C7', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -7, interpolate: true,
  });
  
  eighth_response_C8 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C8', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, 0.1],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -8, interpolate: true,
  });
  
  eighth_response_C9 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C9', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -9, interpolate: true,
  });
  
  eighth_response_C10 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C10', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -10, interpolate: true,
  });
  
  eighth_response_C11 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C11', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -11, interpolate: true,
  });
  
  eighth_response_C12 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C12', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.1)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -12, interpolate: true,
  });
  
  eighth_response_C13 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C13', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.45), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -13, interpolate: true,
  });
  
  eighth_response_C14 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C14', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [(- 0.15), (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -14, interpolate: true,
  });
  
  eighth_response_C15 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C15', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.15, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -15, interpolate: true,
  });
  
  eighth_response_C16 = new visual.Polygon ({
    win: psychoJS.window, name: 'eighth_response_C16', units : 'height', 
    edges: 90, size:[0.11, 0.11],
    ori: 0, pos: [0.45, (- 0.3)],
    lineWidth: 2, lineColor: new util.Color([1.0, 1.0, 1.0]),
    fillColor: new util.Color([(- 1.0), (- 1.0), (- 1.0)]),
    opacity: 1, depth: -16, interpolate: true,
  });
  
  eighth_mouse_response = new core.Mouse({
    win: psychoJS.window,
  });
  eighth_mouse_response.mouseClock = new util.Clock();
  // Initialize components for Routine "Check_outcome"
  Check_outcomeClock = new util.Clock();
  corr = 0;
  // Initialize components for Routine "Blank_Screen"
  Blank_ScreenClock = new util.Clock();
  text = new visual.TextStim({
    win: psychoJS.window,
    name: 'text',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "feedback"
  feedbackClock = new util.Clock();
  text_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_4',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  msg = '';
  // Initialize components for Routine "Repeat_Instructions"
  Repeat_InstructionsClock = new util.Clock();
  repeat_inst = new visual.TextStim({
    win: psychoJS.window,
    name: 'repeat_inst',
    text: 'Remember!\n\nYour job is to use the mouse to click on the circles in backwards order.\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_5',
    text: 'Press space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "check_end_experiment"
  check_end_experimentClock = new util.Clock();
  end_experiment = 0;
  
  // Initialize components for Routine "Get_Experimenter"
  Get_ExperimenterClock = new util.Clock();
  text_11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_11',
    text: 'Thank you! This is the end of the first task.\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  b_text_15 = new visual.TextStim({
    win: psychoJS.window,
    name: 'b_text_15',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 0.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Instructions"
  InstructionsClock = new util.Clock();
  instructions = new visual.TextStim({
    win: psychoJS.window,
    name: 'instructions',
    text: 'In the next task, you will see numbers on the screen appear one after another.\n\nWhen you see the "Recall" screen, type the numbers you saw in backwards order and press Enter. Backspace will not work.\n\nDo your best to remember the numbers and do not cheat. \n\nPress the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.04,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  trial_counter = 0;
  condition_counter = 0;
  // Initialize components for Routine "get_ready"
  get_readyClock = new util.Clock();
  text_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_6',
    text: 'Let’s practice!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_7',
    text: 'Press ‘space bar’ to continue',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "code_meta"
  code_metaClock = new util.Clock();
  // Initialize components for Routine "Presentation_practice"
  Presentation_practiceClock = new util.Clock();
  fixation_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_2',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  pres_text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'pres_text_2',
    text: 'a',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Recall_practice"
  Recall_practiceClock = new util.Clock();
  recall_text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'recall_text_2',
    text: 'Recall',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Store responses
  allResponses_p = []
  current_resp = '';
  pts_response_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'pts_response_2',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "feedback_practice"
  feedback_practiceClock = new util.Clock();
  text_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_8',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "code_end"
  code_endClock = new util.Clock();
  // Initialize components for Routine "repeat_instructions"
  repeat_instructionsClock = new util.Clock();
  text_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_9',
    text: 'Remember that your job is to type the numbers you saw in the opposite order you saw them',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_6 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_10',
    text: 'Press ‘space bar’ to continue',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "real_trials"
  real_trialsClock = new util.Clock();
  get_ready_real_trial = new visual.TextStim({
    win: psychoJS.window,
    name: 'get_ready_real_trial',
    text: 'Great! Let’s start the real task.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  press_space = new visual.TextStim({
    win: psychoJS.window,
    name: 'press_space',
    text: 'Press the space bar to continue',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Presentation"
  PresentationClock = new util.Clock();
  fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  pres_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'pres_text',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Recall"
  RecallClock = new util.Clock();
  recall_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'recall_text',
    text: 'Recall',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.25], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Store responses
  allResponses = []
  current_resp = ' ';
  pts_response = new visual.TextStim({
    win: psychoJS.window,
    name: 'pts_response',
    text: ' ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Feedback"
  FeedbackClock = new util.Clock();
  // Initialize components for Routine "End"
  EndClock = new util.Clock();
  thank_you = new visual.TextStim({
    win: psychoJS.window,
    name: 'thank_you',
    text: 'Thank you! This is the end of the second task.\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  before_closing = new visual.TextStim({
    win: psychoJS.window,
    name: 'before_closing',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.04,  wrapWidth: 0.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Welcome_2"
  Welcome_2Clock = new util.Clock();
  white_background_10 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_10', 
    width: [3, 3][0], height: [3, 3][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_15 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_15',
    text: 'Welcome!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_17 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_17',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroA_2"
  IntroA_2Clock = new util.Clock();
  white_background_25 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_25', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  image_11 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_11', units : undefined, 
    image : 'heart_only.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.0)], size : [0.4, 0.4],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 256, interpolate : false, depth : -1.0 
  });
  text_40 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_40',
    text: 'In this part of the task, you will see hearts.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.0825,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  text_46 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_46',
    text: 'Press the space bar to continue. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  key_resp_27 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroB_2"
  IntroB_2Clock = new util.Clock();
  white_background_21 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_21', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_52 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_52',
    text: 'You will see a heart on the left or right side and you will press the button on the same side as the heart. \n\nIf the heart is on the right, press ‘m’, and if the heart is on the left, press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_53 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_53',
    text: 'Press the space bar to continue. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_28 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Example1"
  Example1Clock = new util.Clock();
  white_background_14 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_14', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_18 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_18',
    text: 'In this example, the heart is on the right.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  image_3 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_3', units : undefined, 
    image : 'rightHeart.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.0)], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -2.0 
  });
  key_resp_11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_60 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_60',
    text: "Press 'm'",
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Example2"
  Example2Clock = new util.Clock();
  white_background_12 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_12', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_19 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_19',
    text: 'In this example, the heart is on the left.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  image_4 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_4', units : undefined, 
    image : 'leftHeart.jpg', mask : undefined,
    ori : 0, pos : [0, (- 0.0)], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -2.0 
  });
  key_resp_12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_61 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_61',
    text: "Press 'z'",
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Quick_Reminder"
  Quick_ReminderClock = new util.Clock();
  white_background_19 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_19', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_71 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_71',
    text: 'The hearts will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_32 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_72 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_72',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Practice_congruent"
  Practice_congruentClock = new util.Clock();
  white_background_7 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_7', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_20 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_20',
    text: "Let's practice!\n",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_21 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_21',
    text: "Press 'z' or 'm' to continue. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_13 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Practice_trial_congruent"
  Practice_trial_congruentClock = new util.Clock();
  white_background_17 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_17', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_22 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_22',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_64 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_64',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_5 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_5', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_28 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_28',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_14 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_congruent_1"
  feedback_hf_congruent_1Clock = new util.Clock();
  white_background_33 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_33', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_108 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_108',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "congruent_reminder"
  congruent_reminderClock = new util.Clock();
  white_background_41 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_41', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_102 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_102',
    text: 'Remember, will see a heart on the left or right side and you will press the button on the same side as the heart. \n\nIf the heart is on the right, press ‘m’, and if the heart is on the left, press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_103 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_103',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_37 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  var eachResp;
  eachResp=0;
  // Initialize components for Routine "Practice_trial_congruent_2"
  Practice_trial_congruent_2Clock = new util.Clock();
  white_background_32 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_32', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_93 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_93',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_94 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_94',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_13 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_13', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_95 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_95',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_21 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_congruent_2"
  feedback_hf_congruent_2Clock = new util.Clock();
  white_background_34 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_34', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_114 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_114',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Ready"
  ReadyClock = new util.Clock();
  white_background_30 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_30', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_29 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_29',
    text: "Let's play for real now.\n\nRemember, if the heart is on the left, press 'z' and if the heart is on the right, press 'm.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_15 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_30 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_30',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Hearts"
  HeartsClock = new util.Clock();
  white_background_6 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_6', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_23 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_23',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_65 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_65',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  hearts = new visual.ImageStim({
    win : psychoJS.window,
    name : 'hearts', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_31 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_31',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  heart_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroA_3"
  IntroA_3Clock = new util.Clock();
  white_background_26 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_26', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_32 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_32',
    text: 'Great job! In the next part of this task, you will see flowers.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.0825,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_16 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_33 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_33',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  image_12 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_12', units : undefined, 
    image : 'flower_only.jpg', mask : undefined,
    ori : 0, pos : [0, 0], size : [0.4, 0.4],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -4.0 
  });
  // Initialize components for Routine "IntroB_3"
  IntroB_3Clock = new util.Clock();
  white_background_20 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_20', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_47 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_47',
    text: "You will see a flower on the left or right and you will press the button on the opposite side as the flower. \n\nIf the flower is on the right, press 'z,' and if the flower is on the left, press 'm.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_34 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_34',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_17 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Example3"
  Example3Clock = new util.Clock();
  white_background_13 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_13', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_35 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_35',
    text: 'In this example, the flower is on the right.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  image_6 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_6', units : undefined, 
    image : 'rightFlower.jpg', mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -2.0 
  });
  key_resp_18 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_62 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_62',
    text: "Press 'z'",
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.4), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Example4"
  Example4Clock = new util.Clock();
  white_background_11 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_11', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_36 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_36',
    text: 'In this example, the flower is on the left.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  image_7 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_7', units : undefined, 
    image : 'leftFlower.jpg', mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -2.0 
  });
  key_resp_19 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_63 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_63',
    text: "Press 'm'",
    font: 'Arial',
    units: undefined, 
    pos: [0.4, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -4.0 
  });
  
  // Initialize components for Routine "Quick_Reminder_Incongruent"
  Quick_Reminder_IncongruentClock = new util.Clock();
  white_background_28 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_28', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_75 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_75',
    text: 'The flowers will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_34 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_76 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_76',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Practice_Incongruent"
  Practice_IncongruentClock = new util.Clock();
  white_background_8 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_8', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_37 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_37',
    text: "Let's practice!\n",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_38 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_38',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_20 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Practice_trial_incongruent"
  Practice_trial_incongruentClock = new util.Clock();
  white_background_22 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_22', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_39 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_39',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_66 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_66',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_8 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_8', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_48 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_48',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_22 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_incongruent_1"
  feedback_hf_incongruent_1Clock = new util.Clock();
  white_background_38 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_38', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_113 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_113',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "incongruent_reminder"
  incongruent_reminderClock = new util.Clock();
  white_background_42 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_42', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_104 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_104',
    text: "You will see a flower on the left or right and you will press the button on the opposite side as the flower. \n\nIf the flower is on the right, press 'z,' and if the flower is on the left, press 'm.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_105 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_105',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_38 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  var nCorrhf02;
  // Initialize components for Routine "Practice_trial_incongruent_2"
  Practice_trial_incongruent_2Clock = new util.Clock();
  white_background_35 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_35', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_96 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_96',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_97 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_97',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_14 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_14', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_98 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_98',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_23 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_incongruent_2"
  feedback_hf_incongruent_2Clock = new util.Clock();
  white_background_37 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_37', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_112 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_112',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Ready2"
  Ready2Clock = new util.Clock();
  white_background_3 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_3', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_49 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_49',
    text: "Let's play for real now. \n\n\nRemember, when the flower is on the left, press 'm,' and when the flower is on the right, press 'z.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_50 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_50',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.25)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_24 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Flowers"
  FlowersClock = new util.Clock();
  white_background_16 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_16', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_51 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_51',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_67 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_67',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_54 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_54',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_25 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroA_4"
  IntroA_4Clock = new util.Clock();
  white_background_27 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_27', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_55 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_55',
    text: "Great job! \n\nNow in this last part of the task, we'll put it all together.",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.0825,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_26 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_56 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_56',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "IntroB_5"
  IntroB_5Clock = new util.Clock();
  white_background_18 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_18', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_57 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_57',
    text: "In this next part of the task, you'll see both hearts and flowers. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_58 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_58',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_29 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroC_11"
  IntroC_11Clock = new util.Clock();
  white_background_23 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_23', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_69 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_69',
    text: "If you see a heart, press the button on the SAME side as the heart. \n\nIf the heart is on the right, press 'm,' and if the heart is on the left, press 'z.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_70 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_70',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_31 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "IntroC_2"
  IntroC_2Clock = new util.Clock();
  white_background_24 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_24', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_73 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_73',
    text: "If you see a flower, press the button on the OPPOSITE side. \n\n\nIf the flower is on the right, press 'z,' and if the flower is on the left, press 'm.'",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_74 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_74',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_30 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Quick_Reminder_Mixed"
  Quick_Reminder_MixedClock = new util.Clock();
  white_background_29 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_29', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_77 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_77',
    text: 'The hearts and flowers will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_33 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_78 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_78',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Practice_mixed"
  Practice_mixedClock = new util.Clock();
  white_background_2 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_2', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_79 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_79',
    text: "Let's practice!",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_35 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_80 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_80',
    text: "Press 'z' or 'm' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "Practice_trial_mixed"
  Practice_trial_mixedClock = new util.Clock();
  white_background_15 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_15', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_81 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_81',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_82 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_82',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_9 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_9', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_83 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_83',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_36 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_mixed_1"
  feedback_hf_mixed_1Clock = new util.Clock();
  white_background_39 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_39', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_110 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_110',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "reminder_mixed"
  reminder_mixedClock = new util.Clock();
  white_background_43 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_43', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_106 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_106',
    text: 'Remember! If you see a heart, press the button on the SAME side as the heart. \n\nIf you see a flower, press the button on the OPPOSITE side of the flower.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_107 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_107',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_39 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  var nCorrhf03;
  // Initialize components for Routine "Practice_trial_mixed_2"
  Practice_trial_mixed_2Clock = new util.Clock();
  white_background_36 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_36', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_99 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_99',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_100 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_100',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_15 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_15', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_101 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_101',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_40 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "feedback_hf_mixed_2"
  feedback_hf_mixed_2Clock = new util.Clock();
  white_background_40 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_40', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_109 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_109',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "Ready3"
  Ready3Clock = new util.Clock();
  white_background_4 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_4', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_84 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_84',
    text: "Let's play for real now. \n\n\nRemember, press the button on the SAME side as the heart.\n\n\nAnd press the button on the OPPOSITE side of the flower.",
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_41 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_85 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_85',
    text: "Press 'z' or 'm' to continue. ",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -3.0 
  });
  
  // Initialize components for Routine "mixed_first"
  mixed_firstClock = new util.Clock();
  white_background_9 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_9', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_86 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_86',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  text_87 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_87',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_10 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_10', units : undefined, 
    image : 'rightHeart.jpg', mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_88 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_88',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_42 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Mixed"
  MixedClock = new util.Clock();
  white_background_5 = new visual.Rect ({
    win: psychoJS.window, name: 'white_background_5', 
    width: [2, 2][0], height: [2, 2][1],
    ori: 0, pos: [0, 0],
    lineWidth: 1, lineColor: new util.Color([1, 1, 1]),
    fillColor: new util.Color([1, 1, 1]),
    opacity: 1, depth: 0, interpolate: true,
  });
  
  text_89 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_89',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.13,  wrapWidth: undefined, ori: 0,
    color: new util.Color('black'),  opacity: 1,
    depth: -1.0 
  });
  
  text_90 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_90',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  image_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_2', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, 0], size : [0.8, 0.3],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : false, depth : -3.0 
  });
  text_91 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_91',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  key_resp_43 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Thank_You"
  Thank_YouClock = new util.Clock();
  text_92 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_92',
    text: 'Great! This is the end of the fourth task.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_111 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_111',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 0.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "oe_welcome"
  oe_welcomeClock = new util.Clock();
  oe_welcome_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_welcome_txt_top',
    text: 'Welcome!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_welcome_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_welcome_txt_bot',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_welcome_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "even_intro"
  even_introClock = new util.Clock();
  even_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_intro_txt_top',
    text: 'In this task, you will see an even number on the left or right side. \n\nYou will press ‘z’ if the number is on the left and press ‘m’ if the number is on the right. \n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  even_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_intro_txt_bot',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  even_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "even_eg1"
  even_eg1Clock = new util.Clock();
  even_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg1_txt_top',
    text: 'In this example, the even number is on the left side. You will press the key on the same side as the number. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  even_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg1_txt_num',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  even_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg1_txt_bot',
    text: 'Press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  even_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "even_eg2"
  even_eg2Clock = new util.Clock();
  even_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg2_txt_top',
    text: 'In this example, the even number is on the right side. You will press the key on the same side as the number. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  even_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg2_txt_num',
    text: '8',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  even_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_eg2_txt_bot',
    text: 'Press ‘m’.',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  even_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_speed_instr"
  oe_speed_instrClock = new util.Clock();
  oe_speed_instr_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_top',
    text: 'The numbers will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_speed_instr_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_bot',
    text: 'Press ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_speed_instr_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_train_start"
  oe_train_startClock = new util.Clock();
  oe_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_feedback"
  oe_feedbackClock = new util.Clock();
  oe_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "even_test_start"
  even_test_startClock = new util.Clock();
  even_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'even_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will see an even number and press the key on the same side as the number.\n\n\n\n\nPress ‘spacebar’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  even_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "odd_intro"
  odd_introClock = new util.Clock();
  odd_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_intro_txt_top',
    text: 'In this task, you will see an odd number on the left or right side.\n\nYour job will to press ‘m’ if the number is on the left and press ‘z’ if the number is on the right. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  odd_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_intro_txt_bot',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  odd_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "odd_eg1"
  odd_eg1Clock = new util.Clock();
  odd_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg1_txt_top',
    text: 'In this example, the odd number is on the left side. Your job is to press the key on the opposite side of the number. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  odd_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg1_txt_num',
    text: '1',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  odd_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg1_txt_bot',
    text: 'Press ‘m’.',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  odd_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "odd_eg2"
  odd_eg2Clock = new util.Clock();
  odd_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg2_txt_top',
    text: 'In this example, the odd number is on the right side. Your job is to press the key on the opposite side of the number. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  odd_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg2_txt_num',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  odd_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_eg2_txt_bot',
    text: 'Press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  odd_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_speed_instr"
  oe_speed_instrClock = new util.Clock();
  oe_speed_instr_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_top',
    text: 'The numbers will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_speed_instr_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_bot',
    text: 'Press ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_speed_instr_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_train_start"
  oe_train_startClock = new util.Clock();
  oe_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_feedback"
  oe_feedbackClock = new util.Clock();
  oe_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "odd_test_start"
  odd_test_startClock = new util.Clock();
  odd_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'odd_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will see an odd number and press the key on the opposite side of the number.\n\n\n\nPress ‘spacebar’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  odd_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_intro"
  oe_introClock = new util.Clock();
  oe_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_intro_txt_top',
    text: 'In this task, you will see an odd or even number on the left or right side.\n\nYour job is to press the key on the same side of the number if it is even, but press the key on the opposite side of the number if it is odd.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_intro_txt_bot',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_eg1"
  oe_eg1Clock = new util.Clock();
  oe_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg1_txt_top',
    text: 'In this example, there is an even number on the left side. Your job is to respond on the same side as this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg1_txt_num',
    text: '2',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), 0.1], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg1_txt_bot',
    text: 'Press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_eg2"
  oe_eg2Clock = new util.Clock();
  oe_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg2_txt_top',
    text: 'In this example, there is an odd number on the right side. Your job is to press the key on the opposite side of this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg2_txt_num',
    text: '7',
    font: 'Arial',
    units: undefined, 
    pos: [0.3, 0.1], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_eg2_txt_bot',
    text: 'Press ‘z’.',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.3), (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_speed_instr"
  oe_speed_instrClock = new util.Clock();
  oe_speed_instr_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_top',
    text: 'The numbers will dissapear after a short time. \n\nTry to press the correct key as fast as you can!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_speed_instr_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_speed_instr_bot',
    text: 'Press ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_speed_instr_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_train_start"
  oe_train_startClock = new util.Clock();
  oe_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress ‘z’ or ‘m’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_feedback"
  oe_feedbackClock = new util.Clock();
  oe_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "oe_test_start"
  oe_test_startClock = new util.Clock();
  oe_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will see an even or odd number and press the key on the same side of the number if it is even, but press the key on the opposite side of the number if it is odd.\n\n\n\n\nPress ‘spacebar’ to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  oe_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "oe_trial"
  oe_trialClock = new util.Clock();
  oe_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  oe_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'oe_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  oe_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Thank_You"
  Thank_YouClock = new util.Clock();
  text_92 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_92',
    text: 'Great! This is the end of the fourth task.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_111 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_111',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: 0.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "welcome"
  welcomeClock = new util.Clock();
  text_122 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_122',
    text: 'Welcome!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: undefined,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_123 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_123',
    text: 'Press ‘space bar’ to continue',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_52 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Instructions_3"
  Instructions_3Clock = new util.Clock();
  instructions_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'instructions_2',
    text: 'The fifth task is an unusual one. Instead of telling you the rules, you have to figure them out.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_53 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_124 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_124',
    text: 'Press ‘space bar’ to continue',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "Example"
  ExampleClock = new util.Clock();
  example_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'example_text',
    text: 'You will see a screen like this:',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.4], height: 0.04,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  example = new visual.ImageStim({
    win : psychoJS.window,
    name : 'example', units : undefined, 
    image : 'example.jpg', mask : undefined,
    ori : 0, pos : [0, 0.15], size : [0.7, 0.4],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  example_text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'example_text_2',
    text: 'You will click on one of the four cards at the top that you think is similar to the card at the bottom.  We will tell you if you clicked the correct card or the incorrect card. \n\n\n\nPress the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.25)], height: 0.04,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  key_resp_54 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "lets_practice"
  lets_practiceClock = new util.Clock();
  text_125 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_125',
    text: 'Let’s practice',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  key_resp_55 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  text_126 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_126',
    text: 'Press the space bar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  // Initialize components for Routine "trials_practice_2"
  trials_practice_2Clock = new util.Clock();
  fixation_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_4',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  one_red_dot_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'one_red_dot_2', units : undefined, 
    image : 'images/one_red_dot.jpg', mask : undefined,
    ori : 0, pos : [(- 0.45), 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  two_yellow_triangles_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'two_yellow_triangles_2', units : undefined, 
    image : 'images/two_yellow_triangles.jpg', mask : undefined,
    ori : 0, pos : [(- 0.15), 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -2.0 
  });
  three_green_crosses_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'three_green_crosses_2', units : undefined, 
    image : 'images/three_green_crosses.jpg', mask : undefined,
    ori : 0, pos : [0.15, 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -3.0 
  });
  four_blue_stars_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'four_blue_stars_2', units : undefined, 
    image : 'images/four_blue_stars.jpg', mask : undefined,
    ori : 0, pos : [0.45, 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -4.0 
  });
  trial_card_2 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'trial_card_2', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, (- 0.2)], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -5.0 
  });
  response_2 = new core.Mouse({
    win: psychoJS.window,
  });
  response_2.mouseClock = new util.Clock();
  // Initialize components for Routine "feedback_practice_2"
  feedback_practice_2Clock = new util.Clock();
  msg = "";
  
  trial_counter = 0;
  corr = 0 ;
  
  corr_trial_counter = 0;
  
  prev = 0;
  feedback_text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'feedback_text_2',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "ready"
  readyClock = new util.Clock();
  text_127 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_127',
    text: 'Ok, let’s play for real now.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  text_128 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_128',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  key_resp_56 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "code_meta_2"
  code_meta_2Clock = new util.Clock();
  trial_counter = 0;
  condition_counter = 0;
  // Initialize components for Routine "Trials"
  TrialsClock = new util.Clock();
  fixation_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'fixation_5',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  one_red_dot = new visual.ImageStim({
    win : psychoJS.window,
    name : 'one_red_dot', units : undefined, 
    image : 'images/one_red_dot.jpg', mask : undefined,
    ori : 0, pos : [(- 0.45), 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -1.0 
  });
  two_yellow_triangles = new visual.ImageStim({
    win : psychoJS.window,
    name : 'two_yellow_triangles', units : undefined, 
    image : 'images/two_yellow_triangles.jpg', mask : undefined,
    ori : 0, pos : [(- 0.15), 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -2.0 
  });
  three_green_crosses = new visual.ImageStim({
    win : psychoJS.window,
    name : 'three_green_crosses', units : undefined, 
    image : 'images/three_green_crosses.jpg', mask : undefined,
    ori : 0, pos : [0.15, 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -3.0 
  });
  four_blue_stars = new visual.ImageStim({
    win : psychoJS.window,
    name : 'four_blue_stars', units : undefined, 
    image : 'images/four_blue_stars.jpg', mask : undefined,
    ori : 0, pos : [0.45, 0.25], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 128, interpolate : true, depth : -4.0 
  });
  trial_card = new visual.ImageStim({
    win : psychoJS.window,
    name : 'trial_card', units : undefined, 
    image : undefined, mask : undefined,
    ori : 0, pos : [0, (- 0.2)], size : [0.25, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -5.0 
  });
  response = new core.Mouse({
    win: psychoJS.window,
  });
  response.mouseClock = new util.Clock();
  // Initialize components for Routine "Feedback_2"
  Feedback_2Clock = new util.Clock();
  msg = "";
  
  trial_counter = 0;
  corr = 0 ;
  
  corr_trial_counter = 0;
  
  prev = 0;
  feedback_text = new visual.TextStim({
    win: psychoJS.window,
    name: 'feedback_text',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  // Initialize components for Routine "code_end_2"
  code_end_2Clock = new util.Clock();
  // Initialize components for Routine "thank_you_5"
  thank_you_5Clock = new util.Clock();
  text_129 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_129',
    text: 'Great! This is the end of the fifth task.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "pm_welcome"
  pm_welcomeClock = new util.Clock();
  pm_welcome_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_welcome_txt_top',
    text: 'Welcome!',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  pm_welcome_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_welcome_txt_bot',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_welcome_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "plus_intro"
  plus_introClock = new util.Clock();
  plus_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_intro_txt_top',
    text: 'In this task, you will see a number and a plus sign. \n\nYou will add 3 to this number and type in the answer.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  plus_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_intro_txt_bot',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  plus_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "plus_eg1"
  plus_eg1Clock = new util.Clock();
  plus_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg1_txt_top',
    text: 'In this example, the number is 25. You will add 3 to this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  plus_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg1_txt_num',
    text: '25',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  plus_eg1_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg1_txt_sym',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  plus_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg1_txt_bot',
    text: 'Type 28 and press enter.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  plus_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  plus_eg1_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg1_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "plus_eg2"
  plus_eg2Clock = new util.Clock();
  plus_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg2_txt_top',
    text: 'In this example, the number is 13. You will add 3 to this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  plus_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg2_txt_num',
    text: '13',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  plus_eg2_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg2_txt_sym',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  plus_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg2_txt_bot',
    text: 'Type 16 and press enter.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  plus_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  plus_eg2_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_eg2_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "pm_train_start"
  pm_train_startClock = new util.Clock();
  pm_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "pm_feedback"
  pm_feedbackClock = new util.Clock();
  pm_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "plus_test_start"
  plus_test_startClock = new util.Clock();
  plus_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'plus_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will add 3 to the number on the screen and type the correct answer. \n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  plus_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "minus_intro"
  minus_introClock = new util.Clock();
  minus_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_intro_txt_top',
    text: 'In this task, you will see a number and a minus sign. \n\nYou will subtract 3 from this number and type in the answer.\n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  minus_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_intro_txt_bot',
    text: 'Press the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  minus_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "minus_eg1"
  minus_eg1Clock = new util.Clock();
  minus_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg1_txt_top',
    text: 'In this example, the number is 25. You will subtract 3 from this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  minus_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg1_txt_num',
    text: '25',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  minus_eg1_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg1_txt_sym',
    text: '-',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  minus_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg1_txt_bot',
    text: 'Type 22 and press enter.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  minus_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  minus_eg1_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg1_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "minus_eg2"
  minus_eg2Clock = new util.Clock();
  minus_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg2_txt_top',
    text: 'In this example, the number is 13. You will subtract 3 from this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  minus_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg2_txt_num',
    text: '13',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  minus_eg2_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg2_txt_sym',
    text: '-',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  minus_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg2_txt_bot',
    text: 'Type 10 and press enter.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  minus_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  minus_eg2_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_eg2_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "pm_train_start"
  pm_train_startClock = new util.Clock();
  pm_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "pm_feedback"
  pm_feedbackClock = new util.Clock();
  pm_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "minus_test_start"
  minus_test_startClock = new util.Clock();
  minus_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'minus_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will subtract 3 from the number on the screen and type the correct answer. \n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  minus_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "pm_intro"
  pm_introClock = new util.Clock();
  pm_intro_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_intro_txt_top',
    text: 'In this task, you will see a number and a minus sign or a plus sign.\n\nYou will add 3 to this number if you see a plus sign, but subtract 3 from this number if you see a minus sign. \n',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.1], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  pm_intro_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_intro_txt_bot',
    text: "Press 'spacebar' to continue.",
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_intro_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_eg1"
  pm_eg1Clock = new util.Clock();
  pm_eg1_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg1_txt_top',
    text: 'In this example, the number is 25 and there is a minus sign. You will subtract 3 from this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_eg1_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg1_txt_num',
    text: '25',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_eg1_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg1_txt_sym',
    text: '-',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_eg1_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg1_txt_bot',
    text: 'Please type 22 and press enter.',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  pm_eg1_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_eg1_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg1_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "pm_eg2"
  pm_eg2Clock = new util.Clock();
  pm_eg2_txt_top = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg2_txt_top',
    text: 'In this example, the number is 13 but there is a plus sign. You will add 3 to this number.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_eg2_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg2_txt_num',
    text: '13',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_eg2_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg2_txt_sym',
    text: '+',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_eg2_txt_bot = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg2_txt_bot',
    text: 'Type 16 and press enter. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.35)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -4.0 
  });
  
  pm_eg2_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_eg2_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_eg2_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -6.0 
  });
  
  // Initialize components for Routine "pm_train_start"
  pm_train_startClock = new util.Clock();
  pm_train_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_train_start_txt',
    text: 'Ok let’s practice. \n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_train_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "pm_feedback"
  pm_feedbackClock = new util.Clock();
  pm_feedback_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_feedback_txt',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  // Initialize components for Routine "pm_test_start"
  pm_test_startClock = new util.Clock();
  pm_test_start_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_test_start_txt',
    text: 'Ok let’s play for real now. Remember, you will subtract 3 from the number on the screen if you see a minus sign and you will add 3 if you see a plus sign.\n\n\n\n\nPress the spacebar to continue.',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_test_start_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "pm_trial"
  pm_trialClock = new util.Clock();
  pm_trial_fixation = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_fixation',
    text: '■',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  pm_trial_txt_num = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_num',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [(- 0.1), 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -2.0 
  });
  
  pm_trial_txt_sym = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_txt_sym',
    text: 'default text',
    font: 'Arial',
    units: undefined, 
    pos: [0.1, 0], height: 0.1,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -3.0 
  });
  
  pm_trial_key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  pm_trial_resp_txt = new visual.TextStim({
    win: psychoJS.window,
    name: 'pm_trial_resp_txt',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.15)], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -5.0 
  });
  
  // Initialize components for Routine "End_2"
  End_2Clock = new util.Clock();
  thank_you_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'thank_you_2',
    text: 'Great! You finished all six tasks.\n\nPlease do not close the window browser until you have seen the following message and click on OK. ',
    font: 'Arial',
    units: undefined, 
    pos: [0, 0.3], height: 0.05,  wrapWidth: undefined, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: 0.0 
  });
  
  end = new visual.TextStim({
    win: psychoJS.window,
    name: 'end',
    text: '',
    font: 'Arial',
    units: undefined, 
    pos: [0, (- 0.3)], height: 0.05,  wrapWidth: 0.8, ori: 0,
    color: new util.Color('white'),  opacity: 1,
    depth: -1.0 
  });
  
  image_16 = new visual.ImageStim({
    win : psychoJS.window,
    name : 'image_16', units : undefined, 
    image : 'ef_math_saving_message.png', mask : undefined,
    ori : 0, pos : [0, (- 0.04)], size : [0.5, 0.25],
    color : new util.Color([1, 1, 1]), opacity : 1,
    flipHoriz : false, flipVert : false,
    texRes : 512, interpolate : true, depth : -3.0 
  });
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}


var t;
var frameN;
var _key_resp_8_allKeys;
var WelcomeComponents;
function WelcomeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Welcome'-------
    t = 0;
    WelcomeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_8.keys = undefined;
    key_resp_8.rt = undefined;
    _key_resp_8_allKeys = [];
    // keep track of which components have finished
    WelcomeComponents = [];
    WelcomeComponents.push(text_12);
    WelcomeComponents.push(text_13);
    WelcomeComponents.push(key_resp_8);
    
    WelcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


var continueRoutine;
function WelcomeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Welcome'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = WelcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_12* updates
    if (t >= 0.0 && text_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_12.tStart = t;  // (not accounting for frame time here)
      text_12.frameNStart = frameN;  // exact frame index
      
      text_12.setAutoDraw(true);
    }

    
    // *text_13* updates
    if (t >= 0.0 && text_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_13.tStart = t;  // (not accounting for frame time here)
      text_13.frameNStart = frameN;  // exact frame index
      
      text_13.setAutoDraw(true);
    }

    
    // *key_resp_8* updates
    if (t >= 0.0 && key_resp_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_8.tStart = t;  // (not accounting for frame time here)
      key_resp_8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_8.clearEvents(); });
    }

    if (key_resp_8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_8.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_8_allKeys = _key_resp_8_allKeys.concat(theseKeys);
      if (_key_resp_8_allKeys.length > 0) {
        key_resp_8.keys = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].name;  // just the last key pressed
        key_resp_8.rt = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    WelcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function WelcomeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Welcome'-------
    WelcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "Welcome" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_57_allKeys;
var overal_ef_assessment_instructionsComponents;
function overal_ef_assessment_instructionsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'overal_ef_assessment_instructions'-------
    t = 0;
    overal_ef_assessment_instructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_57.keys = undefined;
    key_resp_57.rt = undefined;
    _key_resp_57_allKeys = [];
    // keep track of which components have finished
    overal_ef_assessment_instructionsComponents = [];
    overal_ef_assessment_instructionsComponents.push(text_130);
    overal_ef_assessment_instructionsComponents.push(text_131);
    overal_ef_assessment_instructionsComponents.push(key_resp_57);
    overal_ef_assessment_instructionsComponents.push(image_29);
    
    overal_ef_assessment_instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function overal_ef_assessment_instructionsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'overal_ef_assessment_instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = overal_ef_assessment_instructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_130* updates
    if (t >= 0.0 && text_130.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_130.tStart = t;  // (not accounting for frame time here)
      text_130.frameNStart = frameN;  // exact frame index
      
      text_130.setAutoDraw(true);
    }

    
    // *text_131* updates
    if (t >= 0.0 && text_131.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_131.tStart = t;  // (not accounting for frame time here)
      text_131.frameNStart = frameN;  // exact frame index
      
      text_131.setAutoDraw(true);
    }

    
    // *key_resp_57* updates
    if (t >= 0.0 && key_resp_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_57.tStart = t;  // (not accounting for frame time here)
      key_resp_57.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_57.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_57.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_57.clearEvents(); });
    }

    if (key_resp_57.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_57.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_57_allKeys = _key_resp_57_allKeys.concat(theseKeys);
      if (_key_resp_57_allKeys.length > 0) {
        key_resp_57.keys = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].name;  // just the last key pressed
        key_resp_57.rt = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *image_29* updates
    if (t >= 0.0 && image_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_29.tStart = t;  // (not accounting for frame time here)
      image_29.frameNStart = frameN;  // exact frame index
      
      image_29.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    overal_ef_assessment_instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function overal_ef_assessment_instructionsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'overal_ef_assessment_instructions'-------
    overal_ef_assessment_instructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_57.keys', key_resp_57.keys);
    if (typeof key_resp_57.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_57.rt', key_resp_57.rt);
        routineTimer.reset();
        }
    
    key_resp_57.stop();
    // the Routine "overal_ef_assessment_instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_9_allKeys;
var IntroductionComponents;
function IntroductionRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Introduction'-------
    t = 0;
    IntroductionClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_9.keys = undefined;
    key_resp_9.rt = undefined;
    _key_resp_9_allKeys = [];
    // keep track of which components have finished
    IntroductionComponents = [];
    IntroductionComponents.push(text_14);
    IntroductionComponents.push(text_16);
    IntroductionComponents.push(key_resp_9);
    
    IntroductionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroductionRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Introduction'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroductionClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_14* updates
    if (t >= 0.0 && text_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_14.tStart = t;  // (not accounting for frame time here)
      text_14.frameNStart = frameN;  // exact frame index
      
      text_14.setAutoDraw(true);
    }

    
    // *text_16* updates
    if (t >= 0 && text_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_16.tStart = t;  // (not accounting for frame time here)
      text_16.frameNStart = frameN;  // exact frame index
      
      text_16.setAutoDraw(true);
    }

    
    // *key_resp_9* updates
    if (t >= 0 && key_resp_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_9.tStart = t;  // (not accounting for frame time here)
      key_resp_9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.clearEvents(); });
    }

    if (key_resp_9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_9.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_9_allKeys = _key_resp_9_allKeys.concat(theseKeys);
      if (_key_resp_9_allKeys.length > 0) {
        key_resp_9.keys = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].name;  // just the last key pressed
        key_resp_9.rt = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroductionComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroductionRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Introduction'-------
    IntroductionComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "Introduction" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Circles_Example_1Components;
function Circles_Example_1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circles_Example_1'-------
    t = 0;
    Circles_Example_1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Circles_Example_1Components = [];
    Circles_Example_1Components.push(init_circle);
    Circles_Example_1Components.push(init_circle_17);
    Circles_Example_1Components.push(init_circle_18);
    Circles_Example_1Components.push(init_circle_19);
    Circles_Example_1Components.push(init_circle_20);
    Circles_Example_1Components.push(init_circle_21);
    Circles_Example_1Components.push(init_circle_22);
    Circles_Example_1Components.push(init_circle_23);
    Circles_Example_1Components.push(init_circle_24);
    Circles_Example_1Components.push(init_circle_25);
    Circles_Example_1Components.push(init_circle_26);
    Circles_Example_1Components.push(init_circle_27);
    Circles_Example_1Components.push(init_circle_28);
    Circles_Example_1Components.push(init_circle_29);
    Circles_Example_1Components.push(init_circle_30);
    Circles_Example_1Components.push(init_circle_31);
    Circles_Example_1Components.push(For_example);
    
    Circles_Example_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


var frameRemains;
function Circles_Example_1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circles_Example_1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circles_Example_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *init_circle* updates
    if (t >= 0 && init_circle.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle.tStart = t;  // (not accounting for frame time here)
      init_circle.frameNStart = frameN;  // exact frame index
      
      init_circle.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle.status === PsychoJS.Status.STARTED || init_circle.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle.setAutoDraw(false);
    }
    
    // *init_circle_17* updates
    if (t >= 0 && init_circle_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_17.tStart = t;  // (not accounting for frame time here)
      init_circle_17.frameNStart = frameN;  // exact frame index
      
      init_circle_17.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_17.status === PsychoJS.Status.STARTED || init_circle_17.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_17.setAutoDraw(false);
    }
    
    // *init_circle_18* updates
    if (t >= 0 && init_circle_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_18.tStart = t;  // (not accounting for frame time here)
      init_circle_18.frameNStart = frameN;  // exact frame index
      
      init_circle_18.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_18.status === PsychoJS.Status.STARTED || init_circle_18.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_18.setAutoDraw(false);
    }
    
    // *init_circle_19* updates
    if (t >= 0 && init_circle_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_19.tStart = t;  // (not accounting for frame time here)
      init_circle_19.frameNStart = frameN;  // exact frame index
      
      init_circle_19.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_19.status === PsychoJS.Status.STARTED || init_circle_19.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_19.setAutoDraw(false);
    }
    
    // *init_circle_20* updates
    if (t >= 0 && init_circle_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_20.tStart = t;  // (not accounting for frame time here)
      init_circle_20.frameNStart = frameN;  // exact frame index
      
      init_circle_20.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_20.status === PsychoJS.Status.STARTED || init_circle_20.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_20.setAutoDraw(false);
    }
    
    // *init_circle_21* updates
    if (t >= 0 && init_circle_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_21.tStart = t;  // (not accounting for frame time here)
      init_circle_21.frameNStart = frameN;  // exact frame index
      
      init_circle_21.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_21.status === PsychoJS.Status.STARTED || init_circle_21.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_21.setAutoDraw(false);
    }
    
    // *init_circle_22* updates
    if (t >= 0 && init_circle_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_22.tStart = t;  // (not accounting for frame time here)
      init_circle_22.frameNStart = frameN;  // exact frame index
      
      init_circle_22.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_22.status === PsychoJS.Status.STARTED || init_circle_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_22.setAutoDraw(false);
    }
    
    // *init_circle_23* updates
    if (t >= 0 && init_circle_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_23.tStart = t;  // (not accounting for frame time here)
      init_circle_23.frameNStart = frameN;  // exact frame index
      
      init_circle_23.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_23.status === PsychoJS.Status.STARTED || init_circle_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_23.setAutoDraw(false);
    }
    
    // *init_circle_24* updates
    if (t >= 0 && init_circle_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_24.tStart = t;  // (not accounting for frame time here)
      init_circle_24.frameNStart = frameN;  // exact frame index
      
      init_circle_24.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_24.status === PsychoJS.Status.STARTED || init_circle_24.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_24.setAutoDraw(false);
    }
    
    // *init_circle_25* updates
    if (t >= 0 && init_circle_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_25.tStart = t;  // (not accounting for frame time here)
      init_circle_25.frameNStart = frameN;  // exact frame index
      
      init_circle_25.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_25.status === PsychoJS.Status.STARTED || init_circle_25.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_25.setAutoDraw(false);
    }
    
    // *init_circle_26* updates
    if (t >= 0 && init_circle_26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_26.tStart = t;  // (not accounting for frame time here)
      init_circle_26.frameNStart = frameN;  // exact frame index
      
      init_circle_26.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_26.status === PsychoJS.Status.STARTED || init_circle_26.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_26.setAutoDraw(false);
    }
    
    // *init_circle_27* updates
    if (t >= 0 && init_circle_27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_27.tStart = t;  // (not accounting for frame time here)
      init_circle_27.frameNStart = frameN;  // exact frame index
      
      init_circle_27.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_27.status === PsychoJS.Status.STARTED || init_circle_27.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_27.setAutoDraw(false);
    }
    
    // *init_circle_28* updates
    if (t >= 0 && init_circle_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_28.tStart = t;  // (not accounting for frame time here)
      init_circle_28.frameNStart = frameN;  // exact frame index
      
      init_circle_28.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_28.status === PsychoJS.Status.STARTED || init_circle_28.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_28.setAutoDraw(false);
    }
    
    // *init_circle_29* updates
    if (t >= 0 && init_circle_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_29.tStart = t;  // (not accounting for frame time here)
      init_circle_29.frameNStart = frameN;  // exact frame index
      
      init_circle_29.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_29.status === PsychoJS.Status.STARTED || init_circle_29.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_29.setAutoDraw(false);
    }
    
    // *init_circle_30* updates
    if (t >= 0 && init_circle_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_30.tStart = t;  // (not accounting for frame time here)
      init_circle_30.frameNStart = frameN;  // exact frame index
      
      init_circle_30.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_30.status === PsychoJS.Status.STARTED || init_circle_30.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_30.setAutoDraw(false);
    }
    
    // *init_circle_31* updates
    if (t >= 0 && init_circle_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_31.tStart = t;  // (not accounting for frame time here)
      init_circle_31.frameNStart = frameN;  // exact frame index
      
      init_circle_31.setAutoDraw(true);
    }

    frameRemains = 0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_31.status === PsychoJS.Status.STARTED || init_circle_31.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_31.setAutoDraw(false);
    }
    
    // *For_example* updates
    if (t >= 0.0 && For_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      For_example.tStart = t;  // (not accounting for frame time here)
      For_example.frameNStart = frameN;  // exact frame index
      
      For_example.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((For_example.status === PsychoJS.Status.STARTED || For_example.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      For_example.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circles_Example_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circles_Example_1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circles_Example_1'-------
    Circles_Example_1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Circles_Example_2Components;
function Circles_Example_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circles_Example_2'-------
    t = 0;
    Circles_Example_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Circles_Example_2Components = [];
    Circles_Example_2Components.push(init_circle_32);
    Circles_Example_2Components.push(init_circle_33);
    Circles_Example_2Components.push(init_circle_34);
    Circles_Example_2Components.push(C4_circle_lights_up);
    Circles_Example_2Components.push(init_circle_36);
    Circles_Example_2Components.push(init_circle_37);
    Circles_Example_2Components.push(init_circle_38);
    Circles_Example_2Components.push(init_circle_39);
    Circles_Example_2Components.push(init_circle_40);
    Circles_Example_2Components.push(init_circle_41);
    Circles_Example_2Components.push(init_circle_42);
    Circles_Example_2Components.push(init_circle_43);
    Circles_Example_2Components.push(init_circle_44);
    Circles_Example_2Components.push(init_circle_45);
    Circles_Example_2Components.push(init_circle_46);
    Circles_Example_2Components.push(init_circle_47);
    Circles_Example_2Components.push(For_example_2);
    
    Circles_Example_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Circles_Example_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circles_Example_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circles_Example_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *init_circle_32* updates
    if (t >= 0 && init_circle_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_32.tStart = t;  // (not accounting for frame time here)
      init_circle_32.frameNStart = frameN;  // exact frame index
      
      init_circle_32.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_32.status === PsychoJS.Status.STARTED || init_circle_32.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_32.setAutoDraw(false);
    }
    
    // *init_circle_33* updates
    if (t >= 0 && init_circle_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_33.tStart = t;  // (not accounting for frame time here)
      init_circle_33.frameNStart = frameN;  // exact frame index
      
      init_circle_33.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_33.status === PsychoJS.Status.STARTED || init_circle_33.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_33.setAutoDraw(false);
    }
    
    // *init_circle_34* updates
    if (t >= 0 && init_circle_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_34.tStart = t;  // (not accounting for frame time here)
      init_circle_34.frameNStart = frameN;  // exact frame index
      
      init_circle_34.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_34.status === PsychoJS.Status.STARTED || init_circle_34.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_34.setAutoDraw(false);
    }
    
    // *C4_circle_lights_up* updates
    if (t >= 0 && C4_circle_lights_up.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      C4_circle_lights_up.tStart = t;  // (not accounting for frame time here)
      C4_circle_lights_up.frameNStart = frameN;  // exact frame index
      
      C4_circle_lights_up.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((C4_circle_lights_up.status === PsychoJS.Status.STARTED || C4_circle_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      C4_circle_lights_up.setAutoDraw(false);
    }
    
    // *init_circle_36* updates
    if (t >= 0 && init_circle_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_36.tStart = t;  // (not accounting for frame time here)
      init_circle_36.frameNStart = frameN;  // exact frame index
      
      init_circle_36.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_36.status === PsychoJS.Status.STARTED || init_circle_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_36.setAutoDraw(false);
    }
    
    // *init_circle_37* updates
    if (t >= 0 && init_circle_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_37.tStart = t;  // (not accounting for frame time here)
      init_circle_37.frameNStart = frameN;  // exact frame index
      
      init_circle_37.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_37.status === PsychoJS.Status.STARTED || init_circle_37.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_37.setAutoDraw(false);
    }
    
    // *init_circle_38* updates
    if (t >= 0 && init_circle_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_38.tStart = t;  // (not accounting for frame time here)
      init_circle_38.frameNStart = frameN;  // exact frame index
      
      init_circle_38.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_38.status === PsychoJS.Status.STARTED || init_circle_38.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_38.setAutoDraw(false);
    }
    
    // *init_circle_39* updates
    if (t >= 0 && init_circle_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_39.tStart = t;  // (not accounting for frame time here)
      init_circle_39.frameNStart = frameN;  // exact frame index
      
      init_circle_39.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_39.status === PsychoJS.Status.STARTED || init_circle_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_39.setAutoDraw(false);
    }
    
    // *init_circle_40* updates
    if (t >= 0 && init_circle_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_40.tStart = t;  // (not accounting for frame time here)
      init_circle_40.frameNStart = frameN;  // exact frame index
      
      init_circle_40.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_40.status === PsychoJS.Status.STARTED || init_circle_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_40.setAutoDraw(false);
    }
    
    // *init_circle_41* updates
    if (t >= 0 && init_circle_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_41.tStart = t;  // (not accounting for frame time here)
      init_circle_41.frameNStart = frameN;  // exact frame index
      
      init_circle_41.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_41.status === PsychoJS.Status.STARTED || init_circle_41.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_41.setAutoDraw(false);
    }
    
    // *init_circle_42* updates
    if (t >= 0 && init_circle_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_42.tStart = t;  // (not accounting for frame time here)
      init_circle_42.frameNStart = frameN;  // exact frame index
      
      init_circle_42.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_42.status === PsychoJS.Status.STARTED || init_circle_42.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_42.setAutoDraw(false);
    }
    
    // *init_circle_43* updates
    if (t >= 0 && init_circle_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_43.tStart = t;  // (not accounting for frame time here)
      init_circle_43.frameNStart = frameN;  // exact frame index
      
      init_circle_43.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_43.status === PsychoJS.Status.STARTED || init_circle_43.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_43.setAutoDraw(false);
    }
    
    // *init_circle_44* updates
    if (t >= 0 && init_circle_44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_44.tStart = t;  // (not accounting for frame time here)
      init_circle_44.frameNStart = frameN;  // exact frame index
      
      init_circle_44.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_44.status === PsychoJS.Status.STARTED || init_circle_44.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_44.setAutoDraw(false);
    }
    
    // *init_circle_45* updates
    if (t >= 0 && init_circle_45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_45.tStart = t;  // (not accounting for frame time here)
      init_circle_45.frameNStart = frameN;  // exact frame index
      
      init_circle_45.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_45.status === PsychoJS.Status.STARTED || init_circle_45.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_45.setAutoDraw(false);
    }
    
    // *init_circle_46* updates
    if (t >= 0 && init_circle_46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_46.tStart = t;  // (not accounting for frame time here)
      init_circle_46.frameNStart = frameN;  // exact frame index
      
      init_circle_46.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_46.status === PsychoJS.Status.STARTED || init_circle_46.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_46.setAutoDraw(false);
    }
    
    // *init_circle_47* updates
    if (t >= 0 && init_circle_47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_47.tStart = t;  // (not accounting for frame time here)
      init_circle_47.frameNStart = frameN;  // exact frame index
      
      init_circle_47.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_47.status === PsychoJS.Status.STARTED || init_circle_47.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_47.setAutoDraw(false);
    }
    
    // *For_example_2* updates
    if (t >= 0.0 && For_example_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      For_example_2.tStart = t;  // (not accounting for frame time here)
      For_example_2.frameNStart = frameN;  // exact frame index
      
      For_example_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((For_example_2.status === PsychoJS.Status.STARTED || For_example_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      For_example_2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circles_Example_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circles_Example_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circles_Example_2'-------
    Circles_Example_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Circles_Example_3Components;
function Circles_Example_3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circles_Example_3'-------
    t = 0;
    Circles_Example_3Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Circles_Example_3Components = [];
    Circles_Example_3Components.push(init_circle_35);
    Circles_Example_3Components.push(init_circle_48);
    Circles_Example_3Components.push(init_circle_49);
    Circles_Example_3Components.push(init_circle_63);
    Circles_Example_3Components.push(init_circle_50);
    Circles_Example_3Components.push(circle_6_lights_up);
    Circles_Example_3Components.push(init_circle_52);
    Circles_Example_3Components.push(init_circle_53);
    Circles_Example_3Components.push(init_circle_54);
    Circles_Example_3Components.push(init_circle_55);
    Circles_Example_3Components.push(init_circle_56);
    Circles_Example_3Components.push(init_circle_57);
    Circles_Example_3Components.push(init_circle_58);
    Circles_Example_3Components.push(init_circle_59);
    Circles_Example_3Components.push(init_circle_60);
    Circles_Example_3Components.push(init_circle_61);
    Circles_Example_3Components.push(b_For_example_4);
    
    Circles_Example_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Circles_Example_3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circles_Example_3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circles_Example_3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *init_circle_35* updates
    if (t >= 0 && init_circle_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_35.tStart = t;  // (not accounting for frame time here)
      init_circle_35.frameNStart = frameN;  // exact frame index
      
      init_circle_35.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_35.status === PsychoJS.Status.STARTED || init_circle_35.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_35.setAutoDraw(false);
    }
    
    // *init_circle_48* updates
    if (t >= 0 && init_circle_48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_48.tStart = t;  // (not accounting for frame time here)
      init_circle_48.frameNStart = frameN;  // exact frame index
      
      init_circle_48.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_48.status === PsychoJS.Status.STARTED || init_circle_48.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_48.setAutoDraw(false);
    }
    
    // *init_circle_49* updates
    if (t >= 0 && init_circle_49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_49.tStart = t;  // (not accounting for frame time here)
      init_circle_49.frameNStart = frameN;  // exact frame index
      
      init_circle_49.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_49.status === PsychoJS.Status.STARTED || init_circle_49.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_49.setAutoDraw(false);
    }
    
    // *init_circle_63* updates
    if (t >= 0 && init_circle_63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_63.tStart = t;  // (not accounting for frame time here)
      init_circle_63.frameNStart = frameN;  // exact frame index
      
      init_circle_63.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_63.status === PsychoJS.Status.STARTED || init_circle_63.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_63.setAutoDraw(false);
    }
    
    // *init_circle_50* updates
    if (t >= 0 && init_circle_50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_50.tStart = t;  // (not accounting for frame time here)
      init_circle_50.frameNStart = frameN;  // exact frame index
      
      init_circle_50.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_50.status === PsychoJS.Status.STARTED || init_circle_50.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_50.setAutoDraw(false);
    }
    
    // *circle_6_lights_up* updates
    if (t >= 0 && circle_6_lights_up.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle_6_lights_up.tStart = t;  // (not accounting for frame time here)
      circle_6_lights_up.frameNStart = frameN;  // exact frame index
      
      circle_6_lights_up.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((circle_6_lights_up.status === PsychoJS.Status.STARTED || circle_6_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      circle_6_lights_up.setAutoDraw(false);
    }
    
    // *init_circle_52* updates
    if (t >= 0 && init_circle_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_52.tStart = t;  // (not accounting for frame time here)
      init_circle_52.frameNStart = frameN;  // exact frame index
      
      init_circle_52.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_52.status === PsychoJS.Status.STARTED || init_circle_52.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_52.setAutoDraw(false);
    }
    
    // *init_circle_53* updates
    if (t >= 0 && init_circle_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_53.tStart = t;  // (not accounting for frame time here)
      init_circle_53.frameNStart = frameN;  // exact frame index
      
      init_circle_53.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_53.status === PsychoJS.Status.STARTED || init_circle_53.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_53.setAutoDraw(false);
    }
    
    // *init_circle_54* updates
    if (t >= 0 && init_circle_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_54.tStart = t;  // (not accounting for frame time here)
      init_circle_54.frameNStart = frameN;  // exact frame index
      
      init_circle_54.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_54.status === PsychoJS.Status.STARTED || init_circle_54.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_54.setAutoDraw(false);
    }
    
    // *init_circle_55* updates
    if (t >= 0 && init_circle_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_55.tStart = t;  // (not accounting for frame time here)
      init_circle_55.frameNStart = frameN;  // exact frame index
      
      init_circle_55.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_55.status === PsychoJS.Status.STARTED || init_circle_55.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_55.setAutoDraw(false);
    }
    
    // *init_circle_56* updates
    if (t >= 0 && init_circle_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_56.tStart = t;  // (not accounting for frame time here)
      init_circle_56.frameNStart = frameN;  // exact frame index
      
      init_circle_56.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_56.status === PsychoJS.Status.STARTED || init_circle_56.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_56.setAutoDraw(false);
    }
    
    // *init_circle_57* updates
    if (t >= 0 && init_circle_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_57.tStart = t;  // (not accounting for frame time here)
      init_circle_57.frameNStart = frameN;  // exact frame index
      
      init_circle_57.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_57.status === PsychoJS.Status.STARTED || init_circle_57.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_57.setAutoDraw(false);
    }
    
    // *init_circle_58* updates
    if (t >= 0 && init_circle_58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_58.tStart = t;  // (not accounting for frame time here)
      init_circle_58.frameNStart = frameN;  // exact frame index
      
      init_circle_58.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_58.status === PsychoJS.Status.STARTED || init_circle_58.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_58.setAutoDraw(false);
    }
    
    // *init_circle_59* updates
    if (t >= 0 && init_circle_59.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_59.tStart = t;  // (not accounting for frame time here)
      init_circle_59.frameNStart = frameN;  // exact frame index
      
      init_circle_59.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_59.status === PsychoJS.Status.STARTED || init_circle_59.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_59.setAutoDraw(false);
    }
    
    // *init_circle_60* updates
    if (t >= 0 && init_circle_60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_60.tStart = t;  // (not accounting for frame time here)
      init_circle_60.frameNStart = frameN;  // exact frame index
      
      init_circle_60.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_60.status === PsychoJS.Status.STARTED || init_circle_60.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_60.setAutoDraw(false);
    }
    
    // *init_circle_61* updates
    if (t >= 0 && init_circle_61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_61.tStart = t;  // (not accounting for frame time here)
      init_circle_61.frameNStart = frameN;  // exact frame index
      
      init_circle_61.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_61.status === PsychoJS.Status.STARTED || init_circle_61.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_61.setAutoDraw(false);
    }
    
    // *b_For_example_4* updates
    if (t >= 0.0 && b_For_example_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      b_For_example_4.tStart = t;  // (not accounting for frame time here)
      b_For_example_4.frameNStart = frameN;  // exact frame index
      
      b_For_example_4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((b_For_example_4.status === PsychoJS.Status.STARTED || b_For_example_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      b_For_example_4.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circles_Example_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circles_Example_3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circles_Example_3'-------
    Circles_Example_3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Circle_Example_4Components;
function Circle_Example_4RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circle_Example_4'-------
    t = 0;
    Circle_Example_4Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Circle_Example_4Components = [];
    Circle_Example_4Components.push(init_circle_51);
    Circle_Example_4Components.push(init_circle_62);
    Circle_Example_4Components.push(init_circle_64);
    Circle_Example_4Components.push(init_circle_65);
    Circle_Example_4Components.push(init_circle_66);
    Circle_Example_4Components.push(init_circle_80);
    Circle_Example_4Components.push(init_circle_67);
    Circle_Example_4Components.push(init_circle_68);
    Circle_Example_4Components.push(init_circle_69);
    Circle_Example_4Components.push(init_circle_70);
    Circle_Example_4Components.push(init_circle_71);
    Circle_Example_4Components.push(init_circle_72);
    Circle_Example_4Components.push(init_circle_73);
    Circle_Example_4Components.push(init_circle_74);
    Circle_Example_4Components.push(circle_15_lights_up);
    Circle_Example_4Components.push(init_circle_76);
    Circle_Example_4Components.push(For_example_5);
    
    Circle_Example_4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_4RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circle_Example_4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circle_Example_4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *init_circle_51* updates
    if (t >= 0 && init_circle_51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_51.tStart = t;  // (not accounting for frame time here)
      init_circle_51.frameNStart = frameN;  // exact frame index
      
      init_circle_51.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_51.status === PsychoJS.Status.STARTED || init_circle_51.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_51.setAutoDraw(false);
    }
    
    // *init_circle_62* updates
    if (t >= 0 && init_circle_62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_62.tStart = t;  // (not accounting for frame time here)
      init_circle_62.frameNStart = frameN;  // exact frame index
      
      init_circle_62.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_62.status === PsychoJS.Status.STARTED || init_circle_62.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_62.setAutoDraw(false);
    }
    
    // *init_circle_64* updates
    if (t >= 0 && init_circle_64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_64.tStart = t;  // (not accounting for frame time here)
      init_circle_64.frameNStart = frameN;  // exact frame index
      
      init_circle_64.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_64.status === PsychoJS.Status.STARTED || init_circle_64.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_64.setAutoDraw(false);
    }
    
    // *init_circle_65* updates
    if (t >= 0 && init_circle_65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_65.tStart = t;  // (not accounting for frame time here)
      init_circle_65.frameNStart = frameN;  // exact frame index
      
      init_circle_65.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_65.status === PsychoJS.Status.STARTED || init_circle_65.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_65.setAutoDraw(false);
    }
    
    // *init_circle_66* updates
    if (t >= 0 && init_circle_66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_66.tStart = t;  // (not accounting for frame time here)
      init_circle_66.frameNStart = frameN;  // exact frame index
      
      init_circle_66.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_66.status === PsychoJS.Status.STARTED || init_circle_66.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_66.setAutoDraw(false);
    }
    
    // *init_circle_80* updates
    if (t >= 0 && init_circle_80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_80.tStart = t;  // (not accounting for frame time here)
      init_circle_80.frameNStart = frameN;  // exact frame index
      
      init_circle_80.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_80.status === PsychoJS.Status.STARTED || init_circle_80.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_80.setAutoDraw(false);
    }
    
    // *init_circle_67* updates
    if (t >= 0 && init_circle_67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_67.tStart = t;  // (not accounting for frame time here)
      init_circle_67.frameNStart = frameN;  // exact frame index
      
      init_circle_67.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_67.status === PsychoJS.Status.STARTED || init_circle_67.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_67.setAutoDraw(false);
    }
    
    // *init_circle_68* updates
    if (t >= 0 && init_circle_68.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_68.tStart = t;  // (not accounting for frame time here)
      init_circle_68.frameNStart = frameN;  // exact frame index
      
      init_circle_68.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_68.status === PsychoJS.Status.STARTED || init_circle_68.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_68.setAutoDraw(false);
    }
    
    // *init_circle_69* updates
    if (t >= 0 && init_circle_69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_69.tStart = t;  // (not accounting for frame time here)
      init_circle_69.frameNStart = frameN;  // exact frame index
      
      init_circle_69.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_69.status === PsychoJS.Status.STARTED || init_circle_69.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_69.setAutoDraw(false);
    }
    
    // *init_circle_70* updates
    if (t >= 0 && init_circle_70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_70.tStart = t;  // (not accounting for frame time here)
      init_circle_70.frameNStart = frameN;  // exact frame index
      
      init_circle_70.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_70.status === PsychoJS.Status.STARTED || init_circle_70.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_70.setAutoDraw(false);
    }
    
    // *init_circle_71* updates
    if (t >= 0 && init_circle_71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_71.tStart = t;  // (not accounting for frame time here)
      init_circle_71.frameNStart = frameN;  // exact frame index
      
      init_circle_71.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_71.status === PsychoJS.Status.STARTED || init_circle_71.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_71.setAutoDraw(false);
    }
    
    // *init_circle_72* updates
    if (t >= 0 && init_circle_72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_72.tStart = t;  // (not accounting for frame time here)
      init_circle_72.frameNStart = frameN;  // exact frame index
      
      init_circle_72.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_72.status === PsychoJS.Status.STARTED || init_circle_72.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_72.setAutoDraw(false);
    }
    
    // *init_circle_73* updates
    if (t >= 0 && init_circle_73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_73.tStart = t;  // (not accounting for frame time here)
      init_circle_73.frameNStart = frameN;  // exact frame index
      
      init_circle_73.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_73.status === PsychoJS.Status.STARTED || init_circle_73.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_73.setAutoDraw(false);
    }
    
    // *init_circle_74* updates
    if (t >= 0 && init_circle_74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_74.tStart = t;  // (not accounting for frame time here)
      init_circle_74.frameNStart = frameN;  // exact frame index
      
      init_circle_74.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_74.status === PsychoJS.Status.STARTED || init_circle_74.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_74.setAutoDraw(false);
    }
    
    // *circle_15_lights_up* updates
    if (t >= 0 && circle_15_lights_up.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      circle_15_lights_up.tStart = t;  // (not accounting for frame time here)
      circle_15_lights_up.frameNStart = frameN;  // exact frame index
      
      circle_15_lights_up.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((circle_15_lights_up.status === PsychoJS.Status.STARTED || circle_15_lights_up.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      circle_15_lights_up.setAutoDraw(false);
    }
    
    // *init_circle_76* updates
    if (t >= 0 && init_circle_76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_76.tStart = t;  // (not accounting for frame time here)
      init_circle_76.frameNStart = frameN;  // exact frame index
      
      init_circle_76.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_76.status === PsychoJS.Status.STARTED || init_circle_76.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_76.setAutoDraw(false);
    }
    
    // *For_example_5* updates
    if (t >= 0.0 && For_example_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      For_example_5.tStart = t;  // (not accounting for frame time here)
      For_example_5.frameNStart = frameN;  // exact frame index
      
      For_example_5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((For_example_5.status === PsychoJS.Status.STARTED || For_example_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      For_example_5.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circle_Example_4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_4RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circle_Example_4'-------
    Circle_Example_4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Initial_CirclesComponents;
function Initial_CirclesRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Initial_Circles'-------
    t = 0;
    Initial_CirclesClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Initial_CirclesComponents = [];
    Initial_CirclesComponents.push(init_circle_1);
    Initial_CirclesComponents.push(init_circle_2);
    Initial_CirclesComponents.push(init_circle_3);
    Initial_CirclesComponents.push(init_circle_4);
    Initial_CirclesComponents.push(init_circle_5);
    Initial_CirclesComponents.push(init_circle_6);
    Initial_CirclesComponents.push(init_circle_7);
    Initial_CirclesComponents.push(init_circle_8);
    Initial_CirclesComponents.push(init_circle_9);
    Initial_CirclesComponents.push(init_circle_10);
    Initial_CirclesComponents.push(init_circle_11);
    Initial_CirclesComponents.push(init_circle_12);
    Initial_CirclesComponents.push(init_circle_13);
    Initial_CirclesComponents.push(init_circle_14);
    Initial_CirclesComponents.push(init_circle_15);
    Initial_CirclesComponents.push(init_circle_16);
    
    Initial_CirclesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Initial_CirclesRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Initial_Circles'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Initial_CirclesClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *init_circle_1* updates
    if (t >= 0 && init_circle_1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_1.tStart = t;  // (not accounting for frame time here)
      init_circle_1.frameNStart = frameN;  // exact frame index
      
      init_circle_1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_1.status === PsychoJS.Status.STARTED || init_circle_1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_1.setAutoDraw(false);
    }
    
    // *init_circle_2* updates
    if (t >= 0 && init_circle_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_2.tStart = t;  // (not accounting for frame time here)
      init_circle_2.frameNStart = frameN;  // exact frame index
      
      init_circle_2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_2.status === PsychoJS.Status.STARTED || init_circle_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_2.setAutoDraw(false);
    }
    
    // *init_circle_3* updates
    if (t >= 0 && init_circle_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_3.tStart = t;  // (not accounting for frame time here)
      init_circle_3.frameNStart = frameN;  // exact frame index
      
      init_circle_3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_3.status === PsychoJS.Status.STARTED || init_circle_3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_3.setAutoDraw(false);
    }
    
    // *init_circle_4* updates
    if (t >= 0 && init_circle_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_4.tStart = t;  // (not accounting for frame time here)
      init_circle_4.frameNStart = frameN;  // exact frame index
      
      init_circle_4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_4.status === PsychoJS.Status.STARTED || init_circle_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_4.setAutoDraw(false);
    }
    
    // *init_circle_5* updates
    if (t >= 0 && init_circle_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_5.tStart = t;  // (not accounting for frame time here)
      init_circle_5.frameNStart = frameN;  // exact frame index
      
      init_circle_5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_5.status === PsychoJS.Status.STARTED || init_circle_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_5.setAutoDraw(false);
    }
    
    // *init_circle_6* updates
    if (t >= 0 && init_circle_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_6.tStart = t;  // (not accounting for frame time here)
      init_circle_6.frameNStart = frameN;  // exact frame index
      
      init_circle_6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_6.status === PsychoJS.Status.STARTED || init_circle_6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_6.setAutoDraw(false);
    }
    
    // *init_circle_7* updates
    if (t >= 0 && init_circle_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_7.tStart = t;  // (not accounting for frame time here)
      init_circle_7.frameNStart = frameN;  // exact frame index
      
      init_circle_7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_7.status === PsychoJS.Status.STARTED || init_circle_7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_7.setAutoDraw(false);
    }
    
    // *init_circle_8* updates
    if (t >= 0 && init_circle_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_8.tStart = t;  // (not accounting for frame time here)
      init_circle_8.frameNStart = frameN;  // exact frame index
      
      init_circle_8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_8.status === PsychoJS.Status.STARTED || init_circle_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_8.setAutoDraw(false);
    }
    
    // *init_circle_9* updates
    if (t >= 0 && init_circle_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_9.tStart = t;  // (not accounting for frame time here)
      init_circle_9.frameNStart = frameN;  // exact frame index
      
      init_circle_9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_9.status === PsychoJS.Status.STARTED || init_circle_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_9.setAutoDraw(false);
    }
    
    // *init_circle_10* updates
    if (t >= 0 && init_circle_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_10.tStart = t;  // (not accounting for frame time here)
      init_circle_10.frameNStart = frameN;  // exact frame index
      
      init_circle_10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_10.status === PsychoJS.Status.STARTED || init_circle_10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_10.setAutoDraw(false);
    }
    
    // *init_circle_11* updates
    if (t >= 0 && init_circle_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_11.tStart = t;  // (not accounting for frame time here)
      init_circle_11.frameNStart = frameN;  // exact frame index
      
      init_circle_11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_11.status === PsychoJS.Status.STARTED || init_circle_11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_11.setAutoDraw(false);
    }
    
    // *init_circle_12* updates
    if (t >= 0 && init_circle_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_12.tStart = t;  // (not accounting for frame time here)
      init_circle_12.frameNStart = frameN;  // exact frame index
      
      init_circle_12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_12.status === PsychoJS.Status.STARTED || init_circle_12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_12.setAutoDraw(false);
    }
    
    // *init_circle_13* updates
    if (t >= 0 && init_circle_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_13.tStart = t;  // (not accounting for frame time here)
      init_circle_13.frameNStart = frameN;  // exact frame index
      
      init_circle_13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_13.status === PsychoJS.Status.STARTED || init_circle_13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_13.setAutoDraw(false);
    }
    
    // *init_circle_14* updates
    if (t >= 0 && init_circle_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_14.tStart = t;  // (not accounting for frame time here)
      init_circle_14.frameNStart = frameN;  // exact frame index
      
      init_circle_14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_14.status === PsychoJS.Status.STARTED || init_circle_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_14.setAutoDraw(false);
    }
    
    // *init_circle_15* updates
    if (t >= 0 && init_circle_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_15.tStart = t;  // (not accounting for frame time here)
      init_circle_15.frameNStart = frameN;  // exact frame index
      
      init_circle_15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_15.status === PsychoJS.Status.STARTED || init_circle_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_15.setAutoDraw(false);
    }
    
    // *init_circle_16* updates
    if (t >= 0 && init_circle_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      init_circle_16.tStart = t;  // (not accounting for frame time here)
      init_circle_16.frameNStart = frameN;  // exact frame index
      
      init_circle_16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((init_circle_16.status === PsychoJS.Status.STARTED || init_circle_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      init_circle_16.setAutoDraw(false);
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Initial_CirclesComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Initial_CirclesRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Initial_Circles'-------
    Initial_CirclesComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var gotValidClick;
var clicked_frame;
var Circle_Example_5AComponents;
function Circle_Example_5ARoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circle_Example_5A'-------
    t = 0;
    Circle_Example_5AClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the first_mouse_response_example
    // current position of the mouse:
    first_mouse_response_example.x = [];
    first_mouse_response_example.y = [];
    first_mouse_response_example.leftButton = [];
    first_mouse_response_example.midButton = [];
    first_mouse_response_example.rightButton = [];
    first_mouse_response_example.time = [];
    first_mouse_response_example.clicked_name = [];
    gotValidClick = false; // until a click is received
    first_mouse_response_example.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Circle_Example_5AComponents = [];
    Circle_Example_5AComponents.push(first_response_C1_example);
    Circle_Example_5AComponents.push(first_response_C2_example);
    Circle_Example_5AComponents.push(first_response_C3_example);
    Circle_Example_5AComponents.push(first_response_C4_example);
    Circle_Example_5AComponents.push(first_response_C5_example);
    Circle_Example_5AComponents.push(first_response_C6_example);
    Circle_Example_5AComponents.push(first_response_C7_example);
    Circle_Example_5AComponents.push(first_response_C8_example);
    Circle_Example_5AComponents.push(first_response_C9_example);
    Circle_Example_5AComponents.push(first_response_C10_example);
    Circle_Example_5AComponents.push(first_response_C11_example);
    Circle_Example_5AComponents.push(first_response_C12_example);
    Circle_Example_5AComponents.push(first_response_C13_example);
    Circle_Example_5AComponents.push(first_response_C14_example);
    Circle_Example_5AComponents.push(first_response_C15_example);
    Circle_Example_5AComponents.push(first_response_C16_example);
    Circle_Example_5AComponents.push(first_mouse_response_example);
    Circle_Example_5AComponents.push(polygon);
    Circle_Example_5AComponents.push(triangle);
    Circle_Example_5AComponents.push(push_these_circles);
    
    Circle_Example_5AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


var prevButtonState;
var _mouseButtons;
var _mouseXYs;
var clicked_circle;
function Circle_Example_5ARoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circle_Example_5A'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circle_Example_5AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *first_response_C1_example* updates
    if (t >= 0 && first_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C1_example.tStart = t;  // (not accounting for frame time here)
      first_response_C1_example.frameNStart = frameN;  // exact frame index
      
      first_response_C1_example.setAutoDraw(true);
    }

    
    // *first_response_C2_example* updates
    if (t >= 0 && first_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C2_example.tStart = t;  // (not accounting for frame time here)
      first_response_C2_example.frameNStart = frameN;  // exact frame index
      
      first_response_C2_example.setAutoDraw(true);
    }

    
    // *first_response_C3_example* updates
    if (t >= 0 && first_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C3_example.tStart = t;  // (not accounting for frame time here)
      first_response_C3_example.frameNStart = frameN;  // exact frame index
      
      first_response_C3_example.setAutoDraw(true);
    }

    
    // *first_response_C4_example* updates
    if (t >= 0 && first_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C4_example.tStart = t;  // (not accounting for frame time here)
      first_response_C4_example.frameNStart = frameN;  // exact frame index
      
      first_response_C4_example.setAutoDraw(true);
    }

    
    // *first_response_C5_example* updates
    if (t >= 0 && first_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C5_example.tStart = t;  // (not accounting for frame time here)
      first_response_C5_example.frameNStart = frameN;  // exact frame index
      
      first_response_C5_example.setAutoDraw(true);
    }

    
    // *first_response_C6_example* updates
    if (t >= 0 && first_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C6_example.tStart = t;  // (not accounting for frame time here)
      first_response_C6_example.frameNStart = frameN;  // exact frame index
      
      first_response_C6_example.setAutoDraw(true);
    }

    
    // *first_response_C7_example* updates
    if (t >= 0 && first_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C7_example.tStart = t;  // (not accounting for frame time here)
      first_response_C7_example.frameNStart = frameN;  // exact frame index
      
      first_response_C7_example.setAutoDraw(true);
    }

    
    // *first_response_C8_example* updates
    if (t >= 0 && first_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C8_example.tStart = t;  // (not accounting for frame time here)
      first_response_C8_example.frameNStart = frameN;  // exact frame index
      
      first_response_C8_example.setAutoDraw(true);
    }

    
    // *first_response_C9_example* updates
    if (t >= 0 && first_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C9_example.tStart = t;  // (not accounting for frame time here)
      first_response_C9_example.frameNStart = frameN;  // exact frame index
      
      first_response_C9_example.setAutoDraw(true);
    }

    
    // *first_response_C10_example* updates
    if (t >= 0 && first_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C10_example.tStart = t;  // (not accounting for frame time here)
      first_response_C10_example.frameNStart = frameN;  // exact frame index
      
      first_response_C10_example.setAutoDraw(true);
    }

    
    // *first_response_C11_example* updates
    if (t >= 0 && first_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C11_example.tStart = t;  // (not accounting for frame time here)
      first_response_C11_example.frameNStart = frameN;  // exact frame index
      
      first_response_C11_example.setAutoDraw(true);
    }

    
    // *first_response_C12_example* updates
    if (t >= 0 && first_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C12_example.tStart = t;  // (not accounting for frame time here)
      first_response_C12_example.frameNStart = frameN;  // exact frame index
      
      first_response_C12_example.setAutoDraw(true);
    }

    
    // *first_response_C13_example* updates
    if (t >= 0 && first_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C13_example.tStart = t;  // (not accounting for frame time here)
      first_response_C13_example.frameNStart = frameN;  // exact frame index
      
      first_response_C13_example.setAutoDraw(true);
    }

    
    // *first_response_C14_example* updates
    if (t >= 0 && first_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C14_example.tStart = t;  // (not accounting for frame time here)
      first_response_C14_example.frameNStart = frameN;  // exact frame index
      
      first_response_C14_example.setAutoDraw(true);
    }

    
    // *first_response_C15_example* updates
    if (t >= 0 && first_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C15_example.tStart = t;  // (not accounting for frame time here)
      first_response_C15_example.frameNStart = frameN;  // exact frame index
      
      first_response_C15_example.setAutoDraw(true);
    }

    
    // *first_response_C16_example* updates
    if (t >= 0 && first_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C16_example.tStart = t;  // (not accounting for frame time here)
      first_response_C16_example.frameNStart = frameN;  // exact frame index
      
      first_response_C16_example.setAutoDraw(true);
    }

    // *first_mouse_response_example* updates
    if (t >= 0.0 && first_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_mouse_response_example.tStart = t;  // (not accounting for frame time here)
      first_mouse_response_example.frameNStart = frameN;  // exact frame index
      
      first_mouse_response_example.status = PsychoJS.Status.STARTED;
      prevButtonState = first_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
      }
    if (first_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = first_mouse_response_example.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = first_mouse_response_example.getPos();
          first_mouse_response_example.x.push(_mouseXYs[0]);
          first_mouse_response_example.y.push(_mouseXYs[1]);
          first_mouse_response_example.leftButton.push(_mouseButtons[0]);
          first_mouse_response_example.midButton.push(_mouseButtons[1]);
          first_mouse_response_example.rightButton.push(_mouseButtons[2]);
          first_mouse_response_example.time.push(first_mouse_response_example.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [first_response_C15_example]) {
            if (obj.contains(first_mouse_response_example)) {
              gotValidClick = true;
              first_mouse_response_example.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((first_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        console.log(clicked_frame);
        clicked_circle = eval(first_mouse_response_example.clicked_name[0]);
        console.log(clicked_circle);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor([(- 1.0), (- 1.0), (- 1.0)]);
        continueRoutine = false;
    }
    
    
    // *polygon* updates
    if (t >= 0.0 && polygon.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      polygon.tStart = t;  // (not accounting for frame time here)
      polygon.frameNStart = frameN;  // exact frame index
      
      polygon.setAutoDraw(true);
    }

    
    // *triangle* updates
    if (t >= 0.0 && triangle.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      triangle.tStart = t;  // (not accounting for frame time here)
      triangle.frameNStart = frameN;  // exact frame index
      
      triangle.setAutoDraw(true);
    }

    
    // *push_these_circles* updates
    if (t >= 0.0 && push_these_circles.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      push_these_circles.tStart = t;  // (not accounting for frame time here)
      push_these_circles.frameNStart = frameN;  // exact frame index
      
      push_these_circles.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circle_Example_5AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_5ARoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circle_Example_5A'-------
    Circle_Example_5AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('first_mouse_response_example.x', first_mouse_response_example.x);
    psychoJS.experiment.addData('first_mouse_response_example.y', first_mouse_response_example.y);
    psychoJS.experiment.addData('first_mouse_response_example.leftButton', first_mouse_response_example.leftButton);
    psychoJS.experiment.addData('first_mouse_response_example.midButton', first_mouse_response_example.midButton);
    psychoJS.experiment.addData('first_mouse_response_example.rightButton', first_mouse_response_example.rightButton);
    psychoJS.experiment.addData('first_mouse_response_example.time', first_mouse_response_example.time);
    psychoJS.experiment.addData('first_mouse_response_example.clicked_name', first_mouse_response_example.clicked_name);
    
    // the Routine "Circle_Example_5A" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Circle_Example_6Components;
function Circle_Example_6RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circle_Example_6'-------
    t = 0;
    Circle_Example_6Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the second_mouse_response_example
    // current position of the mouse:
    second_mouse_response_example.x = [];
    second_mouse_response_example.y = [];
    second_mouse_response_example.leftButton = [];
    second_mouse_response_example.midButton = [];
    second_mouse_response_example.rightButton = [];
    second_mouse_response_example.time = [];
    second_mouse_response_example.clicked_name = [];
    gotValidClick = false; // until a click is received
    second_mouse_response_example.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Circle_Example_6Components = [];
    Circle_Example_6Components.push(second_response_C1_example);
    Circle_Example_6Components.push(second_response_C2_example);
    Circle_Example_6Components.push(second_response_C3_example);
    Circle_Example_6Components.push(second_response_C4_example);
    Circle_Example_6Components.push(second_response_C5_example);
    Circle_Example_6Components.push(second_response_C6_example);
    Circle_Example_6Components.push(second_response_C7_example);
    Circle_Example_6Components.push(second_response_C8_example);
    Circle_Example_6Components.push(second_response_C9_example);
    Circle_Example_6Components.push(second_response_C10_example);
    Circle_Example_6Components.push(second_response_C11_example);
    Circle_Example_6Components.push(second_response_C12_example);
    Circle_Example_6Components.push(second_response_C13_example);
    Circle_Example_6Components.push(second_response_C14_example);
    Circle_Example_6Components.push(second_response_C15_example);
    Circle_Example_6Components.push(second_response_C16_example);
    Circle_Example_6Components.push(second_mouse_response_example);
    Circle_Example_6Components.push(polygon_2);
    Circle_Example_6Components.push(triangle_2);
    Circle_Example_6Components.push(push_these_circles_2);
    
    Circle_Example_6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_6RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circle_Example_6'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circle_Example_6Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *second_response_C1_example* updates
    if (t >= 0 && second_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C1_example.tStart = t;  // (not accounting for frame time here)
      second_response_C1_example.frameNStart = frameN;  // exact frame index
      
      second_response_C1_example.setAutoDraw(true);
    }

    
    // *second_response_C2_example* updates
    if (t >= 0 && second_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C2_example.tStart = t;  // (not accounting for frame time here)
      second_response_C2_example.frameNStart = frameN;  // exact frame index
      
      second_response_C2_example.setAutoDraw(true);
    }

    
    // *second_response_C3_example* updates
    if (t >= 0 && second_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C3_example.tStart = t;  // (not accounting for frame time here)
      second_response_C3_example.frameNStart = frameN;  // exact frame index
      
      second_response_C3_example.setAutoDraw(true);
    }

    
    // *second_response_C4_example* updates
    if (t >= 0 && second_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C4_example.tStart = t;  // (not accounting for frame time here)
      second_response_C4_example.frameNStart = frameN;  // exact frame index
      
      second_response_C4_example.setAutoDraw(true);
    }

    
    // *second_response_C5_example* updates
    if (t >= 0 && second_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C5_example.tStart = t;  // (not accounting for frame time here)
      second_response_C5_example.frameNStart = frameN;  // exact frame index
      
      second_response_C5_example.setAutoDraw(true);
    }

    
    // *second_response_C6_example* updates
    if (t >= 0 && second_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C6_example.tStart = t;  // (not accounting for frame time here)
      second_response_C6_example.frameNStart = frameN;  // exact frame index
      
      second_response_C6_example.setAutoDraw(true);
    }

    
    // *second_response_C7_example* updates
    if (t >= 0 && second_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C7_example.tStart = t;  // (not accounting for frame time here)
      second_response_C7_example.frameNStart = frameN;  // exact frame index
      
      second_response_C7_example.setAutoDraw(true);
    }

    
    // *second_response_C8_example* updates
    if (t >= 0 && second_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C8_example.tStart = t;  // (not accounting for frame time here)
      second_response_C8_example.frameNStart = frameN;  // exact frame index
      
      second_response_C8_example.setAutoDraw(true);
    }

    
    // *second_response_C9_example* updates
    if (t >= 0 && second_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C9_example.tStart = t;  // (not accounting for frame time here)
      second_response_C9_example.frameNStart = frameN;  // exact frame index
      
      second_response_C9_example.setAutoDraw(true);
    }

    
    // *second_response_C10_example* updates
    if (t >= 0 && second_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C10_example.tStart = t;  // (not accounting for frame time here)
      second_response_C10_example.frameNStart = frameN;  // exact frame index
      
      second_response_C10_example.setAutoDraw(true);
    }

    
    // *second_response_C11_example* updates
    if (t >= 0 && second_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C11_example.tStart = t;  // (not accounting for frame time here)
      second_response_C11_example.frameNStart = frameN;  // exact frame index
      
      second_response_C11_example.setAutoDraw(true);
    }

    
    // *second_response_C12_example* updates
    if (t >= 0 && second_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C12_example.tStart = t;  // (not accounting for frame time here)
      second_response_C12_example.frameNStart = frameN;  // exact frame index
      
      second_response_C12_example.setAutoDraw(true);
    }

    
    // *second_response_C13_example* updates
    if (t >= 0 && second_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C13_example.tStart = t;  // (not accounting for frame time here)
      second_response_C13_example.frameNStart = frameN;  // exact frame index
      
      second_response_C13_example.setAutoDraw(true);
    }

    
    // *second_response_C14_example* updates
    if (t >= 0 && second_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C14_example.tStart = t;  // (not accounting for frame time here)
      second_response_C14_example.frameNStart = frameN;  // exact frame index
      
      second_response_C14_example.setAutoDraw(true);
    }

    
    // *second_response_C15_example* updates
    if (t >= 0 && second_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C15_example.tStart = t;  // (not accounting for frame time here)
      second_response_C15_example.frameNStart = frameN;  // exact frame index
      
      second_response_C15_example.setAutoDraw(true);
    }

    
    // *second_response_C16_example* updates
    if (t >= 0 && second_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C16_example.tStart = t;  // (not accounting for frame time here)
      second_response_C16_example.frameNStart = frameN;  // exact frame index
      
      second_response_C16_example.setAutoDraw(true);
    }

    // *second_mouse_response_example* updates
    if (t >= 0.0 && second_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_mouse_response_example.tStart = t;  // (not accounting for frame time here)
      second_mouse_response_example.frameNStart = frameN;  // exact frame index
      
      second_mouse_response_example.status = PsychoJS.Status.STARTED;
      prevButtonState = second_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
      }
    if (second_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = second_mouse_response_example.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = second_mouse_response_example.getPos();
          second_mouse_response_example.x.push(_mouseXYs[0]);
          second_mouse_response_example.y.push(_mouseXYs[1]);
          second_mouse_response_example.leftButton.push(_mouseButtons[0]);
          second_mouse_response_example.midButton.push(_mouseButtons[1]);
          second_mouse_response_example.rightButton.push(_mouseButtons[2]);
          second_mouse_response_example.time.push(second_mouse_response_example.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [second_response_C6_example]) {
            if (obj.contains(second_mouse_response_example)) {
              gotValidClick = true;
              second_mouse_response_example.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((second_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(second_mouse_response_example.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([-1, -1, -1]));
        continueRoutine = false;
    }
    
    
    // *polygon_2* updates
    if (t >= 0.0 && polygon_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      polygon_2.tStart = t;  // (not accounting for frame time here)
      polygon_2.frameNStart = frameN;  // exact frame index
      
      polygon_2.setAutoDraw(true);
    }

    
    // *triangle_2* updates
    if (t >= 0.0 && triangle_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      triangle_2.tStart = t;  // (not accounting for frame time here)
      triangle_2.frameNStart = frameN;  // exact frame index
      
      triangle_2.setAutoDraw(true);
    }

    
    // *push_these_circles_2* updates
    if (t >= 0.0 && push_these_circles_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      push_these_circles_2.tStart = t;  // (not accounting for frame time here)
      push_these_circles_2.frameNStart = frameN;  // exact frame index
      
      push_these_circles_2.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circle_Example_6Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_6RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circle_Example_6'-------
    Circle_Example_6Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('second_mouse_response_example.x', second_mouse_response_example.x);
    psychoJS.experiment.addData('second_mouse_response_example.y', second_mouse_response_example.y);
    psychoJS.experiment.addData('second_mouse_response_example.leftButton', second_mouse_response_example.leftButton);
    psychoJS.experiment.addData('second_mouse_response_example.midButton', second_mouse_response_example.midButton);
    psychoJS.experiment.addData('second_mouse_response_example.rightButton', second_mouse_response_example.rightButton);
    psychoJS.experiment.addData('second_mouse_response_example.time', second_mouse_response_example.time);
    psychoJS.experiment.addData('second_mouse_response_example.clicked_name', second_mouse_response_example.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Circle_Example_6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Circle_Example_7Components;
function Circle_Example_7RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Circle_Example_7'-------
    t = 0;
    Circle_Example_7Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the third_mouse_response_example
    // current position of the mouse:
    third_mouse_response_example.x = [];
    third_mouse_response_example.y = [];
    third_mouse_response_example.leftButton = [];
    third_mouse_response_example.midButton = [];
    third_mouse_response_example.rightButton = [];
    third_mouse_response_example.time = [];
    third_mouse_response_example.clicked_name = [];
    gotValidClick = false; // until a click is received
    third_mouse_response_example.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Circle_Example_7Components = [];
    Circle_Example_7Components.push(third_response_C1_example);
    Circle_Example_7Components.push(third_response_C2_example);
    Circle_Example_7Components.push(third_response_C3_example);
    Circle_Example_7Components.push(third_response_C4_example);
    Circle_Example_7Components.push(third_response_C5_example);
    Circle_Example_7Components.push(third_response_C6_example);
    Circle_Example_7Components.push(third_response_C7_example);
    Circle_Example_7Components.push(third_response_C8_example);
    Circle_Example_7Components.push(third_response_C9_example);
    Circle_Example_7Components.push(third_response_C10_example);
    Circle_Example_7Components.push(third_response_C11_example);
    Circle_Example_7Components.push(third_response_C12_example);
    Circle_Example_7Components.push(third_response_C13_example);
    Circle_Example_7Components.push(third_response_C14_example);
    Circle_Example_7Components.push(third_response_C15_example);
    Circle_Example_7Components.push(third_response_C16_example);
    Circle_Example_7Components.push(third_mouse_response_example);
    Circle_Example_7Components.push(polygon_3);
    Circle_Example_7Components.push(triangle_3);
    Circle_Example_7Components.push(push_these_circles_3);
    
    Circle_Example_7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_7RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Circle_Example_7'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Circle_Example_7Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *third_response_C1_example* updates
    if (t >= 0 && third_response_C1_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C1_example.tStart = t;  // (not accounting for frame time here)
      third_response_C1_example.frameNStart = frameN;  // exact frame index
      
      third_response_C1_example.setAutoDraw(true);
    }

    
    // *third_response_C2_example* updates
    if (t >= 0 && third_response_C2_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C2_example.tStart = t;  // (not accounting for frame time here)
      third_response_C2_example.frameNStart = frameN;  // exact frame index
      
      third_response_C2_example.setAutoDraw(true);
    }

    
    // *third_response_C3_example* updates
    if (t >= 0 && third_response_C3_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C3_example.tStart = t;  // (not accounting for frame time here)
      third_response_C3_example.frameNStart = frameN;  // exact frame index
      
      third_response_C3_example.setAutoDraw(true);
    }

    
    // *third_response_C4_example* updates
    if (t >= 0 && third_response_C4_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C4_example.tStart = t;  // (not accounting for frame time here)
      third_response_C4_example.frameNStart = frameN;  // exact frame index
      
      third_response_C4_example.setAutoDraw(true);
    }

    
    // *third_response_C5_example* updates
    if (t >= 0 && third_response_C5_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C5_example.tStart = t;  // (not accounting for frame time here)
      third_response_C5_example.frameNStart = frameN;  // exact frame index
      
      third_response_C5_example.setAutoDraw(true);
    }

    
    // *third_response_C6_example* updates
    if (t >= 0 && third_response_C6_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C6_example.tStart = t;  // (not accounting for frame time here)
      third_response_C6_example.frameNStart = frameN;  // exact frame index
      
      third_response_C6_example.setAutoDraw(true);
    }

    
    // *third_response_C7_example* updates
    if (t >= 0 && third_response_C7_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C7_example.tStart = t;  // (not accounting for frame time here)
      third_response_C7_example.frameNStart = frameN;  // exact frame index
      
      third_response_C7_example.setAutoDraw(true);
    }

    
    // *third_response_C8_example* updates
    if (t >= 0 && third_response_C8_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C8_example.tStart = t;  // (not accounting for frame time here)
      third_response_C8_example.frameNStart = frameN;  // exact frame index
      
      third_response_C8_example.setAutoDraw(true);
    }

    
    // *third_response_C9_example* updates
    if (t >= 0 && third_response_C9_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C9_example.tStart = t;  // (not accounting for frame time here)
      third_response_C9_example.frameNStart = frameN;  // exact frame index
      
      third_response_C9_example.setAutoDraw(true);
    }

    
    // *third_response_C10_example* updates
    if (t >= 0 && third_response_C10_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C10_example.tStart = t;  // (not accounting for frame time here)
      third_response_C10_example.frameNStart = frameN;  // exact frame index
      
      third_response_C10_example.setAutoDraw(true);
    }

    
    // *third_response_C11_example* updates
    if (t >= 0 && third_response_C11_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C11_example.tStart = t;  // (not accounting for frame time here)
      third_response_C11_example.frameNStart = frameN;  // exact frame index
      
      third_response_C11_example.setAutoDraw(true);
    }

    
    // *third_response_C12_example* updates
    if (t >= 0 && third_response_C12_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C12_example.tStart = t;  // (not accounting for frame time here)
      third_response_C12_example.frameNStart = frameN;  // exact frame index
      
      third_response_C12_example.setAutoDraw(true);
    }

    
    // *third_response_C13_example* updates
    if (t >= 0 && third_response_C13_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C13_example.tStart = t;  // (not accounting for frame time here)
      third_response_C13_example.frameNStart = frameN;  // exact frame index
      
      third_response_C13_example.setAutoDraw(true);
    }

    
    // *third_response_C14_example* updates
    if (t >= 0 && third_response_C14_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C14_example.tStart = t;  // (not accounting for frame time here)
      third_response_C14_example.frameNStart = frameN;  // exact frame index
      
      third_response_C14_example.setAutoDraw(true);
    }

    
    // *third_response_C15_example* updates
    if (t >= 0 && third_response_C15_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C15_example.tStart = t;  // (not accounting for frame time here)
      third_response_C15_example.frameNStart = frameN;  // exact frame index
      
      third_response_C15_example.setAutoDraw(true);
    }

    
    // *third_response_C16_example* updates
    if (t >= 0 && third_response_C16_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C16_example.tStart = t;  // (not accounting for frame time here)
      third_response_C16_example.frameNStart = frameN;  // exact frame index
      
      third_response_C16_example.setAutoDraw(true);
    }

    // *third_mouse_response_example* updates
    if (t >= 0.0 && third_mouse_response_example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_mouse_response_example.tStart = t;  // (not accounting for frame time here)
      third_mouse_response_example.frameNStart = frameN;  // exact frame index
      
      third_mouse_response_example.status = PsychoJS.Status.STARTED;
      prevButtonState = third_mouse_response_example.getPressed();  // if button is down already this ISN'T a new click
      }
    if (third_mouse_response_example.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = third_mouse_response_example.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = third_mouse_response_example.getPos();
          third_mouse_response_example.x.push(_mouseXYs[0]);
          third_mouse_response_example.y.push(_mouseXYs[1]);
          third_mouse_response_example.leftButton.push(_mouseButtons[0]);
          third_mouse_response_example.midButton.push(_mouseButtons[1]);
          third_mouse_response_example.rightButton.push(_mouseButtons[2]);
          third_mouse_response_example.time.push(third_mouse_response_example.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [third_response_C4_example]) {
            if (obj.contains(third_mouse_response_example)) {
              gotValidClick = true;
              third_mouse_response_example.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((third_mouse_response_example.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(third_mouse_response_example.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([-1, -1, -1]));
        continueRoutine = false;
    }
    
    // *polygon_3* updates
    if (t >= 0.0 && polygon_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      polygon_3.tStart = t;  // (not accounting for frame time here)
      polygon_3.frameNStart = frameN;  // exact frame index
      
      polygon_3.setAutoDraw(true);
    }

    
    // *triangle_3* updates
    if (t >= 0.0 && triangle_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      triangle_3.tStart = t;  // (not accounting for frame time here)
      triangle_3.frameNStart = frameN;  // exact frame index
      
      triangle_3.setAutoDraw(true);
    }

    
    // *push_these_circles_3* updates
    if (t >= 0.0 && push_these_circles_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      push_these_circles_3.tStart = t;  // (not accounting for frame time here)
      push_these_circles_3.frameNStart = frameN;  // exact frame index
      
      push_these_circles_3.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Circle_Example_7Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Circle_Example_7RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Circle_Example_7'-------
    Circle_Example_7Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('third_mouse_response_example.x', third_mouse_response_example.x);
    psychoJS.experiment.addData('third_mouse_response_example.y', third_mouse_response_example.y);
    psychoJS.experiment.addData('third_mouse_response_example.leftButton', third_mouse_response_example.leftButton);
    psychoJS.experiment.addData('third_mouse_response_example.midButton', third_mouse_response_example.midButton);
    psychoJS.experiment.addData('third_mouse_response_example.rightButton', third_mouse_response_example.rightButton);
    psychoJS.experiment.addData('third_mouse_response_example.time', third_mouse_response_example.time);
    psychoJS.experiment.addData('third_mouse_response_example.clicked_name', third_mouse_response_example.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Circle_Example_7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Start_PracticeComponents;
function Start_PracticeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Start_Practice'-------
    t = 0;
    Start_PracticeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the mouse
    gotValidClick = false; // until a click is received
    mouse.mouseClock.reset();
    // keep track of which components have finished
    Start_PracticeComponents = [];
    Start_PracticeComponents.push(practice_text);
    Start_PracticeComponents.push(spacebar_text);
    Start_PracticeComponents.push(mouse);
    
    Start_PracticeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Start_PracticeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Start_Practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Start_PracticeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *practice_text* updates
    if (t >= 0.0 && practice_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      practice_text.tStart = t;  // (not accounting for frame time here)
      practice_text.frameNStart = frameN;  // exact frame index
      
      practice_text.setAutoDraw(true);
    }

    
    // *spacebar_text* updates
    if (t >= 0.0 && spacebar_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      spacebar_text.tStart = t;  // (not accounting for frame time here)
      spacebar_text.frameNStart = frameN;  // exact frame index
      
      spacebar_text.setAutoDraw(true);
    }

    // *mouse* updates
    if (t >= 0.0 && mouse.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      mouse.tStart = t;  // (not accounting for frame time here)
      mouse.frameNStart = frameN;  // exact frame index
      
      mouse.status = PsychoJS.Status.STARTED;
      prevButtonState = mouse.getPressed();  // if button is down already this ISN'T a new click
      }
    if (mouse.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = mouse.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // abort routine on response
          continueRoutine = false;
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Start_PracticeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Start_PracticeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Start_Practice'-------
    Start_PracticeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    // the Routine "Start_Practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Meta_Loop;
var currentLoop;
function Meta_LoopLoopBegin(Meta_LoopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  Meta_Loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'Meta_Loop_072418.xlsx',
    seed: undefined, name: 'Meta_Loop'
  });
  psychoJS.experiment.addLoop(Meta_Loop); // add the loop to the experiment
  currentLoop = Meta_Loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  Meta_Loop.forEach(function() {
    const snapshot = Meta_Loop.getSnapshot();

    Meta_LoopLoopScheduler.add(importConditions(snapshot));
    Meta_LoopLoopScheduler.add(Update_loopRoutineBegin(snapshot));
    Meta_LoopLoopScheduler.add(Update_loopRoutineEachFrame(snapshot));
    Meta_LoopLoopScheduler.add(Update_loopRoutineEnd(snapshot));
    Meta_LoopLoopScheduler.add(Check_practice_overRoutineBegin(snapshot));
    Meta_LoopLoopScheduler.add(Check_practice_overRoutineEachFrame(snapshot));
    Meta_LoopLoopScheduler.add(Check_practice_overRoutineEnd(snapshot));
    const Circle_BlocksLoopScheduler = new Scheduler(psychoJS);
    Meta_LoopLoopScheduler.add(Circle_BlocksLoopBegin, Circle_BlocksLoopScheduler);
    Meta_LoopLoopScheduler.add(Circle_BlocksLoopScheduler);
    Meta_LoopLoopScheduler.add(Circle_BlocksLoopEnd);
    Meta_LoopLoopScheduler.add(check_end_experimentRoutineBegin(snapshot));
    Meta_LoopLoopScheduler.add(check_end_experimentRoutineEachFrame(snapshot));
    Meta_LoopLoopScheduler.add(check_end_experimentRoutineEnd(snapshot));
    Meta_LoopLoopScheduler.add(endLoopIteration(Meta_LoopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


var Circle_Blocks;
function Circle_BlocksLoopBegin(Circle_BlocksLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  Circle_Blocks = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: Circle_Loop,
    seed: undefined, name: 'Circle_Blocks'
  });
  psychoJS.experiment.addLoop(Circle_Blocks); // add the loop to the experiment
  currentLoop = Circle_Blocks;  // we're now the current loop

  // Schedule all the trials in the trialList:
  Circle_Blocks.forEach(function() {
    const snapshot = Circle_Blocks.getSnapshot();

    Circle_BlocksLoopScheduler.add(importConditions(snapshot));
    Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(check_first_round_practiceRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Initial_CirclesRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(First_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Second_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Third_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Fourth_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Fifth_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Sixth_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Seventh_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Eighth_Circle_PresentationRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_First_responseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Second_responseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Third_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fourth_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_for_Fifth_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Sixth_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Seventh_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Wait_For_Eighth_ResponseRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Check_outcomeRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Check_outcomeRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Check_outcomeRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Blank_ScreenRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(feedbackRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(feedbackRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(feedbackRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineBegin(snapshot));
    Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineEachFrame(snapshot));
    Circle_BlocksLoopScheduler.add(Repeat_InstructionsRoutineEnd(snapshot));
    Circle_BlocksLoopScheduler.add(endLoopIteration(Circle_BlocksLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function Circle_BlocksLoopEnd() {
  psychoJS.experiment.removeLoop(Circle_Blocks);

  return Scheduler.Event.NEXT;
}


function Meta_LoopLoopEnd() {
  psychoJS.experiment.removeLoop(Meta_Loop);

  return Scheduler.Event.NEXT;
}


var trials_2;
function trials_2LoopBegin(trials_2LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trials_2 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 2, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: undefined,
    seed: undefined, name: 'trials_2'
  });
  psychoJS.experiment.addLoop(trials_2); // add the loop to the experiment
  currentLoop = trials_2;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trials_2.forEach(function() {
    const snapshot = trials_2.getSnapshot();

    trials_2LoopScheduler.add(importConditions(snapshot));
    trials_2LoopScheduler.add(code_metaRoutineBegin(snapshot));
    trials_2LoopScheduler.add(code_metaRoutineEachFrame(snapshot));
    trials_2LoopScheduler.add(code_metaRoutineEnd(snapshot));
    const practiceLoopScheduler = new Scheduler(psychoJS);
    trials_2LoopScheduler.add(practiceLoopBegin, practiceLoopScheduler);
    trials_2LoopScheduler.add(practiceLoopScheduler);
    trials_2LoopScheduler.add(practiceLoopEnd);
    trials_2LoopScheduler.add(code_endRoutineBegin(snapshot));
    trials_2LoopScheduler.add(code_endRoutineEachFrame(snapshot));
    trials_2LoopScheduler.add(code_endRoutineEnd(snapshot));
    trials_2LoopScheduler.add(repeat_instructionsRoutineBegin(snapshot));
    trials_2LoopScheduler.add(repeat_instructionsRoutineEachFrame(snapshot));
    trials_2LoopScheduler.add(repeat_instructionsRoutineEnd(snapshot));
    trials_2LoopScheduler.add(endLoopIteration(trials_2LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


var practice;
function practiceLoopBegin(practiceLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'three_practice.xlsx',
    seed: undefined, name: 'practice'
  });
  psychoJS.experiment.addLoop(practice); // add the loop to the experiment
  currentLoop = practice;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice.forEach(function() {
    const snapshot = practice.getSnapshot();

    practiceLoopScheduler.add(importConditions(snapshot));
    practiceLoopScheduler.add(Presentation_practiceRoutineBegin(snapshot));
    practiceLoopScheduler.add(Presentation_practiceRoutineEachFrame(snapshot));
    practiceLoopScheduler.add(Presentation_practiceRoutineEnd(snapshot));
    practiceLoopScheduler.add(Recall_practiceRoutineBegin(snapshot));
    practiceLoopScheduler.add(Recall_practiceRoutineEachFrame(snapshot));
    practiceLoopScheduler.add(Recall_practiceRoutineEnd(snapshot));
    practiceLoopScheduler.add(feedback_practiceRoutineBegin(snapshot));
    practiceLoopScheduler.add(feedback_practiceRoutineEachFrame(snapshot));
    practiceLoopScheduler.add(feedback_practiceRoutineEnd(snapshot));
    practiceLoopScheduler.add(endLoopIteration(practiceLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practiceLoopEnd() {
  psychoJS.experiment.removeLoop(practice);

  return Scheduler.Event.NEXT;
}


function trials_2LoopEnd() {
  psychoJS.experiment.removeLoop(trials_2);

  return Scheduler.Event.NEXT;
}


var blocks;
function blocksLoopBegin(blocksLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  blocks = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.SEQUENTIAL,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'choose_digitSpan.xlsx',
    seed: undefined, name: 'blocks'
  });
  psychoJS.experiment.addLoop(blocks); // add the loop to the experiment
  currentLoop = blocks;  // we're now the current loop

  // Schedule all the trials in the trialList:
  blocks.forEach(function() {
    const snapshot = blocks.getSnapshot();

    blocksLoopScheduler.add(importConditions(snapshot));
    const trialsLoopScheduler = new Scheduler(psychoJS);
    blocksLoopScheduler.add(trialsLoopBegin, trialsLoopScheduler);
    blocksLoopScheduler.add(trialsLoopScheduler);
    blocksLoopScheduler.add(trialsLoopEnd);
    blocksLoopScheduler.add(endLoopIteration(blocksLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


var trials;
function trialsLoopBegin(trialsLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trials = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: condition_file,
    seed: undefined, name: 'trials'
  });
  psychoJS.experiment.addLoop(trials); // add the loop to the experiment
  currentLoop = trials;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trials.forEach(function() {
    const snapshot = trials.getSnapshot();

    trialsLoopScheduler.add(importConditions(snapshot));
    trialsLoopScheduler.add(PresentationRoutineBegin(snapshot));
    trialsLoopScheduler.add(PresentationRoutineEachFrame(snapshot));
    trialsLoopScheduler.add(PresentationRoutineEnd(snapshot));
    trialsLoopScheduler.add(RecallRoutineBegin(snapshot));
    trialsLoopScheduler.add(RecallRoutineEachFrame(snapshot));
    trialsLoopScheduler.add(RecallRoutineEnd(snapshot));
    trialsLoopScheduler.add(FeedbackRoutineBegin(snapshot));
    trialsLoopScheduler.add(FeedbackRoutineEachFrame(snapshot));
    trialsLoopScheduler.add(FeedbackRoutineEnd(snapshot));
    trialsLoopScheduler.add(endLoopIteration(trialsLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trialsLoopEnd() {
  psychoJS.experiment.removeLoop(trials);

  return Scheduler.Event.NEXT;
}


function blocksLoopEnd() {
  psychoJS.experiment.removeLoop(blocks);

  return Scheduler.Event.NEXT;
}


var practice_congruent_1;
function practice_congruent_1LoopBegin(practice_congruent_1LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_congruent_1 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'test_practice_congruent.xlsx',
    seed: undefined, name: 'practice_congruent_1'
  });
  psychoJS.experiment.addLoop(practice_congruent_1); // add the loop to the experiment
  currentLoop = practice_congruent_1;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_congruent_1.forEach(function() {
    const snapshot = practice_congruent_1.getSnapshot();

    practice_congruent_1LoopScheduler.add(importConditions(snapshot));
    practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineBegin(snapshot));
    practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineEachFrame(snapshot));
    practice_congruent_1LoopScheduler.add(Practice_trial_congruentRoutineEnd(snapshot));
    practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineBegin(snapshot));
    practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineEachFrame(snapshot));
    practice_congruent_1LoopScheduler.add(feedback_hf_congruent_1RoutineEnd(snapshot));
    practice_congruent_1LoopScheduler.add(endLoopIteration(practice_congruent_1LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_congruent_1LoopEnd() {
  psychoJS.experiment.removeLoop(practice_congruent_1);

  return Scheduler.Event.NEXT;
}


var practice_congruent_2;
function practice_congruent_2LoopBegin(practice_congruent_2LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_congruent_2 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice congruent.xlsx',
    seed: undefined, name: 'practice_congruent_2'
  });
  psychoJS.experiment.addLoop(practice_congruent_2); // add the loop to the experiment
  currentLoop = practice_congruent_2;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_congruent_2.forEach(function() {
    const snapshot = practice_congruent_2.getSnapshot();

    practice_congruent_2LoopScheduler.add(importConditions(snapshot));
    practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineBegin(snapshot));
    practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineEachFrame(snapshot));
    practice_congruent_2LoopScheduler.add(Practice_trial_congruent_2RoutineEnd(snapshot));
    practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineBegin(snapshot));
    practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineEachFrame(snapshot));
    practice_congruent_2LoopScheduler.add(feedback_hf_congruent_2RoutineEnd(snapshot));
    practice_congruent_2LoopScheduler.add(endLoopIteration(practice_congruent_2LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_congruent_2LoopEnd() {
  psychoJS.experiment.removeLoop(practice_congruent_2);

  return Scheduler.Event.NEXT;
}


var trial_hearts;
function trial_heartsLoopBegin(trial_heartsLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trial_hearts = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'block1_Hearts.xlsx',
    seed: undefined, name: 'trial_hearts'
  });
  psychoJS.experiment.addLoop(trial_hearts); // add the loop to the experiment
  currentLoop = trial_hearts;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trial_hearts.forEach(function() {
    const snapshot = trial_hearts.getSnapshot();

    trial_heartsLoopScheduler.add(importConditions(snapshot));
    trial_heartsLoopScheduler.add(HeartsRoutineBegin(snapshot));
    trial_heartsLoopScheduler.add(HeartsRoutineEachFrame(snapshot));
    trial_heartsLoopScheduler.add(HeartsRoutineEnd(snapshot));
    trial_heartsLoopScheduler.add(endLoopIteration(trial_heartsLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trial_heartsLoopEnd() {
  psychoJS.experiment.removeLoop(trial_hearts);

  return Scheduler.Event.NEXT;
}


var practice_incongruent_1;
function practice_incongruent_1LoopBegin(practice_incongruent_1LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_incongruent_1 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice incongruent.xlsx',
    seed: undefined, name: 'practice_incongruent_1'
  });
  psychoJS.experiment.addLoop(practice_incongruent_1); // add the loop to the experiment
  currentLoop = practice_incongruent_1;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_incongruent_1.forEach(function() {
    const snapshot = practice_incongruent_1.getSnapshot();

    practice_incongruent_1LoopScheduler.add(importConditions(snapshot));
    practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineBegin(snapshot));
    practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineEachFrame(snapshot));
    practice_incongruent_1LoopScheduler.add(Practice_trial_incongruentRoutineEnd(snapshot));
    practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineBegin(snapshot));
    practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineEachFrame(snapshot));
    practice_incongruent_1LoopScheduler.add(feedback_hf_incongruent_1RoutineEnd(snapshot));
    practice_incongruent_1LoopScheduler.add(endLoopIteration(practice_incongruent_1LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_incongruent_1LoopEnd() {
  psychoJS.experiment.removeLoop(practice_incongruent_1);

  return Scheduler.Event.NEXT;
}


var practice_incongruent_2;
function practice_incongruent_2LoopBegin(practice_incongruent_2LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_incongruent_2 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice incongruent.xlsx',
    seed: undefined, name: 'practice_incongruent_2'
  });
  psychoJS.experiment.addLoop(practice_incongruent_2); // add the loop to the experiment
  currentLoop = practice_incongruent_2;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_incongruent_2.forEach(function() {
    const snapshot = practice_incongruent_2.getSnapshot();

    practice_incongruent_2LoopScheduler.add(importConditions(snapshot));
    practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineBegin(snapshot));
    practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineEachFrame(snapshot));
    practice_incongruent_2LoopScheduler.add(Practice_trial_incongruent_2RoutineEnd(snapshot));
    practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineBegin(snapshot));
    practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineEachFrame(snapshot));
    practice_incongruent_2LoopScheduler.add(feedback_hf_incongruent_2RoutineEnd(snapshot));
    practice_incongruent_2LoopScheduler.add(endLoopIteration(practice_incongruent_2LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_incongruent_2LoopEnd() {
  psychoJS.experiment.removeLoop(practice_incongruent_2);

  return Scheduler.Event.NEXT;
}


var trial_flowers;
function trial_flowersLoopBegin(trial_flowersLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trial_flowers = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'block2_Flowers.xlsx',
    seed: undefined, name: 'trial_flowers'
  });
  psychoJS.experiment.addLoop(trial_flowers); // add the loop to the experiment
  currentLoop = trial_flowers;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trial_flowers.forEach(function() {
    const snapshot = trial_flowers.getSnapshot();

    trial_flowersLoopScheduler.add(importConditions(snapshot));
    trial_flowersLoopScheduler.add(FlowersRoutineBegin(snapshot));
    trial_flowersLoopScheduler.add(FlowersRoutineEachFrame(snapshot));
    trial_flowersLoopScheduler.add(FlowersRoutineEnd(snapshot));
    trial_flowersLoopScheduler.add(endLoopIteration(trial_flowersLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trial_flowersLoopEnd() {
  psychoJS.experiment.removeLoop(trial_flowers);

  return Scheduler.Event.NEXT;
}


var practice_mixed_1;
function practice_mixed_1LoopBegin(practice_mixed_1LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_mixed_1 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice mixed.xlsx',
    seed: undefined, name: 'practice_mixed_1'
  });
  psychoJS.experiment.addLoop(practice_mixed_1); // add the loop to the experiment
  currentLoop = practice_mixed_1;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_mixed_1.forEach(function() {
    const snapshot = practice_mixed_1.getSnapshot();

    practice_mixed_1LoopScheduler.add(importConditions(snapshot));
    practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineBegin(snapshot));
    practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineEachFrame(snapshot));
    practice_mixed_1LoopScheduler.add(Practice_trial_mixedRoutineEnd(snapshot));
    practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineBegin(snapshot));
    practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineEachFrame(snapshot));
    practice_mixed_1LoopScheduler.add(feedback_hf_mixed_1RoutineEnd(snapshot));
    practice_mixed_1LoopScheduler.add(endLoopIteration(practice_mixed_1LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_mixed_1LoopEnd() {
  psychoJS.experiment.removeLoop(practice_mixed_1);

  return Scheduler.Event.NEXT;
}


var practice_mixed_2;
function practice_mixed_2LoopBegin(practice_mixed_2LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  practice_mixed_2 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice mixed.xlsx',
    seed: undefined, name: 'practice_mixed_2'
  });
  psychoJS.experiment.addLoop(practice_mixed_2); // add the loop to the experiment
  currentLoop = practice_mixed_2;  // we're now the current loop

  // Schedule all the trials in the trialList:
  practice_mixed_2.forEach(function() {
    const snapshot = practice_mixed_2.getSnapshot();

    practice_mixed_2LoopScheduler.add(importConditions(snapshot));
    practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineBegin(snapshot));
    practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineEachFrame(snapshot));
    practice_mixed_2LoopScheduler.add(Practice_trial_mixed_2RoutineEnd(snapshot));
    practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineBegin(snapshot));
    practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineEachFrame(snapshot));
    practice_mixed_2LoopScheduler.add(feedback_hf_mixed_2RoutineEnd(snapshot));
    practice_mixed_2LoopScheduler.add(endLoopIteration(practice_mixed_2LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function practice_mixed_2LoopEnd() {
  psychoJS.experiment.removeLoop(practice_mixed_2);

  return Scheduler.Event.NEXT;
}


var trial_mixed;
function trial_mixedLoopBegin(trial_mixedLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trial_mixed = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'block3_Mixed001_random.xlsx',
    seed: undefined, name: 'trial_mixed'
  });
  psychoJS.experiment.addLoop(trial_mixed); // add the loop to the experiment
  currentLoop = trial_mixed;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trial_mixed.forEach(function() {
    const snapshot = trial_mixed.getSnapshot();

    trial_mixedLoopScheduler.add(importConditions(snapshot));
    trial_mixedLoopScheduler.add(MixedRoutineBegin(snapshot));
    trial_mixedLoopScheduler.add(MixedRoutineEachFrame(snapshot));
    trial_mixedLoopScheduler.add(MixedRoutineEnd(snapshot));
    trial_mixedLoopScheduler.add(endLoopIteration(trial_mixedLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trial_mixedLoopEnd() {
  psychoJS.experiment.removeLoop(trial_mixed);

  return Scheduler.Event.NEXT;
}


var even_train_loop;
function even_train_loopLoopBegin(even_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  even_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'even_input.csv',
    seed: undefined, name: 'even_train_loop'
  });
  psychoJS.experiment.addLoop(even_train_loop); // add the loop to the experiment
  currentLoop = even_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  even_train_loop.forEach(function() {
    const snapshot = even_train_loop.getSnapshot();

    even_train_loopLoopScheduler.add(importConditions(snapshot));
    even_train_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    even_train_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    even_train_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    even_train_loopLoopScheduler.add(oe_feedbackRoutineBegin(snapshot));
    even_train_loopLoopScheduler.add(oe_feedbackRoutineEachFrame(snapshot));
    even_train_loopLoopScheduler.add(oe_feedbackRoutineEnd(snapshot));
    even_train_loopLoopScheduler.add(endLoopIteration(even_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function even_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(even_train_loop);

  return Scheduler.Event.NEXT;
}


var even_test_loop;
function even_test_loopLoopBegin(even_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  even_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 2, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'even_input.csv',
    seed: undefined, name: 'even_test_loop'
  });
  psychoJS.experiment.addLoop(even_test_loop); // add the loop to the experiment
  currentLoop = even_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  even_test_loop.forEach(function() {
    const snapshot = even_test_loop.getSnapshot();

    even_test_loopLoopScheduler.add(importConditions(snapshot));
    even_test_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    even_test_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    even_test_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    even_test_loopLoopScheduler.add(endLoopIteration(even_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function even_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(even_test_loop);

  return Scheduler.Event.NEXT;
}


var odd_train_loop;
function odd_train_loopLoopBegin(odd_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  odd_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'odd_input.csv',
    seed: undefined, name: 'odd_train_loop'
  });
  psychoJS.experiment.addLoop(odd_train_loop); // add the loop to the experiment
  currentLoop = odd_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  odd_train_loop.forEach(function() {
    const snapshot = odd_train_loop.getSnapshot();

    odd_train_loopLoopScheduler.add(importConditions(snapshot));
    odd_train_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    odd_train_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    odd_train_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    odd_train_loopLoopScheduler.add(oe_feedbackRoutineBegin(snapshot));
    odd_train_loopLoopScheduler.add(oe_feedbackRoutineEachFrame(snapshot));
    odd_train_loopLoopScheduler.add(oe_feedbackRoutineEnd(snapshot));
    odd_train_loopLoopScheduler.add(endLoopIteration(odd_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function odd_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(odd_train_loop);

  return Scheduler.Event.NEXT;
}


var odd_test_loop;
function odd_test_loopLoopBegin(odd_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  odd_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 2, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'odd_input.csv',
    seed: undefined, name: 'odd_test_loop'
  });
  psychoJS.experiment.addLoop(odd_test_loop); // add the loop to the experiment
  currentLoop = odd_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  odd_test_loop.forEach(function() {
    const snapshot = odd_test_loop.getSnapshot();

    odd_test_loopLoopScheduler.add(importConditions(snapshot));
    odd_test_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    odd_test_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    odd_test_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    odd_test_loopLoopScheduler.add(endLoopIteration(odd_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function odd_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(odd_test_loop);

  return Scheduler.Event.NEXT;
}


var oe_train_loop;
function oe_train_loopLoopBegin(oe_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  oe_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'oe_input.csv',
    seed: undefined, name: 'oe_train_loop'
  });
  psychoJS.experiment.addLoop(oe_train_loop); // add the loop to the experiment
  currentLoop = oe_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  oe_train_loop.forEach(function() {
    const snapshot = oe_train_loop.getSnapshot();

    oe_train_loopLoopScheduler.add(importConditions(snapshot));
    oe_train_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    oe_train_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    oe_train_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    oe_train_loopLoopScheduler.add(oe_feedbackRoutineBegin(snapshot));
    oe_train_loopLoopScheduler.add(oe_feedbackRoutineEachFrame(snapshot));
    oe_train_loopLoopScheduler.add(oe_feedbackRoutineEnd(snapshot));
    oe_train_loopLoopScheduler.add(endLoopIteration(oe_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function oe_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(oe_train_loop);

  return Scheduler.Event.NEXT;
}


var oe_test_loop;
function oe_test_loopLoopBegin(oe_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  oe_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 2, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'oe_input.csv',
    seed: undefined, name: 'oe_test_loop'
  });
  psychoJS.experiment.addLoop(oe_test_loop); // add the loop to the experiment
  currentLoop = oe_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  oe_test_loop.forEach(function() {
    const snapshot = oe_test_loop.getSnapshot();

    oe_test_loopLoopScheduler.add(importConditions(snapshot));
    oe_test_loopLoopScheduler.add(oe_trialRoutineBegin(snapshot));
    oe_test_loopLoopScheduler.add(oe_trialRoutineEachFrame(snapshot));
    oe_test_loopLoopScheduler.add(oe_trialRoutineEnd(snapshot));
    oe_test_loopLoopScheduler.add(endLoopIteration(oe_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function oe_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(oe_test_loop);

  return Scheduler.Event.NEXT;
}


var trials_practice_loop;
function trials_practice_loopLoopBegin(trials_practice_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trials_practice_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'practice_trials.xlsx',
    seed: undefined, name: 'trials_practice_loop'
  });
  psychoJS.experiment.addLoop(trials_practice_loop); // add the loop to the experiment
  currentLoop = trials_practice_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trials_practice_loop.forEach(function() {
    const snapshot = trials_practice_loop.getSnapshot();

    trials_practice_loopLoopScheduler.add(importConditions(snapshot));
    trials_practice_loopLoopScheduler.add(trials_practice_2RoutineBegin(snapshot));
    trials_practice_loopLoopScheduler.add(trials_practice_2RoutineEachFrame(snapshot));
    trials_practice_loopLoopScheduler.add(trials_practice_2RoutineEnd(snapshot));
    trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineBegin(snapshot));
    trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineEachFrame(snapshot));
    trials_practice_loopLoopScheduler.add(feedback_practice_2RoutineEnd(snapshot));
    trials_practice_loopLoopScheduler.add(endLoopIteration(trials_practice_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trials_practice_loopLoopEnd() {
  psychoJS.experiment.removeLoop(trials_practice_loop);

  return Scheduler.Event.NEXT;
}


var blocks_2;
function blocks_2LoopBegin(blocks_2LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  blocks_2 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'chooseRule.xlsx',
    seed: undefined, name: 'blocks_2'
  });
  psychoJS.experiment.addLoop(blocks_2); // add the loop to the experiment
  currentLoop = blocks_2;  // we're now the current loop

  // Schedule all the trials in the trialList:
  blocks_2.forEach(function() {
    const snapshot = blocks_2.getSnapshot();

    blocks_2LoopScheduler.add(importConditions(snapshot));
    blocks_2LoopScheduler.add(code_meta_2RoutineBegin(snapshot));
    blocks_2LoopScheduler.add(code_meta_2RoutineEachFrame(snapshot));
    blocks_2LoopScheduler.add(code_meta_2RoutineEnd(snapshot));
    const trials_3LoopScheduler = new Scheduler(psychoJS);
    blocks_2LoopScheduler.add(trials_3LoopBegin, trials_3LoopScheduler);
    blocks_2LoopScheduler.add(trials_3LoopScheduler);
    blocks_2LoopScheduler.add(trials_3LoopEnd);
    blocks_2LoopScheduler.add(code_end_2RoutineBegin(snapshot));
    blocks_2LoopScheduler.add(code_end_2RoutineEachFrame(snapshot));
    blocks_2LoopScheduler.add(code_end_2RoutineEnd(snapshot));
    blocks_2LoopScheduler.add(endLoopIteration(blocks_2LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


var trials_3;
function trials_3LoopBegin(trials_3LoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  trials_3 = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: condition_file,
    seed: undefined, name: 'trials_3'
  });
  psychoJS.experiment.addLoop(trials_3); // add the loop to the experiment
  currentLoop = trials_3;  // we're now the current loop

  // Schedule all the trials in the trialList:
  trials_3.forEach(function() {
    const snapshot = trials_3.getSnapshot();

    trials_3LoopScheduler.add(importConditions(snapshot));
    trials_3LoopScheduler.add(TrialsRoutineBegin(snapshot));
    trials_3LoopScheduler.add(TrialsRoutineEachFrame(snapshot));
    trials_3LoopScheduler.add(TrialsRoutineEnd(snapshot));
    trials_3LoopScheduler.add(Feedback_2RoutineBegin(snapshot));
    trials_3LoopScheduler.add(Feedback_2RoutineEachFrame(snapshot));
    trials_3LoopScheduler.add(Feedback_2RoutineEnd(snapshot));
    trials_3LoopScheduler.add(endLoopIteration(trials_3LoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function trials_3LoopEnd() {
  psychoJS.experiment.removeLoop(trials_3);

  return Scheduler.Event.NEXT;
}


function blocks_2LoopEnd() {
  psychoJS.experiment.removeLoop(blocks_2);

  return Scheduler.Event.NEXT;
}


var plus_train_loop;
function plus_train_loopLoopBegin(plus_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  plus_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'plus_input.csv',
    seed: undefined, name: 'plus_train_loop'
  });
  psychoJS.experiment.addLoop(plus_train_loop); // add the loop to the experiment
  currentLoop = plus_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  plus_train_loop.forEach(function() {
    const snapshot = plus_train_loop.getSnapshot();

    plus_train_loopLoopScheduler.add(importConditions(snapshot));
    plus_train_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    plus_train_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    plus_train_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    plus_train_loopLoopScheduler.add(pm_feedbackRoutineBegin(snapshot));
    plus_train_loopLoopScheduler.add(pm_feedbackRoutineEachFrame(snapshot));
    plus_train_loopLoopScheduler.add(pm_feedbackRoutineEnd(snapshot));
    plus_train_loopLoopScheduler.add(endLoopIteration(plus_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function plus_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(plus_train_loop);

  return Scheduler.Event.NEXT;
}


var plus_test_loop;
function plus_test_loopLoopBegin(plus_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  plus_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'plus_input.csv',
    seed: undefined, name: 'plus_test_loop'
  });
  psychoJS.experiment.addLoop(plus_test_loop); // add the loop to the experiment
  currentLoop = plus_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  plus_test_loop.forEach(function() {
    const snapshot = plus_test_loop.getSnapshot();

    plus_test_loopLoopScheduler.add(importConditions(snapshot));
    plus_test_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    plus_test_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    plus_test_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    plus_test_loopLoopScheduler.add(endLoopIteration(plus_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function plus_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(plus_test_loop);

  return Scheduler.Event.NEXT;
}


var minus_train_loop;
function minus_train_loopLoopBegin(minus_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  minus_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'minus_input.csv',
    seed: undefined, name: 'minus_train_loop'
  });
  psychoJS.experiment.addLoop(minus_train_loop); // add the loop to the experiment
  currentLoop = minus_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  minus_train_loop.forEach(function() {
    const snapshot = minus_train_loop.getSnapshot();

    minus_train_loopLoopScheduler.add(importConditions(snapshot));
    minus_train_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    minus_train_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    minus_train_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    minus_train_loopLoopScheduler.add(pm_feedbackRoutineBegin(snapshot));
    minus_train_loopLoopScheduler.add(pm_feedbackRoutineEachFrame(snapshot));
    minus_train_loopLoopScheduler.add(pm_feedbackRoutineEnd(snapshot));
    minus_train_loopLoopScheduler.add(endLoopIteration(minus_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function minus_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(minus_train_loop);

  return Scheduler.Event.NEXT;
}


var minus_test_loop;
function minus_test_loopLoopBegin(minus_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  minus_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'minus_input.csv',
    seed: undefined, name: 'minus_test_loop'
  });
  psychoJS.experiment.addLoop(minus_test_loop); // add the loop to the experiment
  currentLoop = minus_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  minus_test_loop.forEach(function() {
    const snapshot = minus_test_loop.getSnapshot();

    minus_test_loopLoopScheduler.add(importConditions(snapshot));
    minus_test_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    minus_test_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    minus_test_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    minus_test_loopLoopScheduler.add(endLoopIteration(minus_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function minus_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(minus_test_loop);

  return Scheduler.Event.NEXT;
}


var pm_train_loop;
function pm_train_loopLoopBegin(pm_train_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  pm_train_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'pm_input.csv',
    seed: undefined, name: 'pm_train_loop'
  });
  psychoJS.experiment.addLoop(pm_train_loop); // add the loop to the experiment
  currentLoop = pm_train_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  pm_train_loop.forEach(function() {
    const snapshot = pm_train_loop.getSnapshot();

    pm_train_loopLoopScheduler.add(importConditions(snapshot));
    pm_train_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    pm_train_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    pm_train_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    pm_train_loopLoopScheduler.add(pm_feedbackRoutineBegin(snapshot));
    pm_train_loopLoopScheduler.add(pm_feedbackRoutineEachFrame(snapshot));
    pm_train_loopLoopScheduler.add(pm_feedbackRoutineEnd(snapshot));
    pm_train_loopLoopScheduler.add(endLoopIteration(pm_train_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function pm_train_loopLoopEnd() {
  psychoJS.experiment.removeLoop(pm_train_loop);

  return Scheduler.Event.NEXT;
}


var pm_test_loop;
function pm_test_loopLoopBegin(pm_test_loopLoopScheduler) {
  // set up handler to look after randomisation of conditions etc
  pm_test_loop = new TrialHandler({
    psychoJS: psychoJS,
    nReps: 1, method: TrialHandler.Method.RANDOM,
    extraInfo: expInfo, originPath: undefined,
    trialList: 'pm_input.csv',
    seed: undefined, name: 'pm_test_loop'
  });
  psychoJS.experiment.addLoop(pm_test_loop); // add the loop to the experiment
  currentLoop = pm_test_loop;  // we're now the current loop

  // Schedule all the trials in the trialList:
  pm_test_loop.forEach(function() {
    const snapshot = pm_test_loop.getSnapshot();

    pm_test_loopLoopScheduler.add(importConditions(snapshot));
    pm_test_loopLoopScheduler.add(pm_trialRoutineBegin(snapshot));
    pm_test_loopLoopScheduler.add(pm_trialRoutineEachFrame(snapshot));
    pm_test_loopLoopScheduler.add(pm_trialRoutineEnd(snapshot));
    pm_test_loopLoopScheduler.add(endLoopIteration(pm_test_loopLoopScheduler, snapshot));
  });

  return Scheduler.Event.NEXT;
}


function pm_test_loopLoopEnd() {
  psychoJS.experiment.removeLoop(pm_test_loop);

  return Scheduler.Event.NEXT;
}


var trials_correct;
var Update_loopComponents;
function Update_loopRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Update_loop'-------
    t = 0;
    Update_loopClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    circle_loop = (circle_loop + 1);
    trial_counter = 0;
    trials_correct = 0;
    
    console.log(circle_loop)
    console.log(trial_counter)
    console.log(trials_correct)
    // keep track of which components have finished
    Update_loopComponents = [];
    
    Update_loopComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Update_loopRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Update_loop'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Update_loopClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Update_loopComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Update_loopRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Update_loop'-------
    Update_loopComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    console.log(circle_loop)
    console.log(trial_counter)
    console.log(trials_correct)
    // the Routine "Update_loop" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Check_practice_overComponents;
function Check_practice_overRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Check_practice_over'-------
    t = 0;
    Check_practice_overClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the mouse_2
    gotValidClick = false; // until a click is received
    mouse_2.mouseClock.reset();
    // keep track of which components have finished
    Check_practice_overComponents = [];
    Check_practice_overComponents.push(text_3);
    Check_practice_overComponents.push(mouse_2);
    Check_practice_overComponents.push(mouse_click_text);
    
    Check_practice_overComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Check_practice_overRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Check_practice_over'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Check_practice_overClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    console.log(circle_loop)
    if (circle_loop == 3) {
        console.log(circle_loop);
        console.log("this is not working");
        continueRoutine = true;
    } else {
        console.log(circle_loop);
        console.log("maybe");
        continueRoutine = false;
    }
    
    // *text_3* updates
    if (t >= 0.0 && text_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_3.tStart = t;  // (not accounting for frame time here)
      text_3.frameNStart = frameN;  // exact frame index
      
      text_3.setAutoDraw(true);
    }

    // *mouse_2* updates
    if (t >= 0.0 && mouse_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      mouse_2.tStart = t;  // (not accounting for frame time here)
      mouse_2.frameNStart = frameN;  // exact frame index
      
      mouse_2.status = PsychoJS.Status.STARTED;
      prevButtonState = mouse_2.getPressed();  // if button is down already this ISN'T a new click
      }
    if (mouse_2.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = mouse_2.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // abort routine on response
          continueRoutine = false;
        }
      }
    }
    
    // *mouse_click_text* updates
    if (t >= 0.0 && mouse_click_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      mouse_click_text.tStart = t;  // (not accounting for frame time here)
      mouse_click_text.frameNStart = frameN;  // exact frame index
      
      mouse_click_text.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Check_practice_overComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Check_practice_overRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Check_practice_over'-------
    Check_practice_overComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    // the Routine "Check_practice_over" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var check_first_round_practiceComponents;
function check_first_round_practiceRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'check_first_round_practice'-------
    t = 0;
    check_first_round_practiceClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    console.log(practice_correct)
    console.log(circle_loop)
    // keep track of which components have finished
    check_first_round_practiceComponents = [];
    
    check_first_round_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function check_first_round_practiceRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'check_first_round_practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = check_first_round_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    check_first_round_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function check_first_round_practiceRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'check_first_round_practice'-------
    check_first_round_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "check_first_round_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var First_Circle_PresentationComponents;
function First_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'First_Circle_Presentation'-------
    t = 0;
    First_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    first_circle_pres_C1.setFillColor(new util.Color(circle1color_first_circle_shown));
    first_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C2.setFillColor(new util.Color(circle2color_first_circle_shown));
    first_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C3.setFillColor(new util.Color(circle3color_first_circle_shown));
    first_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C4.setFillColor(new util.Color(circle4color_first_circle_shown));
    first_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C5.setFillColor(new util.Color(circle5color_first_circle_shown));
    first_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C6.setFillColor(new util.Color(circle6color_first_circle_shown));
    first_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C7.setFillColor(new util.Color(circle7color_first_circle_shown));
    first_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C8.setFillColor(new util.Color(circle8color_first_circle_shown));
    first_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C9.setFillColor(new util.Color(circle9color_first_circle_shown));
    first_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C10.setFillColor(new util.Color(circle10color_first_circle_shown));
    first_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C11.setFillColor(new util.Color(circle11color_first_circle_shown));
    first_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C12.setFillColor(new util.Color(circle12color_first_circle_shown));
    first_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C13.setFillColor(new util.Color(circle13color_first_circle_shown));
    first_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C14.setFillColor(new util.Color(circle14color_first_circle_shown));
    first_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C15.setFillColor(new util.Color(circle15color_first_circle_shown));
    first_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    first_circle_pres_C16.setFillColor(new util.Color(circle16color_first_circle_shown));
    first_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    First_Circle_PresentationComponents = [];
    First_Circle_PresentationComponents.push(first_circle_pres_C1);
    First_Circle_PresentationComponents.push(first_circle_pres_C2);
    First_Circle_PresentationComponents.push(first_circle_pres_C3);
    First_Circle_PresentationComponents.push(first_circle_pres_C4);
    First_Circle_PresentationComponents.push(first_circle_pres_C5);
    First_Circle_PresentationComponents.push(first_circle_pres_C6);
    First_Circle_PresentationComponents.push(first_circle_pres_C7);
    First_Circle_PresentationComponents.push(first_circle_pres_C8);
    First_Circle_PresentationComponents.push(first_circle_pres_C9);
    First_Circle_PresentationComponents.push(first_circle_pres_C10);
    First_Circle_PresentationComponents.push(first_circle_pres_C11);
    First_Circle_PresentationComponents.push(first_circle_pres_C12);
    First_Circle_PresentationComponents.push(first_circle_pres_C13);
    First_Circle_PresentationComponents.push(first_circle_pres_C14);
    First_Circle_PresentationComponents.push(first_circle_pres_C15);
    First_Circle_PresentationComponents.push(first_circle_pres_C16);
    
    First_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function First_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'First_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = First_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *first_circle_pres_C1* updates
    if (t >= 0 && first_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C1.status === PsychoJS.Status.STARTED || first_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C1.setAutoDraw(false);
    }
    
    // *first_circle_pres_C2* updates
    if (t >= 0 && first_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C2.status === PsychoJS.Status.STARTED || first_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C2.setAutoDraw(false);
    }
    
    // *first_circle_pres_C3* updates
    if (t >= 0 && first_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C3.status === PsychoJS.Status.STARTED || first_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C3.setAutoDraw(false);
    }
    
    // *first_circle_pres_C4* updates
    if (t >= 0 && first_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C4.status === PsychoJS.Status.STARTED || first_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C4.setAutoDraw(false);
    }
    
    // *first_circle_pres_C5* updates
    if (t >= 0 && first_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C5.status === PsychoJS.Status.STARTED || first_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C5.setAutoDraw(false);
    }
    
    // *first_circle_pres_C6* updates
    if (t >= 0 && first_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C6.status === PsychoJS.Status.STARTED || first_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C6.setAutoDraw(false);
    }
    
    // *first_circle_pres_C7* updates
    if (t >= 0 && first_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C7.status === PsychoJS.Status.STARTED || first_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C7.setAutoDraw(false);
    }
    
    // *first_circle_pres_C8* updates
    if (t >= 0 && first_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C8.status === PsychoJS.Status.STARTED || first_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C8.setAutoDraw(false);
    }
    
    // *first_circle_pres_C9* updates
    if (t >= 0 && first_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C9.status === PsychoJS.Status.STARTED || first_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C9.setAutoDraw(false);
    }
    
    // *first_circle_pres_C10* updates
    if (t >= 0 && first_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C10.status === PsychoJS.Status.STARTED || first_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C10.setAutoDraw(false);
    }
    
    // *first_circle_pres_C11* updates
    if (t >= 0 && first_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C11.status === PsychoJS.Status.STARTED || first_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C11.setAutoDraw(false);
    }
    
    // *first_circle_pres_C12* updates
    if (t >= 0 && first_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C12.status === PsychoJS.Status.STARTED || first_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C12.setAutoDraw(false);
    }
    
    // *first_circle_pres_C13* updates
    if (t >= 0 && first_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C13.status === PsychoJS.Status.STARTED || first_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C13.setAutoDraw(false);
    }
    
    // *first_circle_pres_C14* updates
    if (t >= 0 && first_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C14.status === PsychoJS.Status.STARTED || first_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C14.setAutoDraw(false);
    }
    
    // *first_circle_pres_C15* updates
    if (t >= 0 && first_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C15.status === PsychoJS.Status.STARTED || first_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C15.setAutoDraw(false);
    }
    
    // *first_circle_pres_C16* updates
    if (t >= 0 && first_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      first_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      first_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((first_circle_pres_C16.status === PsychoJS.Status.STARTED || first_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      first_circle_pres_C16.setAutoDraw(false);
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    First_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function First_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'First_Circle_Presentation'-------
    First_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Second_Circle_PresentationComponents;
function Second_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Second_Circle_Presentation'-------
    t = 0;
    Second_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    second_circle_pres_C1.setFillColor(new util.Color(circle1color_second_circle_shown));
    second_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C2.setFillColor(new util.Color(circle2color_second_circle_shown));
    second_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C3.setFillColor(new util.Color(circle3color_second_circle_shown));
    second_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C4.setFillColor(new util.Color(circle4color_second_circle_shown));
    second_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C5.setFillColor(new util.Color(circle5color_second_circle_shown));
    second_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C6.setFillColor(new util.Color(circle6color_second_circle_shown));
    second_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C7.setFillColor(new util.Color(circle7color_second_circle_shown));
    second_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C8.setFillColor(new util.Color(circle8color_second_circle_shown));
    second_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C9.setFillColor(new util.Color(circle9color_second_circle_shown));
    second_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C10.setFillColor(new util.Color(circle10color_second_circle_shown));
    second_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C11.setFillColor(new util.Color(circle11color_second_circle_shown));
    second_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C12.setFillColor(new util.Color(circle12color_second_circle_shown));
    second_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C13.setFillColor(new util.Color(circle13color_second_circle_shown));
    second_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C14.setFillColor(new util.Color(circle14color_second_circle_shown));
    second_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C15.setFillColor(new util.Color(circle15color_second_circle_shown));
    second_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    second_circle_pres_C16.setFillColor(new util.Color(circle16color_second_circle_shown));
    second_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Second_Circle_PresentationComponents = [];
    Second_Circle_PresentationComponents.push(second_circle_pres_C1);
    Second_Circle_PresentationComponents.push(second_circle_pres_C2);
    Second_Circle_PresentationComponents.push(second_circle_pres_C3);
    Second_Circle_PresentationComponents.push(second_circle_pres_C4);
    Second_Circle_PresentationComponents.push(second_circle_pres_C5);
    Second_Circle_PresentationComponents.push(second_circle_pres_C6);
    Second_Circle_PresentationComponents.push(second_circle_pres_C7);
    Second_Circle_PresentationComponents.push(second_circle_pres_C8);
    Second_Circle_PresentationComponents.push(second_circle_pres_C9);
    Second_Circle_PresentationComponents.push(second_circle_pres_C10);
    Second_Circle_PresentationComponents.push(second_circle_pres_C11);
    Second_Circle_PresentationComponents.push(second_circle_pres_C12);
    Second_Circle_PresentationComponents.push(second_circle_pres_C13);
    Second_Circle_PresentationComponents.push(second_circle_pres_C14);
    Second_Circle_PresentationComponents.push(second_circle_pres_C15);
    Second_Circle_PresentationComponents.push(second_circle_pres_C16);
    
    Second_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Second_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Second_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Second_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *second_circle_pres_C1* updates
    if (t >= 0 && second_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C1.status === PsychoJS.Status.STARTED || second_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C1.setAutoDraw(false);
    }
    
    // *second_circle_pres_C2* updates
    if (t >= 0 && second_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C2.status === PsychoJS.Status.STARTED || second_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C2.setAutoDraw(false);
    }
    
    // *second_circle_pres_C3* updates
    if (t >= 0 && second_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C3.status === PsychoJS.Status.STARTED || second_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C3.setAutoDraw(false);
    }
    
    // *second_circle_pres_C4* updates
    if (t >= 0 && second_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C4.status === PsychoJS.Status.STARTED || second_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C4.setAutoDraw(false);
    }
    
    // *second_circle_pres_C5* updates
    if (t >= 0 && second_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C5.status === PsychoJS.Status.STARTED || second_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C5.setAutoDraw(false);
    }
    
    // *second_circle_pres_C6* updates
    if (t >= 0 && second_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C6.status === PsychoJS.Status.STARTED || second_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C6.setAutoDraw(false);
    }
    
    // *second_circle_pres_C7* updates
    if (t >= 0 && second_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C7.status === PsychoJS.Status.STARTED || second_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C7.setAutoDraw(false);
    }
    
    // *second_circle_pres_C8* updates
    if (t >= 0 && second_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C8.status === PsychoJS.Status.STARTED || second_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C8.setAutoDraw(false);
    }
    
    // *second_circle_pres_C9* updates
    if (t >= 0 && second_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C9.status === PsychoJS.Status.STARTED || second_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C9.setAutoDraw(false);
    }
    
    // *second_circle_pres_C10* updates
    if (t >= 0 && second_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C10.status === PsychoJS.Status.STARTED || second_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C10.setAutoDraw(false);
    }
    
    // *second_circle_pres_C11* updates
    if (t >= 0 && second_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C11.status === PsychoJS.Status.STARTED || second_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C11.setAutoDraw(false);
    }
    
    // *second_circle_pres_C12* updates
    if (t >= 0 && second_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C12.status === PsychoJS.Status.STARTED || second_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C12.setAutoDraw(false);
    }
    
    // *second_circle_pres_C13* updates
    if (t >= 0 && second_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C13.status === PsychoJS.Status.STARTED || second_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C13.setAutoDraw(false);
    }
    
    // *second_circle_pres_C14* updates
    if (t >= 0 && second_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C14.status === PsychoJS.Status.STARTED || second_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C14.setAutoDraw(false);
    }
    
    // *second_circle_pres_C15* updates
    if (t >= 0 && second_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C15.status === PsychoJS.Status.STARTED || second_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C15.setAutoDraw(false);
    }
    
    // *second_circle_pres_C16* updates
    if (t >= 0 && second_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      second_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      second_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((second_circle_pres_C16.status === PsychoJS.Status.STARTED || second_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      second_circle_pres_C16.setAutoDraw(false);
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Second_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Second_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Second_Circle_Presentation'-------
    Second_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Third_Circle_PresentationComponents;
function Third_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Third_Circle_Presentation'-------
    t = 0;
    Third_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    third_circle_pres_C1.setFillColor(new util.Color(circle1color_third_circle_shown));
    third_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C2.setFillColor(new util.Color(circle2color_third_circle_shown));
    third_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C3.setFillColor(new util.Color(circle3color_third_circle_shown));
    third_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C4.setFillColor(new util.Color(circle4color_third_circle_shown));
    third_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C5.setFillColor(new util.Color(circle5color_third_circle_shown));
    third_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C6.setFillColor(new util.Color(circle6color_third_circle_shown));
    third_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C7.setFillColor(new util.Color(circle7color_third_circle_shown));
    third_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C8.setFillColor(new util.Color(circle8color_third_circle_shown));
    third_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C9.setFillColor(new util.Color(circle9color_third_circle_shown));
    third_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C10.setFillColor(new util.Color(circle10color_third_circle_shown));
    third_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C11.setFillColor(new util.Color(circle11color_third_circle_shown));
    third_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C12.setFillColor(new util.Color(circle12color_third_circle_shown));
    third_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C13.setFillColor(new util.Color(circle13color_third_circle_shown));
    third_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C14.setFillColor(new util.Color(circle14color_third_circle_shown));
    third_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C15.setFillColor(new util.Color(circle15color_third_circle_shown));
    third_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    third_circle_pres_C16.setFillColor(new util.Color(circle16color_third_circle_shown));
    third_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Third_Circle_PresentationComponents = [];
    Third_Circle_PresentationComponents.push(third_circle_pres_C1);
    Third_Circle_PresentationComponents.push(third_circle_pres_C2);
    Third_Circle_PresentationComponents.push(third_circle_pres_C3);
    Third_Circle_PresentationComponents.push(third_circle_pres_C4);
    Third_Circle_PresentationComponents.push(third_circle_pres_C5);
    Third_Circle_PresentationComponents.push(third_circle_pres_C6);
    Third_Circle_PresentationComponents.push(third_circle_pres_C7);
    Third_Circle_PresentationComponents.push(third_circle_pres_C8);
    Third_Circle_PresentationComponents.push(third_circle_pres_C9);
    Third_Circle_PresentationComponents.push(third_circle_pres_C10);
    Third_Circle_PresentationComponents.push(third_circle_pres_C11);
    Third_Circle_PresentationComponents.push(third_circle_pres_C12);
    Third_Circle_PresentationComponents.push(third_circle_pres_C13);
    Third_Circle_PresentationComponents.push(third_circle_pres_C14);
    Third_Circle_PresentationComponents.push(third_circle_pres_C15);
    Third_Circle_PresentationComponents.push(third_circle_pres_C16);
    
    Third_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Third_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Third_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Third_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *third_circle_pres_C1* updates
    if (t >= 0 && third_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C1.status === PsychoJS.Status.STARTED || third_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C1.setAutoDraw(false);
    }
    
    // *third_circle_pres_C2* updates
    if (t >= 0 && third_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C2.status === PsychoJS.Status.STARTED || third_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C2.setAutoDraw(false);
    }
    
    // *third_circle_pres_C3* updates
    if (t >= 0 && third_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C3.status === PsychoJS.Status.STARTED || third_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C3.setAutoDraw(false);
    }
    
    // *third_circle_pres_C4* updates
    if (t >= 0 && third_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C4.status === PsychoJS.Status.STARTED || third_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C4.setAutoDraw(false);
    }
    
    // *third_circle_pres_C5* updates
    if (t >= 0 && third_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C5.status === PsychoJS.Status.STARTED || third_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C5.setAutoDraw(false);
    }
    
    // *third_circle_pres_C6* updates
    if (t >= 0 && third_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C6.status === PsychoJS.Status.STARTED || third_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C6.setAutoDraw(false);
    }
    
    // *third_circle_pres_C7* updates
    if (t >= 0 && third_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C7.status === PsychoJS.Status.STARTED || third_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C7.setAutoDraw(false);
    }
    
    // *third_circle_pres_C8* updates
    if (t >= 0 && third_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C8.status === PsychoJS.Status.STARTED || third_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C8.setAutoDraw(false);
    }
    
    // *third_circle_pres_C9* updates
    if (t >= 0 && third_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C9.status === PsychoJS.Status.STARTED || third_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C9.setAutoDraw(false);
    }
    
    // *third_circle_pres_C10* updates
    if (t >= 0 && third_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C10.status === PsychoJS.Status.STARTED || third_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C10.setAutoDraw(false);
    }
    
    // *third_circle_pres_C11* updates
    if (t >= 0 && third_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C11.status === PsychoJS.Status.STARTED || third_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C11.setAutoDraw(false);
    }
    
    // *third_circle_pres_C12* updates
    if (t >= 0 && third_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C12.status === PsychoJS.Status.STARTED || third_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C12.setAutoDraw(false);
    }
    
    // *third_circle_pres_C13* updates
    if (t >= 0 && third_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C13.status === PsychoJS.Status.STARTED || third_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C13.setAutoDraw(false);
    }
    
    // *third_circle_pres_C14* updates
    if (t >= 0 && third_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C14.status === PsychoJS.Status.STARTED || third_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C14.setAutoDraw(false);
    }
    
    // *third_circle_pres_C15* updates
    if (t >= 0 && third_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C15.status === PsychoJS.Status.STARTED || third_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C15.setAutoDraw(false);
    }
    
    // *third_circle_pres_C16* updates
    if (t >= 0 && third_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      third_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      third_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((third_circle_pres_C16.status === PsychoJS.Status.STARTED || third_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      third_circle_pres_C16.setAutoDraw(false);
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Third_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Third_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Third_Circle_Presentation'-------
    Third_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Fourth_Circle_PresentationComponents;
function Fourth_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Fourth_Circle_Presentation'-------
    t = 0;
    Fourth_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    fourth_circle_pres_C1.setFillColor(new util.Color(circle1color_fourth_circle_shown));
    fourth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C2.setFillColor(new util.Color(circle2color_fourth_circle_shown));
    fourth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C3.setFillColor(new util.Color(circle3color_fourth_circle_shown));
    fourth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C4.setFillColor(new util.Color(circle4color_fourth_circle_shown));
    fourth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C5.setFillColor(new util.Color(circle5color_fourth_circle_shown));
    fourth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C6.setFillColor(new util.Color(circle6color_fourth_circle_shown));
    fourth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C7.setFillColor(new util.Color(circle7color_fourth_circle_shown));
    fourth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C8.setFillColor(new util.Color(circle8color_fourth_circle_shown));
    fourth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C9.setFillColor(new util.Color(circle9color_fourth_circle_shown));
    fourth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C10.setFillColor(new util.Color(circle10color_fourth_circle_shown));
    fourth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C11.setFillColor(new util.Color(circle11color_fourth_circle_shown));
    fourth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C12.setFillColor(new util.Color(circle12color_fourth_circle_shown));
    fourth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C13.setFillColor(new util.Color(circle13color_fourth_circle_shown));
    fourth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C14.setFillColor(new util.Color(circle14color_fourth_circle_shown));
    fourth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C15.setFillColor(new util.Color(circle15color_fourth_circle_shown));
    fourth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fourth_circle_pres_C16.setFillColor(new util.Color(circle16color_fourth_circle_shown));
    fourth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Fourth_Circle_PresentationComponents = [];
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C1);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C2);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C3);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C4);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C5);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C6);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C7);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C8);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C9);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C10);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C11);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C12);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C13);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C14);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C15);
    Fourth_Circle_PresentationComponents.push(fourth_circle_pres_C16);
    
    Fourth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Fourth_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Fourth_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Fourth_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 3)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *fourth_circle_pres_C1* updates
    if (t >= 0 && fourth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C1.status === PsychoJS.Status.STARTED || fourth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C1.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C2* updates
    if (t >= 0 && fourth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C2.status === PsychoJS.Status.STARTED || fourth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C2.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C3* updates
    if (t >= 0 && fourth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C3.status === PsychoJS.Status.STARTED || fourth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C3.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C4* updates
    if (t >= 0 && fourth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C4.status === PsychoJS.Status.STARTED || fourth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C4.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C5* updates
    if (t >= 0 && fourth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C5.status === PsychoJS.Status.STARTED || fourth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C5.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C6* updates
    if (t >= 0 && fourth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C6.status === PsychoJS.Status.STARTED || fourth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C6.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C7* updates
    if (t >= 0 && fourth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C7.status === PsychoJS.Status.STARTED || fourth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C7.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C8* updates
    if (t >= 0 && fourth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C8.status === PsychoJS.Status.STARTED || fourth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C8.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C9* updates
    if (t >= 0 && fourth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C9.status === PsychoJS.Status.STARTED || fourth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C9.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C10* updates
    if (t >= 0 && fourth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C10.status === PsychoJS.Status.STARTED || fourth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C10.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C11* updates
    if (t >= 0 && fourth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C11.status === PsychoJS.Status.STARTED || fourth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C11.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C12* updates
    if (t >= 0 && fourth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C12.status === PsychoJS.Status.STARTED || fourth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C12.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C13* updates
    if (t >= 0 && fourth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C13.status === PsychoJS.Status.STARTED || fourth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C13.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C14* updates
    if (t >= 0 && fourth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C14.status === PsychoJS.Status.STARTED || fourth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C14.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C15* updates
    if (t >= 0 && fourth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C15.status === PsychoJS.Status.STARTED || fourth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C15.setAutoDraw(false);
    }
    
    // *fourth_circle_pres_C16* updates
    if (t >= 0 && fourth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      fourth_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      fourth_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fourth_circle_pres_C16.status === PsychoJS.Status.STARTED || fourth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fourth_circle_pres_C16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Fourth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Fourth_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Fourth_Circle_Presentation'-------
    Fourth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Fifth_Circle_PresentationComponents;
function Fifth_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Fifth_Circle_Presentation'-------
    t = 0;
    Fifth_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    fifth_circle_pres_C1.setFillColor(new util.Color(circle1color_fifth_circle_shown));
    fifth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C2.setFillColor(new util.Color(circle2color_fifth_circle_shown));
    fifth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C3.setFillColor(new util.Color(circle3color_fifth_circle_shown));
    fifth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C4.setFillColor(new util.Color(circle4color_fifth_circle_shown));
    fifth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C5.setFillColor(new util.Color(circle5color_fifth_circle_shown));
    fifth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C6.setFillColor(new util.Color(circle6color_fifth_circle_shown));
    fifth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C7.setFillColor(new util.Color(circle7color_fifth_circle_shown));
    fifth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C8.setFillColor(new util.Color(circle8color_fifth_circle_shown));
    fifth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C9.setFillColor(new util.Color(circle9color_fifth_circle_shown));
    fifth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C10.setFillColor(new util.Color(circle10color_fifth_circle_shown));
    fifth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C11.setFillColor(new util.Color(circle11color_fifth_circle_shown));
    fifth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C12.setFillColor(new util.Color(circle12color_fifth_circle_shown));
    fifth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C13.setFillColor(new util.Color(circle13color_fifth_circle_shown));
    fifth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C14.setFillColor(new util.Color(circle14color_fifth_circle_shown));
    fifth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C15.setFillColor(new util.Color(circle15color_fifth_circle_shown));
    fifth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    fifth_circle_pres_C16.setFillColor(new util.Color(circle16color_fifth_circle_shown));
    fifth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Fifth_Circle_PresentationComponents = [];
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C1);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C2);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C3);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C4);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C5);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C6);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C7);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C8);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C9);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C10);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C11);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C12);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C13);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C14);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C15);
    Fifth_Circle_PresentationComponents.push(fifth_circle_pres_C16);
    
    Fifth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Fifth_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Fifth_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Fifth_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 4)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *fifth_circle_pres_C1* updates
    if (t >= 0 && fifth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C1.status === PsychoJS.Status.STARTED || fifth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C1.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C2* updates
    if (t >= 0 && fifth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C2.status === PsychoJS.Status.STARTED || fifth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C2.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C3* updates
    if (t >= 0 && fifth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C3.status === PsychoJS.Status.STARTED || fifth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C3.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C4* updates
    if (t >= 0 && fifth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C4.status === PsychoJS.Status.STARTED || fifth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C4.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C5* updates
    if (t >= 0 && fifth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C5.status === PsychoJS.Status.STARTED || fifth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C5.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C6* updates
    if (t >= 0 && fifth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C6.status === PsychoJS.Status.STARTED || fifth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C6.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C7* updates
    if (t >= 0 && fifth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C7.status === PsychoJS.Status.STARTED || fifth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C7.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C8* updates
    if (t >= 0 && fifth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C8.status === PsychoJS.Status.STARTED || fifth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C8.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C9* updates
    if (t >= 0 && fifth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C9.status === PsychoJS.Status.STARTED || fifth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C9.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C10* updates
    if (t >= 0 && fifth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C10.status === PsychoJS.Status.STARTED || fifth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C10.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C11* updates
    if (t >= 0 && fifth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C11.status === PsychoJS.Status.STARTED || fifth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C11.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C12* updates
    if (t >= 0 && fifth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C12.status === PsychoJS.Status.STARTED || fifth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C12.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C13* updates
    if (t >= 0 && fifth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C13.status === PsychoJS.Status.STARTED || fifth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C13.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C14* updates
    if (t >= 0 && fifth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C14.status === PsychoJS.Status.STARTED || fifth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C14.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C15* updates
    if (t >= 0 && fifth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C15.status === PsychoJS.Status.STARTED || fifth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C15.setAutoDraw(false);
    }
    
    // *fifth_circle_pres_C16* updates
    if (t >= 0 && fifth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      fifth_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      fifth_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fifth_circle_pres_C16.status === PsychoJS.Status.STARTED || fifth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fifth_circle_pres_C16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Fifth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Fifth_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Fifth_Circle_Presentation'-------
    Fifth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Sixth_Circle_PresentationComponents;
function Sixth_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Sixth_Circle_Presentation'-------
    t = 0;
    Sixth_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    sixth_circle_pres_C1.setFillColor(new util.Color(circle1color_sixth_circle_shown));
    sixth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C2.setFillColor(new util.Color(circle2color_sixth_circle_shown));
    sixth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C3.setFillColor(new util.Color(circle3color_sixth_circle_shown));
    sixth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C4.setFillColor(new util.Color(circle4color_sixth_circle_shown));
    sixth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C5.setFillColor(new util.Color(circle5color_sixth_circle_shown));
    sixth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C6.setFillColor(new util.Color(circle6color_sixth_circle_shown));
    sixth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C7.setFillColor(new util.Color(circle7color_sixth_circle_shown));
    sixth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C8.setFillColor(new util.Color(circle8color_sixth_circle_shown));
    sixth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C9.setFillColor(new util.Color(circle9color_sixth_circle_shown));
    sixth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C10.setFillColor(new util.Color(circle10color_sixth_circle_shown));
    sixth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C11.setFillColor(new util.Color(circle11color_sixth_circle_shown));
    sixth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C12.setFillColor(new util.Color(circle12color_sixth_circle_shown));
    sixth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C13.setFillColor(new util.Color(circle13color_sixth_circle_shown));
    sixth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C14.setFillColor(new util.Color(circle14color_sixth_circle_shown));
    sixth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C15.setFillColor(new util.Color(circle15color_sixth_circle_shown));
    sixth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    sixth_circle_pres_C16.setFillColor(new util.Color(circle16color_sixth_circle_shown));
    sixth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Sixth_Circle_PresentationComponents = [];
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C1);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C2);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C3);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C4);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C5);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C6);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C7);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C8);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C9);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C10);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C11);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C12);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C13);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C14);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C15);
    Sixth_Circle_PresentationComponents.push(sixth_circle_pres_C16);
    
    Sixth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Sixth_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Sixth_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Sixth_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 5)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *sixth_circle_pres_C1* updates
    if (t >= 0 && sixth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C1.status === PsychoJS.Status.STARTED || sixth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C1.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C2* updates
    if (t >= 0 && sixth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C2.status === PsychoJS.Status.STARTED || sixth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C2.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C3* updates
    if (t >= 0 && sixth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C3.status === PsychoJS.Status.STARTED || sixth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C3.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C4* updates
    if (t >= 0 && sixth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C4.status === PsychoJS.Status.STARTED || sixth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C4.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C5* updates
    if (t >= 0 && sixth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C5.status === PsychoJS.Status.STARTED || sixth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C5.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C6* updates
    if (t >= 0 && sixth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C6.status === PsychoJS.Status.STARTED || sixth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C6.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C7* updates
    if (t >= 0 && sixth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C7.status === PsychoJS.Status.STARTED || sixth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C7.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C8* updates
    if (t >= 0 && sixth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C8.status === PsychoJS.Status.STARTED || sixth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C8.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C9* updates
    if (t >= 0 && sixth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C9.status === PsychoJS.Status.STARTED || sixth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C9.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C10* updates
    if (t >= 0 && sixth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C10.status === PsychoJS.Status.STARTED || sixth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C10.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C11* updates
    if (t >= 0 && sixth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C11.status === PsychoJS.Status.STARTED || sixth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C11.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C12* updates
    if (t >= 0 && sixth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C12.status === PsychoJS.Status.STARTED || sixth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C12.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C13* updates
    if (t >= 0 && sixth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C13.status === PsychoJS.Status.STARTED || sixth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C13.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C14* updates
    if (t >= 0 && sixth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C14.status === PsychoJS.Status.STARTED || sixth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C14.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C15* updates
    if (t >= 0 && sixth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C15.status === PsychoJS.Status.STARTED || sixth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C15.setAutoDraw(false);
    }
    
    // *sixth_circle_pres_C16* updates
    if (t >= 0 && sixth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      sixth_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      sixth_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((sixth_circle_pres_C16.status === PsychoJS.Status.STARTED || sixth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      sixth_circle_pres_C16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Sixth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Sixth_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Sixth_Circle_Presentation'-------
    Sixth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Seventh_Circle_PresentationComponents;
function Seventh_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Seventh_Circle_Presentation'-------
    t = 0;
    Seventh_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    seventh_circle_pres_C1.setFillColor(new util.Color(circle1color_seventh_circle_shown));
    seventh_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C2.setFillColor(new util.Color(circle2color_seventh_circle_shown));
    seventh_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C3.setFillColor(new util.Color(circle3color_seventh_circle_shown));
    seventh_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C4.setFillColor(new util.Color(circle4color_seventh_circle_shown));
    seventh_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C5.setFillColor(new util.Color(circle5color_seventh_circle_shown));
    seventh_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C6.setFillColor(new util.Color(circle6color_seventh_circle_shown));
    seventh_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C7.setFillColor(new util.Color(circle7color_seventh_circle_shown));
    seventh_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C8.setFillColor(new util.Color(circle8color_seventh_circle_shown));
    seventh_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C9.setFillColor(new util.Color(circle9color_seventh_circle_shown));
    seventh_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C10.setFillColor(new util.Color(circle10color_seventh_circle_shown));
    seventh_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C11.setFillColor(new util.Color(circle11color_seventh_circle_shown));
    seventh_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C12.setFillColor(new util.Color(circle12color_seventh_circle_shown));
    seventh_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C13.setFillColor(new util.Color(circle13color_seventh_circle_shown));
    seventh_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C14.setFillColor(new util.Color(circle14color_seventh_circle_shown));
    seventh_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C15.setFillColor(new util.Color(circle15color_seventh_circle_shown));
    seventh_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    seventh_circle_pres_C16.setFillColor(new util.Color(circle16color_seventh_circle_shown));
    seventh_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Seventh_Circle_PresentationComponents = [];
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C1);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C2);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C3);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C4);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C5);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C6);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C7);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C8);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C9);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C10);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C11);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C12);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C13);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C14);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C15);
    Seventh_Circle_PresentationComponents.push(seventh_circle_pres_C16);
    
    Seventh_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Seventh_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Seventh_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Seventh_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 6)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *seventh_circle_pres_C1* updates
    if (t >= 0 && seventh_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C1.status === PsychoJS.Status.STARTED || seventh_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C1.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C2* updates
    if (t >= 0 && seventh_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C2.status === PsychoJS.Status.STARTED || seventh_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C2.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C3* updates
    if (t >= 0 && seventh_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C3.status === PsychoJS.Status.STARTED || seventh_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C3.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C4* updates
    if (t >= 0 && seventh_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C4.status === PsychoJS.Status.STARTED || seventh_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C4.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C5* updates
    if (t >= 0 && seventh_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C5.status === PsychoJS.Status.STARTED || seventh_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C5.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C6* updates
    if (t >= 0 && seventh_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C6.status === PsychoJS.Status.STARTED || seventh_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C6.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C7* updates
    if (t >= 0 && seventh_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C7.status === PsychoJS.Status.STARTED || seventh_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C7.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C8* updates
    if (t >= 0 && seventh_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C8.status === PsychoJS.Status.STARTED || seventh_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C8.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C9* updates
    if (t >= 0 && seventh_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C9.status === PsychoJS.Status.STARTED || seventh_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C9.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C10* updates
    if (t >= 0 && seventh_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C10.status === PsychoJS.Status.STARTED || seventh_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C10.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C11* updates
    if (t >= 0 && seventh_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C11.status === PsychoJS.Status.STARTED || seventh_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C11.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C12* updates
    if (t >= 0 && seventh_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C12.status === PsychoJS.Status.STARTED || seventh_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C12.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C13* updates
    if (t >= 0 && seventh_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C13.status === PsychoJS.Status.STARTED || seventh_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C13.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C14* updates
    if (t >= 0 && seventh_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C14.status === PsychoJS.Status.STARTED || seventh_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C14.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C15* updates
    if (t >= 0 && seventh_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C15.status === PsychoJS.Status.STARTED || seventh_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C15.setAutoDraw(false);
    }
    
    // *seventh_circle_pres_C16* updates
    if (t >= 0 && seventh_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      seventh_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      seventh_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((seventh_circle_pres_C16.status === PsychoJS.Status.STARTED || seventh_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      seventh_circle_pres_C16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Seventh_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Seventh_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Seventh_Circle_Presentation'-------
    Seventh_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Eighth_Circle_PresentationComponents;
function Eighth_Circle_PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Eighth_Circle_Presentation'-------
    t = 0;
    Eighth_Circle_PresentationClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.900000);
    // update component parameters for each repeat
    eighth_circle_pres_C1.setFillColor(new util.Color(circle1color_eighth_circle_shown));
    eighth_circle_pres_C1.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C2.setFillColor(new util.Color(circle2color_eighth_circle_shown));
    eighth_circle_pres_C2.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C3.setFillColor(new util.Color(circle3color_eighth_circle_shown));
    eighth_circle_pres_C3.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C4.setFillColor(new util.Color(circle4color_eighth_circle_shown));
    eighth_circle_pres_C4.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C5.setFillColor(new util.Color(circle5color_eighth_circle_shown));
    eighth_circle_pres_C5.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C6.setFillColor(new util.Color(circle6color_eighth_circle_shown));
    eighth_circle_pres_C6.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C7.setFillColor(new util.Color(circle7color_eighth_circle_shown));
    eighth_circle_pres_C7.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C8.setFillColor(new util.Color(circle8color_eighth_circle_shown));
    eighth_circle_pres_C8.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C9.setFillColor(new util.Color(circle9color_eighth_circle_shown));
    eighth_circle_pres_C9.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C10.setFillColor(new util.Color(circle10color_eighth_circle_shown));
    eighth_circle_pres_C10.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C11.setFillColor(new util.Color(circle11color_eighth_circle_shown));
    eighth_circle_pres_C11.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C12.setFillColor(new util.Color(circle12color_eighth_circle_shown));
    eighth_circle_pres_C12.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C13.setFillColor(new util.Color(circle13color_eighth_circle_shown));
    eighth_circle_pres_C13.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C14.setFillColor(new util.Color(circle14color_eighth_circle_shown));
    eighth_circle_pres_C14.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C15.setFillColor(new util.Color(circle15color_eighth_circle_shown));
    eighth_circle_pres_C15.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    eighth_circle_pres_C16.setFillColor(new util.Color(circle16color_eighth_circle_shown));
    eighth_circle_pres_C16.setLineColor(new util.Color([1.0, 1.0, 1.0]));
    // keep track of which components have finished
    Eighth_Circle_PresentationComponents = [];
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C1);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C2);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C3);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C4);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C5);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C6);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C7);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C8);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C9);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C10);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C11);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C12);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C13);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C14);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C15);
    Eighth_Circle_PresentationComponents.push(eighth_circle_pres_C16);
    
    Eighth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Eighth_Circle_PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Eighth_Circle_Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Eighth_Circle_PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 7)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *eighth_circle_pres_C1* updates
    if (t >= 0 && eighth_circle_pres_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C1.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C1.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C1.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C1.status === PsychoJS.Status.STARTED || eighth_circle_pres_C1.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C1.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C2* updates
    if (t >= 0 && eighth_circle_pres_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C2.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C2.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C2.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C2.status === PsychoJS.Status.STARTED || eighth_circle_pres_C2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C2.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C3* updates
    if (t >= 0 && eighth_circle_pres_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C3.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C3.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C3.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C3.status === PsychoJS.Status.STARTED || eighth_circle_pres_C3.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C3.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C4* updates
    if (t >= 0 && eighth_circle_pres_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C4.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C4.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C4.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C4.status === PsychoJS.Status.STARTED || eighth_circle_pres_C4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C4.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C5* updates
    if (t >= 0 && eighth_circle_pres_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C5.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C5.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C5.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C5.status === PsychoJS.Status.STARTED || eighth_circle_pres_C5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C5.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C6* updates
    if (t >= 0 && eighth_circle_pres_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C6.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C6.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C6.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C6.status === PsychoJS.Status.STARTED || eighth_circle_pres_C6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C6.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C7* updates
    if (t >= 0 && eighth_circle_pres_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C7.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C7.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C7.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C7.status === PsychoJS.Status.STARTED || eighth_circle_pres_C7.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C7.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C8* updates
    if (t >= 0 && eighth_circle_pres_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C8.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C8.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C8.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C8.status === PsychoJS.Status.STARTED || eighth_circle_pres_C8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C8.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C9* updates
    if (t >= 0 && eighth_circle_pres_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C9.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C9.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C9.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C9.status === PsychoJS.Status.STARTED || eighth_circle_pres_C9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C9.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C10* updates
    if (t >= 0 && eighth_circle_pres_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C10.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C10.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C10.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C10.status === PsychoJS.Status.STARTED || eighth_circle_pres_C10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C10.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C11* updates
    if (t >= 0 && eighth_circle_pres_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C11.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C11.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C11.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C11.status === PsychoJS.Status.STARTED || eighth_circle_pres_C11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C11.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C12* updates
    if (t >= 0 && eighth_circle_pres_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C12.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C12.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C12.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C12.status === PsychoJS.Status.STARTED || eighth_circle_pres_C12.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C12.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C13* updates
    if (t >= 0 && eighth_circle_pres_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C13.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C13.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C13.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C13.status === PsychoJS.Status.STARTED || eighth_circle_pres_C13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C13.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C14* updates
    if (t >= 0 && eighth_circle_pres_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C14.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C14.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C14.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C14.status === PsychoJS.Status.STARTED || eighth_circle_pres_C14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C14.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C15* updates
    if (t >= 0 && eighth_circle_pres_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C15.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C15.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C15.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C15.status === PsychoJS.Status.STARTED || eighth_circle_pres_C15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C15.setAutoDraw(false);
    }
    
    // *eighth_circle_pres_C16* updates
    if (t >= 0 && eighth_circle_pres_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_circle_pres_C16.tStart = t;  // (not accounting for frame time here)
      eighth_circle_pres_C16.frameNStart = frameN;  // exact frame index
      
      eighth_circle_pres_C16.setAutoDraw(true);
    }

    frameRemains = 0 + 0.9 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((eighth_circle_pres_C16.status === PsychoJS.Status.STARTED || eighth_circle_pres_C16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      eighth_circle_pres_C16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Eighth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Eighth_Circle_PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Eighth_Circle_Presentation'-------
    Eighth_Circle_PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var Wait_for_First_responseComponents;
function Wait_for_First_responseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_for_First_response'-------
    t = 0;
    Wait_for_First_responseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the first_mouse_response
    // current position of the mouse:
    first_mouse_response.x = [];
    first_mouse_response.y = [];
    first_mouse_response.leftButton = [];
    first_mouse_response.midButton = [];
    first_mouse_response.rightButton = [];
    first_mouse_response.time = [];
    first_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    first_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_for_First_responseComponents = [];
    Wait_for_First_responseComponents.push(first_response_C1);
    Wait_for_First_responseComponents.push(first_response_C2);
    Wait_for_First_responseComponents.push(first_response_C3);
    Wait_for_First_responseComponents.push(first_response_C4);
    Wait_for_First_responseComponents.push(first_response_C5);
    Wait_for_First_responseComponents.push(first_response_C6);
    Wait_for_First_responseComponents.push(first_response_C7);
    Wait_for_First_responseComponents.push(first_response_C8);
    Wait_for_First_responseComponents.push(first_response_C9);
    Wait_for_First_responseComponents.push(first_response_C10);
    Wait_for_First_responseComponents.push(first_response_C11);
    Wait_for_First_responseComponents.push(first_response_C12);
    Wait_for_First_responseComponents.push(first_response_C13);
    Wait_for_First_responseComponents.push(first_response_C14);
    Wait_for_First_responseComponents.push(first_response_C15);
    Wait_for_First_responseComponents.push(first_response_C16);
    Wait_for_First_responseComponents.push(first_mouse_response);
    
    Wait_for_First_responseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_First_responseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_for_First_response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_for_First_responseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *first_response_C1* updates
    if (t >= 0 && first_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C1.tStart = t;  // (not accounting for frame time here)
      first_response_C1.frameNStart = frameN;  // exact frame index
      
      first_response_C1.setAutoDraw(true);
    }

    
    // *first_response_C2* updates
    if (t >= 0 && first_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C2.tStart = t;  // (not accounting for frame time here)
      first_response_C2.frameNStart = frameN;  // exact frame index
      
      first_response_C2.setAutoDraw(true);
    }

    
    // *first_response_C3* updates
    if (t >= 0 && first_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C3.tStart = t;  // (not accounting for frame time here)
      first_response_C3.frameNStart = frameN;  // exact frame index
      
      first_response_C3.setAutoDraw(true);
    }

    
    // *first_response_C4* updates
    if (t >= 0 && first_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C4.tStart = t;  // (not accounting for frame time here)
      first_response_C4.frameNStart = frameN;  // exact frame index
      
      first_response_C4.setAutoDraw(true);
    }

    
    // *first_response_C5* updates
    if (t >= 0 && first_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C5.tStart = t;  // (not accounting for frame time here)
      first_response_C5.frameNStart = frameN;  // exact frame index
      
      first_response_C5.setAutoDraw(true);
    }

    
    // *first_response_C6* updates
    if (t >= 0 && first_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C6.tStart = t;  // (not accounting for frame time here)
      first_response_C6.frameNStart = frameN;  // exact frame index
      
      first_response_C6.setAutoDraw(true);
    }

    
    // *first_response_C7* updates
    if (t >= 0 && first_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C7.tStart = t;  // (not accounting for frame time here)
      first_response_C7.frameNStart = frameN;  // exact frame index
      
      first_response_C7.setAutoDraw(true);
    }

    
    // *first_response_C8* updates
    if (t >= 0 && first_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C8.tStart = t;  // (not accounting for frame time here)
      first_response_C8.frameNStart = frameN;  // exact frame index
      
      first_response_C8.setAutoDraw(true);
    }

    
    // *first_response_C9* updates
    if (t >= 0 && first_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C9.tStart = t;  // (not accounting for frame time here)
      first_response_C9.frameNStart = frameN;  // exact frame index
      
      first_response_C9.setAutoDraw(true);
    }

    
    // *first_response_C10* updates
    if (t >= 0 && first_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C10.tStart = t;  // (not accounting for frame time here)
      first_response_C10.frameNStart = frameN;  // exact frame index
      
      first_response_C10.setAutoDraw(true);
    }

    
    // *first_response_C11* updates
    if (t >= 0 && first_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C11.tStart = t;  // (not accounting for frame time here)
      first_response_C11.frameNStart = frameN;  // exact frame index
      
      first_response_C11.setAutoDraw(true);
    }

    
    // *first_response_C12* updates
    if (t >= 0 && first_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C12.tStart = t;  // (not accounting for frame time here)
      first_response_C12.frameNStart = frameN;  // exact frame index
      
      first_response_C12.setAutoDraw(true);
    }

    
    // *first_response_C13* updates
    if (t >= 0 && first_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C13.tStart = t;  // (not accounting for frame time here)
      first_response_C13.frameNStart = frameN;  // exact frame index
      
      first_response_C13.setAutoDraw(true);
    }

    
    // *first_response_C14* updates
    if (t >= 0 && first_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C14.tStart = t;  // (not accounting for frame time here)
      first_response_C14.frameNStart = frameN;  // exact frame index
      
      first_response_C14.setAutoDraw(true);
    }

    
    // *first_response_C15* updates
    if (t >= 0 && first_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C15.tStart = t;  // (not accounting for frame time here)
      first_response_C15.frameNStart = frameN;  // exact frame index
      
      first_response_C15.setAutoDraw(true);
    }

    
    // *first_response_C16* updates
    if (t >= 0 && first_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_response_C16.tStart = t;  // (not accounting for frame time here)
      first_response_C16.frameNStart = frameN;  // exact frame index
      
      first_response_C16.setAutoDraw(true);
    }

    // *first_mouse_response* updates
    if (t >= 0.0 && first_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      first_mouse_response.tStart = t;  // (not accounting for frame time here)
      first_mouse_response.frameNStart = frameN;  // exact frame index
      
      first_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = first_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (first_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = first_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = first_mouse_response.getPos();
          first_mouse_response.x.push(_mouseXYs[0]);
          first_mouse_response.y.push(_mouseXYs[1]);
          first_mouse_response.leftButton.push(_mouseButtons[0]);
          first_mouse_response.midButton.push(_mouseButtons[1]);
          first_mouse_response.rightButton.push(_mouseButtons[2]);
          first_mouse_response.time.push(first_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [first_response_C1, first_response_C2, first_response_C3, first_response_C4, first_response_C5, first_response_C6, first_response_C7, first_response_C8, first_response_C9, first_response_C10, first_response_C11, first_response_C12, first_response_C13, first_response_C14, first_response_C15, first_response_C16]) {
            if (obj.contains(first_mouse_response)) {
              gotValidClick = true;
              first_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    
    if (((first_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(first_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_for_First_responseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_First_responseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_for_First_response'-------
    Wait_for_First_responseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('first_mouse_response.x', first_mouse_response.x);
    psychoJS.experiment.addData('first_mouse_response.y', first_mouse_response.y);
    psychoJS.experiment.addData('first_mouse_response.leftButton', first_mouse_response.leftButton);
    psychoJS.experiment.addData('first_mouse_response.midButton', first_mouse_response.midButton);
    psychoJS.experiment.addData('first_mouse_response.rightButton', first_mouse_response.rightButton);
    psychoJS.experiment.addData('first_mouse_response.time', first_mouse_response.time);
    psychoJS.experiment.addData('first_mouse_response.clicked_name', first_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_for_First_response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_for_Second_responseComponents;
function Wait_for_Second_responseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_for_Second_response'-------
    t = 0;
    Wait_for_Second_responseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the second_mouse_response
    // current position of the mouse:
    second_mouse_response.x = [];
    second_mouse_response.y = [];
    second_mouse_response.leftButton = [];
    second_mouse_response.midButton = [];
    second_mouse_response.rightButton = [];
    second_mouse_response.time = [];
    second_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    second_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_for_Second_responseComponents = [];
    Wait_for_Second_responseComponents.push(second_response_C1);
    Wait_for_Second_responseComponents.push(second_response_C2);
    Wait_for_Second_responseComponents.push(second_response_C3);
    Wait_for_Second_responseComponents.push(second_response_C4);
    Wait_for_Second_responseComponents.push(second_response_C5);
    Wait_for_Second_responseComponents.push(second_response_C6);
    Wait_for_Second_responseComponents.push(second_response_C7);
    Wait_for_Second_responseComponents.push(second_response_C8);
    Wait_for_Second_responseComponents.push(second_response_C9);
    Wait_for_Second_responseComponents.push(second_response_C10);
    Wait_for_Second_responseComponents.push(second_response_C11);
    Wait_for_Second_responseComponents.push(second_response_C12);
    Wait_for_Second_responseComponents.push(second_response_C13);
    Wait_for_Second_responseComponents.push(second_response_C14);
    Wait_for_Second_responseComponents.push(second_response_C15);
    Wait_for_Second_responseComponents.push(second_response_C16);
    Wait_for_Second_responseComponents.push(second_mouse_response);
    
    Wait_for_Second_responseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Second_responseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_for_Second_response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_for_Second_responseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *second_response_C1* updates
    if (t >= 0 && second_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C1.tStart = t;  // (not accounting for frame time here)
      second_response_C1.frameNStart = frameN;  // exact frame index
      
      second_response_C1.setAutoDraw(true);
    }

    
    // *second_response_C2* updates
    if (t >= 0 && second_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C2.tStart = t;  // (not accounting for frame time here)
      second_response_C2.frameNStart = frameN;  // exact frame index
      
      second_response_C2.setAutoDraw(true);
    }

    
    // *second_response_C3* updates
    if (t >= 0 && second_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C3.tStart = t;  // (not accounting for frame time here)
      second_response_C3.frameNStart = frameN;  // exact frame index
      
      second_response_C3.setAutoDraw(true);
    }

    
    // *second_response_C4* updates
    if (t >= 0 && second_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C4.tStart = t;  // (not accounting for frame time here)
      second_response_C4.frameNStart = frameN;  // exact frame index
      
      second_response_C4.setAutoDraw(true);
    }

    
    // *second_response_C5* updates
    if (t >= 0 && second_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C5.tStart = t;  // (not accounting for frame time here)
      second_response_C5.frameNStart = frameN;  // exact frame index
      
      second_response_C5.setAutoDraw(true);
    }

    
    // *second_response_C6* updates
    if (t >= 0 && second_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C6.tStart = t;  // (not accounting for frame time here)
      second_response_C6.frameNStart = frameN;  // exact frame index
      
      second_response_C6.setAutoDraw(true);
    }

    
    // *second_response_C7* updates
    if (t >= 0 && second_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C7.tStart = t;  // (not accounting for frame time here)
      second_response_C7.frameNStart = frameN;  // exact frame index
      
      second_response_C7.setAutoDraw(true);
    }

    
    // *second_response_C8* updates
    if (t >= 0 && second_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C8.tStart = t;  // (not accounting for frame time here)
      second_response_C8.frameNStart = frameN;  // exact frame index
      
      second_response_C8.setAutoDraw(true);
    }

    
    // *second_response_C9* updates
    if (t >= 0 && second_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C9.tStart = t;  // (not accounting for frame time here)
      second_response_C9.frameNStart = frameN;  // exact frame index
      
      second_response_C9.setAutoDraw(true);
    }

    
    // *second_response_C10* updates
    if (t >= 0 && second_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C10.tStart = t;  // (not accounting for frame time here)
      second_response_C10.frameNStart = frameN;  // exact frame index
      
      second_response_C10.setAutoDraw(true);
    }

    
    // *second_response_C11* updates
    if (t >= 0 && second_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C11.tStart = t;  // (not accounting for frame time here)
      second_response_C11.frameNStart = frameN;  // exact frame index
      
      second_response_C11.setAutoDraw(true);
    }

    
    // *second_response_C12* updates
    if (t >= 0 && second_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C12.tStart = t;  // (not accounting for frame time here)
      second_response_C12.frameNStart = frameN;  // exact frame index
      
      second_response_C12.setAutoDraw(true);
    }

    
    // *second_response_C13* updates
    if (t >= 0 && second_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C13.tStart = t;  // (not accounting for frame time here)
      second_response_C13.frameNStart = frameN;  // exact frame index
      
      second_response_C13.setAutoDraw(true);
    }

    
    // *second_response_C14* updates
    if (t >= 0 && second_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C14.tStart = t;  // (not accounting for frame time here)
      second_response_C14.frameNStart = frameN;  // exact frame index
      
      second_response_C14.setAutoDraw(true);
    }

    
    // *second_response_C15* updates
    if (t >= 0 && second_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C15.tStart = t;  // (not accounting for frame time here)
      second_response_C15.frameNStart = frameN;  // exact frame index
      
      second_response_C15.setAutoDraw(true);
    }

    
    // *second_response_C16* updates
    if (t >= 0 && second_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_response_C16.tStart = t;  // (not accounting for frame time here)
      second_response_C16.frameNStart = frameN;  // exact frame index
      
      second_response_C16.setAutoDraw(true);
    }

    // *second_mouse_response* updates
    if (t >= 0.0 && second_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      second_mouse_response.tStart = t;  // (not accounting for frame time here)
      second_mouse_response.frameNStart = frameN;  // exact frame index
      
      second_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = second_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (second_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = second_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = second_mouse_response.getPos();
          second_mouse_response.x.push(_mouseXYs[0]);
          second_mouse_response.y.push(_mouseXYs[1]);
          second_mouse_response.leftButton.push(_mouseButtons[0]);
          second_mouse_response.midButton.push(_mouseButtons[1]);
          second_mouse_response.rightButton.push(_mouseButtons[2]);
          second_mouse_response.time.push(second_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [second_response_C1, second_response_C2, second_response_C3, second_response_C4, second_response_C5, second_response_C6, second_response_C7, second_response_C8, second_response_C9, second_response_C10, second_response_C11, second_response_C12, second_response_C13, second_response_C14, second_response_C15, second_response_C16]) {
            if (obj.contains(second_mouse_response)) {
              gotValidClick = true;
              second_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    if (((second_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(second_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_for_Second_responseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Second_responseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_for_Second_response'-------
    Wait_for_Second_responseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('second_mouse_response.x', second_mouse_response.x);
    psychoJS.experiment.addData('second_mouse_response.y', second_mouse_response.y);
    psychoJS.experiment.addData('second_mouse_response.leftButton', second_mouse_response.leftButton);
    psychoJS.experiment.addData('second_mouse_response.midButton', second_mouse_response.midButton);
    psychoJS.experiment.addData('second_mouse_response.rightButton', second_mouse_response.rightButton);
    psychoJS.experiment.addData('second_mouse_response.time', second_mouse_response.time);
    psychoJS.experiment.addData('second_mouse_response.clicked_name', second_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_for_Second_response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_for_Third_ResponseComponents;
function Wait_for_Third_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_for_Third_Response'-------
    t = 0;
    Wait_for_Third_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the third_mouse_response
    // current position of the mouse:
    third_mouse_response.x = [];
    third_mouse_response.y = [];
    third_mouse_response.leftButton = [];
    third_mouse_response.midButton = [];
    third_mouse_response.rightButton = [];
    third_mouse_response.time = [];
    third_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    third_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_for_Third_ResponseComponents = [];
    Wait_for_Third_ResponseComponents.push(third_response_C1);
    Wait_for_Third_ResponseComponents.push(third_response_C2);
    Wait_for_Third_ResponseComponents.push(third_response_C3);
    Wait_for_Third_ResponseComponents.push(third_response_C4);
    Wait_for_Third_ResponseComponents.push(third_response_C5);
    Wait_for_Third_ResponseComponents.push(third_response_C6);
    Wait_for_Third_ResponseComponents.push(third_response_C7);
    Wait_for_Third_ResponseComponents.push(third_response_C8);
    Wait_for_Third_ResponseComponents.push(third_response_C9);
    Wait_for_Third_ResponseComponents.push(third_response_C10);
    Wait_for_Third_ResponseComponents.push(third_response_C11);
    Wait_for_Third_ResponseComponents.push(third_response_C12);
    Wait_for_Third_ResponseComponents.push(third_response_C13);
    Wait_for_Third_ResponseComponents.push(third_response_C14);
    Wait_for_Third_ResponseComponents.push(third_response_C15);
    Wait_for_Third_ResponseComponents.push(third_response_C16);
    Wait_for_Third_ResponseComponents.push(third_mouse_response);
    
    Wait_for_Third_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Third_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_for_Third_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_for_Third_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *third_response_C1* updates
    if (t >= 0 && third_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C1.tStart = t;  // (not accounting for frame time here)
      third_response_C1.frameNStart = frameN;  // exact frame index
      
      third_response_C1.setAutoDraw(true);
    }

    
    // *third_response_C2* updates
    if (t >= 0 && third_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C2.tStart = t;  // (not accounting for frame time here)
      third_response_C2.frameNStart = frameN;  // exact frame index
      
      third_response_C2.setAutoDraw(true);
    }

    
    // *third_response_C3* updates
    if (t >= 0 && third_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C3.tStart = t;  // (not accounting for frame time here)
      third_response_C3.frameNStart = frameN;  // exact frame index
      
      third_response_C3.setAutoDraw(true);
    }

    
    // *third_response_C4* updates
    if (t >= 0 && third_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C4.tStart = t;  // (not accounting for frame time here)
      third_response_C4.frameNStart = frameN;  // exact frame index
      
      third_response_C4.setAutoDraw(true);
    }

    
    // *third_response_C5* updates
    if (t >= 0 && third_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C5.tStart = t;  // (not accounting for frame time here)
      third_response_C5.frameNStart = frameN;  // exact frame index
      
      third_response_C5.setAutoDraw(true);
    }

    
    // *third_response_C6* updates
    if (t >= 0 && third_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C6.tStart = t;  // (not accounting for frame time here)
      third_response_C6.frameNStart = frameN;  // exact frame index
      
      third_response_C6.setAutoDraw(true);
    }

    
    // *third_response_C7* updates
    if (t >= 0 && third_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C7.tStart = t;  // (not accounting for frame time here)
      third_response_C7.frameNStart = frameN;  // exact frame index
      
      third_response_C7.setAutoDraw(true);
    }

    
    // *third_response_C8* updates
    if (t >= 0 && third_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C8.tStart = t;  // (not accounting for frame time here)
      third_response_C8.frameNStart = frameN;  // exact frame index
      
      third_response_C8.setAutoDraw(true);
    }

    
    // *third_response_C9* updates
    if (t >= 0 && third_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C9.tStart = t;  // (not accounting for frame time here)
      third_response_C9.frameNStart = frameN;  // exact frame index
      
      third_response_C9.setAutoDraw(true);
    }

    
    // *third_response_C10* updates
    if (t >= 0 && third_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C10.tStart = t;  // (not accounting for frame time here)
      third_response_C10.frameNStart = frameN;  // exact frame index
      
      third_response_C10.setAutoDraw(true);
    }

    
    // *third_response_C11* updates
    if (t >= 0 && third_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C11.tStart = t;  // (not accounting for frame time here)
      third_response_C11.frameNStart = frameN;  // exact frame index
      
      third_response_C11.setAutoDraw(true);
    }

    
    // *third_response_C12* updates
    if (t >= 0 && third_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C12.tStart = t;  // (not accounting for frame time here)
      third_response_C12.frameNStart = frameN;  // exact frame index
      
      third_response_C12.setAutoDraw(true);
    }

    
    // *third_response_C13* updates
    if (t >= 0 && third_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C13.tStart = t;  // (not accounting for frame time here)
      third_response_C13.frameNStart = frameN;  // exact frame index
      
      third_response_C13.setAutoDraw(true);
    }

    
    // *third_response_C14* updates
    if (t >= 0 && third_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C14.tStart = t;  // (not accounting for frame time here)
      third_response_C14.frameNStart = frameN;  // exact frame index
      
      third_response_C14.setAutoDraw(true);
    }

    
    // *third_response_C15* updates
    if (t >= 0 && third_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C15.tStart = t;  // (not accounting for frame time here)
      third_response_C15.frameNStart = frameN;  // exact frame index
      
      third_response_C15.setAutoDraw(true);
    }

    
    // *third_response_C16* updates
    if (t >= 0 && third_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_response_C16.tStart = t;  // (not accounting for frame time here)
      third_response_C16.frameNStart = frameN;  // exact frame index
      
      third_response_C16.setAutoDraw(true);
    }

    // *third_mouse_response* updates
    if (t >= 0.0 && third_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      third_mouse_response.tStart = t;  // (not accounting for frame time here)
      third_mouse_response.frameNStart = frameN;  // exact frame index
      
      third_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = third_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (third_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = third_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = third_mouse_response.getPos();
          third_mouse_response.x.push(_mouseXYs[0]);
          third_mouse_response.y.push(_mouseXYs[1]);
          third_mouse_response.leftButton.push(_mouseButtons[0]);
          third_mouse_response.midButton.push(_mouseButtons[1]);
          third_mouse_response.rightButton.push(_mouseButtons[2]);
          third_mouse_response.time.push(third_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [third_response_C1, third_response_C2, third_response_C3, third_response_C4, third_response_C5, third_response_C6, third_response_C7, third_response_C8, third_response_C9, third_response_C10, third_response_C11, third_response_C12, third_response_C13, third_response_C14, third_response_C15, third_response_C16]) {
            if (obj.contains(third_mouse_response)) {
              gotValidClick = true;
              third_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    
    if (((third_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(third_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_for_Third_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Third_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_for_Third_Response'-------
    Wait_for_Third_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('third_mouse_response.x', third_mouse_response.x);
    psychoJS.experiment.addData('third_mouse_response.y', third_mouse_response.y);
    psychoJS.experiment.addData('third_mouse_response.leftButton', third_mouse_response.leftButton);
    psychoJS.experiment.addData('third_mouse_response.midButton', third_mouse_response.midButton);
    psychoJS.experiment.addData('third_mouse_response.rightButton', third_mouse_response.rightButton);
    psychoJS.experiment.addData('third_mouse_response.time', third_mouse_response.time);
    psychoJS.experiment.addData('third_mouse_response.clicked_name', third_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_for_Third_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_for_Fourth_ResponseComponents;
function Wait_for_Fourth_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_for_Fourth_Response'-------
    t = 0;
    Wait_for_Fourth_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    
    
    // setup some python lists for storing info about the fourth_mouse_response
    // current position of the mouse:
    fourth_mouse_response.x = [];
    fourth_mouse_response.y = [];
    fourth_mouse_response.leftButton = [];
    fourth_mouse_response.midButton = [];
    fourth_mouse_response.rightButton = [];
    fourth_mouse_response.time = [];
    fourth_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    fourth_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_for_Fourth_ResponseComponents = [];
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C1);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C2);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C3);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C4);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C5);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C6);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C7);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C8);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C9);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C10);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C11);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C12);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C13);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C14);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C15);
    Wait_for_Fourth_ResponseComponents.push(fourth_response_C16);
    Wait_for_Fourth_ResponseComponents.push(fourth_mouse_response);
    
    Wait_for_Fourth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Fourth_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_for_Fourth_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_for_Fourth_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 3)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    // *fourth_response_C1* updates
    if (t >= 0 && fourth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C1.tStart = t;  // (not accounting for frame time here)
      fourth_response_C1.frameNStart = frameN;  // exact frame index
      
      fourth_response_C1.setAutoDraw(true);
    }

    
    // *fourth_response_C2* updates
    if (t >= 0 && fourth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C2.tStart = t;  // (not accounting for frame time here)
      fourth_response_C2.frameNStart = frameN;  // exact frame index
      
      fourth_response_C2.setAutoDraw(true);
    }

    
    // *fourth_response_C3* updates
    if (t >= 0 && fourth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C3.tStart = t;  // (not accounting for frame time here)
      fourth_response_C3.frameNStart = frameN;  // exact frame index
      
      fourth_response_C3.setAutoDraw(true);
    }

    
    // *fourth_response_C4* updates
    if (t >= 0 && fourth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C4.tStart = t;  // (not accounting for frame time here)
      fourth_response_C4.frameNStart = frameN;  // exact frame index
      
      fourth_response_C4.setAutoDraw(true);
    }

    
    // *fourth_response_C5* updates
    if (t >= 0 && fourth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C5.tStart = t;  // (not accounting for frame time here)
      fourth_response_C5.frameNStart = frameN;  // exact frame index
      
      fourth_response_C5.setAutoDraw(true);
    }

    
    // *fourth_response_C6* updates
    if (t >= 0 && fourth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C6.tStart = t;  // (not accounting for frame time here)
      fourth_response_C6.frameNStart = frameN;  // exact frame index
      
      fourth_response_C6.setAutoDraw(true);
    }

    
    // *fourth_response_C7* updates
    if (t >= 0 && fourth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C7.tStart = t;  // (not accounting for frame time here)
      fourth_response_C7.frameNStart = frameN;  // exact frame index
      
      fourth_response_C7.setAutoDraw(true);
    }

    
    // *fourth_response_C8* updates
    if (t >= 0 && fourth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C8.tStart = t;  // (not accounting for frame time here)
      fourth_response_C8.frameNStart = frameN;  // exact frame index
      
      fourth_response_C8.setAutoDraw(true);
    }

    
    // *fourth_response_C9* updates
    if (t >= 0 && fourth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C9.tStart = t;  // (not accounting for frame time here)
      fourth_response_C9.frameNStart = frameN;  // exact frame index
      
      fourth_response_C9.setAutoDraw(true);
    }

    
    // *fourth_response_C10* updates
    if (t >= 0 && fourth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C10.tStart = t;  // (not accounting for frame time here)
      fourth_response_C10.frameNStart = frameN;  // exact frame index
      
      fourth_response_C10.setAutoDraw(true);
    }

    
    // *fourth_response_C11* updates
    if (t >= 0 && fourth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C11.tStart = t;  // (not accounting for frame time here)
      fourth_response_C11.frameNStart = frameN;  // exact frame index
      
      fourth_response_C11.setAutoDraw(true);
    }

    
    // *fourth_response_C12* updates
    if (t >= 0 && fourth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C12.tStart = t;  // (not accounting for frame time here)
      fourth_response_C12.frameNStart = frameN;  // exact frame index
      
      fourth_response_C12.setAutoDraw(true);
    }

    
    // *fourth_response_C13* updates
    if (t >= 0 && fourth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C13.tStart = t;  // (not accounting for frame time here)
      fourth_response_C13.frameNStart = frameN;  // exact frame index
      
      fourth_response_C13.setAutoDraw(true);
    }

    
    // *fourth_response_C14* updates
    if (t >= 0 && fourth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C14.tStart = t;  // (not accounting for frame time here)
      fourth_response_C14.frameNStart = frameN;  // exact frame index
      
      fourth_response_C14.setAutoDraw(true);
    }

    
    // *fourth_response_C15* updates
    if (t >= 0 && fourth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C15.tStart = t;  // (not accounting for frame time here)
      fourth_response_C15.frameNStart = frameN;  // exact frame index
      
      fourth_response_C15.setAutoDraw(true);
    }

    
    // *fourth_response_C16* updates
    if (t >= 0 && fourth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_response_C16.tStart = t;  // (not accounting for frame time here)
      fourth_response_C16.frameNStart = frameN;  // exact frame index
      
      fourth_response_C16.setAutoDraw(true);
    }

    // *fourth_mouse_response* updates
    if (t >= 0.0 && fourth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fourth_mouse_response.tStart = t;  // (not accounting for frame time here)
      fourth_mouse_response.frameNStart = frameN;  // exact frame index
      
      fourth_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = fourth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (fourth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = fourth_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = fourth_mouse_response.getPos();
          fourth_mouse_response.x.push(_mouseXYs[0]);
          fourth_mouse_response.y.push(_mouseXYs[1]);
          fourth_mouse_response.leftButton.push(_mouseButtons[0]);
          fourth_mouse_response.midButton.push(_mouseButtons[1]);
          fourth_mouse_response.rightButton.push(_mouseButtons[2]);
          fourth_mouse_response.time.push(fourth_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [fourth_response_C1, fourth_response_C2, fourth_response_C3, fourth_response_C4, fourth_response_C5, fourth_response_C6, fourth_response_C7, fourth_response_C8, fourth_response_C9, fourth_response_C10, fourth_response_C11, fourth_response_C12, fourth_response_C13, fourth_response_C14, fourth_response_C15, fourth_response_C16]) {
            if (obj.contains(fourth_mouse_response)) {
              gotValidClick = true;
              fourth_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((fourth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(fourth_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_for_Fourth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Fourth_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_for_Fourth_Response'-------
    Wait_for_Fourth_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('fourth_mouse_response.x', fourth_mouse_response.x);
    psychoJS.experiment.addData('fourth_mouse_response.y', fourth_mouse_response.y);
    psychoJS.experiment.addData('fourth_mouse_response.leftButton', fourth_mouse_response.leftButton);
    psychoJS.experiment.addData('fourth_mouse_response.midButton', fourth_mouse_response.midButton);
    psychoJS.experiment.addData('fourth_mouse_response.rightButton', fourth_mouse_response.rightButton);
    psychoJS.experiment.addData('fourth_mouse_response.time', fourth_mouse_response.time);
    psychoJS.experiment.addData('fourth_mouse_response.clicked_name', fourth_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_for_Fourth_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_for_Fifth_ResponseComponents;
function Wait_for_Fifth_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_for_Fifth_Response'-------
    t = 0;
    Wait_for_Fifth_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the fifth_mouse_response
    // current position of the mouse:
    fifth_mouse_response.x = [];
    fifth_mouse_response.y = [];
    fifth_mouse_response.leftButton = [];
    fifth_mouse_response.midButton = [];
    fifth_mouse_response.rightButton = [];
    fifth_mouse_response.time = [];
    fifth_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    fifth_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_for_Fifth_ResponseComponents = [];
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C1);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C2);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C3);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C4);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C5);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C6);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C7);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C8);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C9);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C10);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C11);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C12);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C13);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C14);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C15);
    Wait_for_Fifth_ResponseComponents.push(fifth_response_C16);
    Wait_for_Fifth_ResponseComponents.push(fifth_mouse_response);
    
    Wait_for_Fifth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Fifth_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_for_Fifth_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_for_Fifth_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 4)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *fifth_response_C1* updates
    if (t >= 0 && fifth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C1.tStart = t;  // (not accounting for frame time here)
      fifth_response_C1.frameNStart = frameN;  // exact frame index
      
      fifth_response_C1.setAutoDraw(true);
    }

    
    // *fifth_response_C2* updates
    if (t >= 0 && fifth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C2.tStart = t;  // (not accounting for frame time here)
      fifth_response_C2.frameNStart = frameN;  // exact frame index
      
      fifth_response_C2.setAutoDraw(true);
    }

    
    // *fifth_response_C3* updates
    if (t >= 0 && fifth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C3.tStart = t;  // (not accounting for frame time here)
      fifth_response_C3.frameNStart = frameN;  // exact frame index
      
      fifth_response_C3.setAutoDraw(true);
    }

    
    // *fifth_response_C4* updates
    if (t >= 0 && fifth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C4.tStart = t;  // (not accounting for frame time here)
      fifth_response_C4.frameNStart = frameN;  // exact frame index
      
      fifth_response_C4.setAutoDraw(true);
    }

    
    // *fifth_response_C5* updates
    if (t >= 0 && fifth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C5.tStart = t;  // (not accounting for frame time here)
      fifth_response_C5.frameNStart = frameN;  // exact frame index
      
      fifth_response_C5.setAutoDraw(true);
    }

    
    // *fifth_response_C6* updates
    if (t >= 0 && fifth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C6.tStart = t;  // (not accounting for frame time here)
      fifth_response_C6.frameNStart = frameN;  // exact frame index
      
      fifth_response_C6.setAutoDraw(true);
    }

    
    // *fifth_response_C7* updates
    if (t >= 0 && fifth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C7.tStart = t;  // (not accounting for frame time here)
      fifth_response_C7.frameNStart = frameN;  // exact frame index
      
      fifth_response_C7.setAutoDraw(true);
    }

    
    // *fifth_response_C8* updates
    if (t >= 0 && fifth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C8.tStart = t;  // (not accounting for frame time here)
      fifth_response_C8.frameNStart = frameN;  // exact frame index
      
      fifth_response_C8.setAutoDraw(true);
    }

    
    // *fifth_response_C9* updates
    if (t >= 0 && fifth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C9.tStart = t;  // (not accounting for frame time here)
      fifth_response_C9.frameNStart = frameN;  // exact frame index
      
      fifth_response_C9.setAutoDraw(true);
    }

    
    // *fifth_response_C10* updates
    if (t >= 0 && fifth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C10.tStart = t;  // (not accounting for frame time here)
      fifth_response_C10.frameNStart = frameN;  // exact frame index
      
      fifth_response_C10.setAutoDraw(true);
    }

    
    // *fifth_response_C11* updates
    if (t >= 0 && fifth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C11.tStart = t;  // (not accounting for frame time here)
      fifth_response_C11.frameNStart = frameN;  // exact frame index
      
      fifth_response_C11.setAutoDraw(true);
    }

    
    // *fifth_response_C12* updates
    if (t >= 0 && fifth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C12.tStart = t;  // (not accounting for frame time here)
      fifth_response_C12.frameNStart = frameN;  // exact frame index
      
      fifth_response_C12.setAutoDraw(true);
    }

    
    // *fifth_response_C13* updates
    if (t >= 0 && fifth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C13.tStart = t;  // (not accounting for frame time here)
      fifth_response_C13.frameNStart = frameN;  // exact frame index
      
      fifth_response_C13.setAutoDraw(true);
    }

    
    // *fifth_response_C14* updates
    if (t >= 0 && fifth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C14.tStart = t;  // (not accounting for frame time here)
      fifth_response_C14.frameNStart = frameN;  // exact frame index
      
      fifth_response_C14.setAutoDraw(true);
    }

    
    // *fifth_response_C15* updates
    if (t >= 0 && fifth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C15.tStart = t;  // (not accounting for frame time here)
      fifth_response_C15.frameNStart = frameN;  // exact frame index
      
      fifth_response_C15.setAutoDraw(true);
    }

    
    // *fifth_response_C16* updates
    if (t >= 0 && fifth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_response_C16.tStart = t;  // (not accounting for frame time here)
      fifth_response_C16.frameNStart = frameN;  // exact frame index
      
      fifth_response_C16.setAutoDraw(true);
    }

    // *fifth_mouse_response* updates
    if (t >= 0.0 && fifth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fifth_mouse_response.tStart = t;  // (not accounting for frame time here)
      fifth_mouse_response.frameNStart = frameN;  // exact frame index
      
      fifth_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = fifth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (fifth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = fifth_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = fifth_mouse_response.getPos();
          fifth_mouse_response.x.push(_mouseXYs[0]);
          fifth_mouse_response.y.push(_mouseXYs[1]);
          fifth_mouse_response.leftButton.push(_mouseButtons[0]);
          fifth_mouse_response.midButton.push(_mouseButtons[1]);
          fifth_mouse_response.rightButton.push(_mouseButtons[2]);
          fifth_mouse_response.time.push(fifth_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [fifth_response_C1, fifth_response_C2, fifth_response_C3, fifth_response_C4, fifth_response_C5, fifth_response_C6, fifth_response_C7, fifth_response_C8, fifth_response_C9, fifth_response_C10, fifth_response_C11, fifth_response_C12, fifth_response_C13, fifth_response_C14, fifth_response_C15, fifth_response_C16]) {
            if (obj.contains(fifth_mouse_response)) {
              gotValidClick = true;
              fifth_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((fifth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(fifth_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_for_Fifth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_for_Fifth_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_for_Fifth_Response'-------
    Wait_for_Fifth_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('fifth_mouse_response.x', fifth_mouse_response.x);
    psychoJS.experiment.addData('fifth_mouse_response.y', fifth_mouse_response.y);
    psychoJS.experiment.addData('fifth_mouse_response.leftButton', fifth_mouse_response.leftButton);
    psychoJS.experiment.addData('fifth_mouse_response.midButton', fifth_mouse_response.midButton);
    psychoJS.experiment.addData('fifth_mouse_response.rightButton', fifth_mouse_response.rightButton);
    psychoJS.experiment.addData('fifth_mouse_response.time', fifth_mouse_response.time);
    psychoJS.experiment.addData('fifth_mouse_response.clicked_name', fifth_mouse_response.clicked_name);
    
    // the Routine "Wait_for_Fifth_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_For_Sixth_ResponseComponents;
function Wait_For_Sixth_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_For_Sixth_Response'-------
    t = 0;
    Wait_For_Sixth_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the sixth_mouse_response
    // current position of the mouse:
    sixth_mouse_response.x = [];
    sixth_mouse_response.y = [];
    sixth_mouse_response.leftButton = [];
    sixth_mouse_response.midButton = [];
    sixth_mouse_response.rightButton = [];
    sixth_mouse_response.time = [];
    sixth_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    sixth_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_For_Sixth_ResponseComponents = [];
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C1);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C2);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C3);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C4);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C5);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C6);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C7);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C8);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C9);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C10);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C11);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C12);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C13);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C14);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C15);
    Wait_For_Sixth_ResponseComponents.push(sixth_response_C16);
    Wait_For_Sixth_ResponseComponents.push(sixth_mouse_response);
    
    Wait_For_Sixth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Sixth_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_For_Sixth_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_For_Sixth_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 5)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *sixth_response_C1* updates
    if (t >= 0 && sixth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C1.tStart = t;  // (not accounting for frame time here)
      sixth_response_C1.frameNStart = frameN;  // exact frame index
      
      sixth_response_C1.setAutoDraw(true);
    }

    
    // *sixth_response_C2* updates
    if (t >= 0 && sixth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C2.tStart = t;  // (not accounting for frame time here)
      sixth_response_C2.frameNStart = frameN;  // exact frame index
      
      sixth_response_C2.setAutoDraw(true);
    }

    
    // *sixth_response_C3* updates
    if (t >= 0 && sixth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C3.tStart = t;  // (not accounting for frame time here)
      sixth_response_C3.frameNStart = frameN;  // exact frame index
      
      sixth_response_C3.setAutoDraw(true);
    }

    
    // *sixth_response_C4* updates
    if (t >= 0 && sixth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C4.tStart = t;  // (not accounting for frame time here)
      sixth_response_C4.frameNStart = frameN;  // exact frame index
      
      sixth_response_C4.setAutoDraw(true);
    }

    
    // *sixth_response_C5* updates
    if (t >= 0 && sixth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C5.tStart = t;  // (not accounting for frame time here)
      sixth_response_C5.frameNStart = frameN;  // exact frame index
      
      sixth_response_C5.setAutoDraw(true);
    }

    
    // *sixth_response_C6* updates
    if (t >= 0 && sixth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C6.tStart = t;  // (not accounting for frame time here)
      sixth_response_C6.frameNStart = frameN;  // exact frame index
      
      sixth_response_C6.setAutoDraw(true);
    }

    
    // *sixth_response_C7* updates
    if (t >= 0 && sixth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C7.tStart = t;  // (not accounting for frame time here)
      sixth_response_C7.frameNStart = frameN;  // exact frame index
      
      sixth_response_C7.setAutoDraw(true);
    }

    
    // *sixth_response_C8* updates
    if (t >= 0 && sixth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C8.tStart = t;  // (not accounting for frame time here)
      sixth_response_C8.frameNStart = frameN;  // exact frame index
      
      sixth_response_C8.setAutoDraw(true);
    }

    
    // *sixth_response_C9* updates
    if (t >= 0 && sixth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C9.tStart = t;  // (not accounting for frame time here)
      sixth_response_C9.frameNStart = frameN;  // exact frame index
      
      sixth_response_C9.setAutoDraw(true);
    }

    
    // *sixth_response_C10* updates
    if (t >= 0 && sixth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C10.tStart = t;  // (not accounting for frame time here)
      sixth_response_C10.frameNStart = frameN;  // exact frame index
      
      sixth_response_C10.setAutoDraw(true);
    }

    
    // *sixth_response_C11* updates
    if (t >= 0 && sixth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C11.tStart = t;  // (not accounting for frame time here)
      sixth_response_C11.frameNStart = frameN;  // exact frame index
      
      sixth_response_C11.setAutoDraw(true);
    }

    
    // *sixth_response_C12* updates
    if (t >= 0 && sixth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C12.tStart = t;  // (not accounting for frame time here)
      sixth_response_C12.frameNStart = frameN;  // exact frame index
      
      sixth_response_C12.setAutoDraw(true);
    }

    
    // *sixth_response_C13* updates
    if (t >= 0 && sixth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C13.tStart = t;  // (not accounting for frame time here)
      sixth_response_C13.frameNStart = frameN;  // exact frame index
      
      sixth_response_C13.setAutoDraw(true);
    }

    
    // *sixth_response_C14* updates
    if (t >= 0 && sixth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C14.tStart = t;  // (not accounting for frame time here)
      sixth_response_C14.frameNStart = frameN;  // exact frame index
      
      sixth_response_C14.setAutoDraw(true);
    }

    
    // *sixth_response_C15* updates
    if (t >= 0 && sixth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C15.tStart = t;  // (not accounting for frame time here)
      sixth_response_C15.frameNStart = frameN;  // exact frame index
      
      sixth_response_C15.setAutoDraw(true);
    }

    
    // *sixth_response_C16* updates
    if (t >= 0 && sixth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_response_C16.tStart = t;  // (not accounting for frame time here)
      sixth_response_C16.frameNStart = frameN;  // exact frame index
      
      sixth_response_C16.setAutoDraw(true);
    }

    // *sixth_mouse_response* updates
    if (t >= 0.0 && sixth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sixth_mouse_response.tStart = t;  // (not accounting for frame time here)
      sixth_mouse_response.frameNStart = frameN;  // exact frame index
      
      sixth_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = sixth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (sixth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = sixth_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = sixth_mouse_response.getPos();
          sixth_mouse_response.x.push(_mouseXYs[0]);
          sixth_mouse_response.y.push(_mouseXYs[1]);
          sixth_mouse_response.leftButton.push(_mouseButtons[0]);
          sixth_mouse_response.midButton.push(_mouseButtons[1]);
          sixth_mouse_response.rightButton.push(_mouseButtons[2]);
          sixth_mouse_response.time.push(sixth_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [sixth_response_C1, sixth_response_C2, sixth_response_C3, sixth_response_C4, sixth_response_C5, sixth_response_C6, sixth_response_C7, sixth_response_C8, sixth_response_C9, sixth_response_C10, sixth_response_C11, sixth_response_C12, sixth_response_C13, sixth_response_C14, sixth_response_C15, sixth_response_C16]) {
            if (obj.contains(sixth_mouse_response)) {
              gotValidClick = true;
              sixth_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((sixth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(sixth_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_For_Sixth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Sixth_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_For_Sixth_Response'-------
    Wait_For_Sixth_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('sixth_mouse_response.x', sixth_mouse_response.x);
    psychoJS.experiment.addData('sixth_mouse_response.y', sixth_mouse_response.y);
    psychoJS.experiment.addData('sixth_mouse_response.leftButton', sixth_mouse_response.leftButton);
    psychoJS.experiment.addData('sixth_mouse_response.midButton', sixth_mouse_response.midButton);
    psychoJS.experiment.addData('sixth_mouse_response.rightButton', sixth_mouse_response.rightButton);
    psychoJS.experiment.addData('sixth_mouse_response.time', sixth_mouse_response.time);
    psychoJS.experiment.addData('sixth_mouse_response.clicked_name', sixth_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_For_Sixth_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_For_Seventh_ResponseComponents;
function Wait_For_Seventh_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_For_Seventh_Response'-------
    t = 0;
    Wait_For_Seventh_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the seventh_mouse_response
    // current position of the mouse:
    seventh_mouse_response.x = [];
    seventh_mouse_response.y = [];
    seventh_mouse_response.leftButton = [];
    seventh_mouse_response.midButton = [];
    seventh_mouse_response.rightButton = [];
    seventh_mouse_response.time = [];
    seventh_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    seventh_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_For_Seventh_ResponseComponents = [];
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C1);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C2);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C3);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C4);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C5);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C6);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C7);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C8);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C9);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C10);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C11);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C12);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C13);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C14);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C15);
    Wait_For_Seventh_ResponseComponents.push(seventh_response_C16);
    Wait_For_Seventh_ResponseComponents.push(seventh_mouse_response);
    
    Wait_For_Seventh_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Seventh_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_For_Seventh_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_For_Seventh_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 6)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *seventh_response_C1* updates
    if (t >= 0 && seventh_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C1.tStart = t;  // (not accounting for frame time here)
      seventh_response_C1.frameNStart = frameN;  // exact frame index
      
      seventh_response_C1.setAutoDraw(true);
    }

    
    // *seventh_response_C2* updates
    if (t >= 0 && seventh_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C2.tStart = t;  // (not accounting for frame time here)
      seventh_response_C2.frameNStart = frameN;  // exact frame index
      
      seventh_response_C2.setAutoDraw(true);
    }

    
    // *seventh_response_C3* updates
    if (t >= 0 && seventh_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C3.tStart = t;  // (not accounting for frame time here)
      seventh_response_C3.frameNStart = frameN;  // exact frame index
      
      seventh_response_C3.setAutoDraw(true);
    }

    
    // *seventh_response_C4* updates
    if (t >= 0 && seventh_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C4.tStart = t;  // (not accounting for frame time here)
      seventh_response_C4.frameNStart = frameN;  // exact frame index
      
      seventh_response_C4.setAutoDraw(true);
    }

    
    // *seventh_response_C5* updates
    if (t >= 0 && seventh_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C5.tStart = t;  // (not accounting for frame time here)
      seventh_response_C5.frameNStart = frameN;  // exact frame index
      
      seventh_response_C5.setAutoDraw(true);
    }

    
    // *seventh_response_C6* updates
    if (t >= 0 && seventh_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C6.tStart = t;  // (not accounting for frame time here)
      seventh_response_C6.frameNStart = frameN;  // exact frame index
      
      seventh_response_C6.setAutoDraw(true);
    }

    
    // *seventh_response_C7* updates
    if (t >= 0 && seventh_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C7.tStart = t;  // (not accounting for frame time here)
      seventh_response_C7.frameNStart = frameN;  // exact frame index
      
      seventh_response_C7.setAutoDraw(true);
    }

    
    // *seventh_response_C8* updates
    if (t >= 0 && seventh_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C8.tStart = t;  // (not accounting for frame time here)
      seventh_response_C8.frameNStart = frameN;  // exact frame index
      
      seventh_response_C8.setAutoDraw(true);
    }

    
    // *seventh_response_C9* updates
    if (t >= 0 && seventh_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C9.tStart = t;  // (not accounting for frame time here)
      seventh_response_C9.frameNStart = frameN;  // exact frame index
      
      seventh_response_C9.setAutoDraw(true);
    }

    
    // *seventh_response_C10* updates
    if (t >= 0 && seventh_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C10.tStart = t;  // (not accounting for frame time here)
      seventh_response_C10.frameNStart = frameN;  // exact frame index
      
      seventh_response_C10.setAutoDraw(true);
    }

    
    // *seventh_response_C11* updates
    if (t >= 0 && seventh_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C11.tStart = t;  // (not accounting for frame time here)
      seventh_response_C11.frameNStart = frameN;  // exact frame index
      
      seventh_response_C11.setAutoDraw(true);
    }

    
    // *seventh_response_C12* updates
    if (t >= 0 && seventh_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C12.tStart = t;  // (not accounting for frame time here)
      seventh_response_C12.frameNStart = frameN;  // exact frame index
      
      seventh_response_C12.setAutoDraw(true);
    }

    
    // *seventh_response_C13* updates
    if (t >= 0 && seventh_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C13.tStart = t;  // (not accounting for frame time here)
      seventh_response_C13.frameNStart = frameN;  // exact frame index
      
      seventh_response_C13.setAutoDraw(true);
    }

    
    // *seventh_response_C14* updates
    if (t >= 0 && seventh_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C14.tStart = t;  // (not accounting for frame time here)
      seventh_response_C14.frameNStart = frameN;  // exact frame index
      
      seventh_response_C14.setAutoDraw(true);
    }

    
    // *seventh_response_C15* updates
    if (t >= 0 && seventh_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C15.tStart = t;  // (not accounting for frame time here)
      seventh_response_C15.frameNStart = frameN;  // exact frame index
      
      seventh_response_C15.setAutoDraw(true);
    }

    
    // *seventh_response_C16* updates
    if (t >= 0 && seventh_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_response_C16.tStart = t;  // (not accounting for frame time here)
      seventh_response_C16.frameNStart = frameN;  // exact frame index
      
      seventh_response_C16.setAutoDraw(true);
    }

    // *seventh_mouse_response* updates
    if (t >= 0.0 && seventh_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      seventh_mouse_response.tStart = t;  // (not accounting for frame time here)
      seventh_mouse_response.frameNStart = frameN;  // exact frame index
      
      seventh_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = seventh_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (seventh_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = seventh_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = seventh_mouse_response.getPos();
          seventh_mouse_response.x.push(_mouseXYs[0]);
          seventh_mouse_response.y.push(_mouseXYs[1]);
          seventh_mouse_response.leftButton.push(_mouseButtons[0]);
          seventh_mouse_response.midButton.push(_mouseButtons[1]);
          seventh_mouse_response.rightButton.push(_mouseButtons[2]);
          seventh_mouse_response.time.push(seventh_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [seventh_response_C1, seventh_response_C2, seventh_response_C3, seventh_response_C4, seventh_response_C5, seventh_response_C6, seventh_response_C7, seventh_response_C8, seventh_response_C9, seventh_response_C10, seventh_response_C11, seventh_response_C12, seventh_response_C13, seventh_response_C14, seventh_response_C15, seventh_response_C16]) {
            if (obj.contains(seventh_mouse_response)) {
              gotValidClick = true;
              seventh_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((seventh_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(seventh_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_For_Seventh_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Seventh_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_For_Seventh_Response'-------
    Wait_For_Seventh_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('seventh_mouse_response.x', seventh_mouse_response.x);
    psychoJS.experiment.addData('seventh_mouse_response.y', seventh_mouse_response.y);
    psychoJS.experiment.addData('seventh_mouse_response.leftButton', seventh_mouse_response.leftButton);
    psychoJS.experiment.addData('seventh_mouse_response.midButton', seventh_mouse_response.midButton);
    psychoJS.experiment.addData('seventh_mouse_response.rightButton', seventh_mouse_response.rightButton);
    psychoJS.experiment.addData('seventh_mouse_response.time', seventh_mouse_response.time);
    psychoJS.experiment.addData('seventh_mouse_response.clicked_name', seventh_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_For_Seventh_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Wait_For_Eighth_ResponseComponents;
function Wait_For_Eighth_ResponseRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Wait_For_Eighth_Response'-------
    t = 0;
    Wait_For_Eighth_ResponseClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // setup some python lists for storing info about the eighth_mouse_response
    // current position of the mouse:
    eighth_mouse_response.x = [];
    eighth_mouse_response.y = [];
    eighth_mouse_response.leftButton = [];
    eighth_mouse_response.midButton = [];
    eighth_mouse_response.rightButton = [];
    eighth_mouse_response.time = [];
    eighth_mouse_response.clicked_name = [];
    gotValidClick = false; // until a click is received
    eighth_mouse_response.mouseClock.reset();
    clicked_frame = null;
    
    // keep track of which components have finished
    Wait_For_Eighth_ResponseComponents = [];
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C1);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C2);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C3);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C4);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C5);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C6);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C7);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C8);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C9);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C10);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C11);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C12);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C13);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C14);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C15);
    Wait_For_Eighth_ResponseComponents.push(eighth_response_C16);
    Wait_For_Eighth_ResponseComponents.push(eighth_mouse_response);
    
    Wait_For_Eighth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Eighth_ResponseRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Wait_For_Eighth_Response'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Wait_For_Eighth_ResponseClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop > 7)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    
    // *eighth_response_C1* updates
    if (t >= 0 && eighth_response_C1.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C1.tStart = t;  // (not accounting for frame time here)
      eighth_response_C1.frameNStart = frameN;  // exact frame index
      
      eighth_response_C1.setAutoDraw(true);
    }

    
    // *eighth_response_C2* updates
    if (t >= 0 && eighth_response_C2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C2.tStart = t;  // (not accounting for frame time here)
      eighth_response_C2.frameNStart = frameN;  // exact frame index
      
      eighth_response_C2.setAutoDraw(true);
    }

    
    // *eighth_response_C3* updates
    if (t >= 0 && eighth_response_C3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C3.tStart = t;  // (not accounting for frame time here)
      eighth_response_C3.frameNStart = frameN;  // exact frame index
      
      eighth_response_C3.setAutoDraw(true);
    }

    
    // *eighth_response_C4* updates
    if (t >= 0 && eighth_response_C4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C4.tStart = t;  // (not accounting for frame time here)
      eighth_response_C4.frameNStart = frameN;  // exact frame index
      
      eighth_response_C4.setAutoDraw(true);
    }

    
    // *eighth_response_C5* updates
    if (t >= 0 && eighth_response_C5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C5.tStart = t;  // (not accounting for frame time here)
      eighth_response_C5.frameNStart = frameN;  // exact frame index
      
      eighth_response_C5.setAutoDraw(true);
    }

    
    // *eighth_response_C6* updates
    if (t >= 0 && eighth_response_C6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C6.tStart = t;  // (not accounting for frame time here)
      eighth_response_C6.frameNStart = frameN;  // exact frame index
      
      eighth_response_C6.setAutoDraw(true);
    }

    
    // *eighth_response_C7* updates
    if (t >= 0 && eighth_response_C7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C7.tStart = t;  // (not accounting for frame time here)
      eighth_response_C7.frameNStart = frameN;  // exact frame index
      
      eighth_response_C7.setAutoDraw(true);
    }

    
    // *eighth_response_C8* updates
    if (t >= 0 && eighth_response_C8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C8.tStart = t;  // (not accounting for frame time here)
      eighth_response_C8.frameNStart = frameN;  // exact frame index
      
      eighth_response_C8.setAutoDraw(true);
    }

    
    // *eighth_response_C9* updates
    if (t >= 0 && eighth_response_C9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C9.tStart = t;  // (not accounting for frame time here)
      eighth_response_C9.frameNStart = frameN;  // exact frame index
      
      eighth_response_C9.setAutoDraw(true);
    }

    
    // *eighth_response_C10* updates
    if (t >= 0 && eighth_response_C10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C10.tStart = t;  // (not accounting for frame time here)
      eighth_response_C10.frameNStart = frameN;  // exact frame index
      
      eighth_response_C10.setAutoDraw(true);
    }

    
    // *eighth_response_C11* updates
    if (t >= 0 && eighth_response_C11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C11.tStart = t;  // (not accounting for frame time here)
      eighth_response_C11.frameNStart = frameN;  // exact frame index
      
      eighth_response_C11.setAutoDraw(true);
    }

    
    // *eighth_response_C12* updates
    if (t >= 0 && eighth_response_C12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C12.tStart = t;  // (not accounting for frame time here)
      eighth_response_C12.frameNStart = frameN;  // exact frame index
      
      eighth_response_C12.setAutoDraw(true);
    }

    
    // *eighth_response_C13* updates
    if (t >= 0 && eighth_response_C13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C13.tStart = t;  // (not accounting for frame time here)
      eighth_response_C13.frameNStart = frameN;  // exact frame index
      
      eighth_response_C13.setAutoDraw(true);
    }

    
    // *eighth_response_C14* updates
    if (t >= 0 && eighth_response_C14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C14.tStart = t;  // (not accounting for frame time here)
      eighth_response_C14.frameNStart = frameN;  // exact frame index
      
      eighth_response_C14.setAutoDraw(true);
    }

    
    // *eighth_response_C15* updates
    if (t >= 0 && eighth_response_C15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C15.tStart = t;  // (not accounting for frame time here)
      eighth_response_C15.frameNStart = frameN;  // exact frame index
      
      eighth_response_C15.setAutoDraw(true);
    }

    
    // *eighth_response_C16* updates
    if (t >= 0 && eighth_response_C16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_response_C16.tStart = t;  // (not accounting for frame time here)
      eighth_response_C16.frameNStart = frameN;  // exact frame index
      
      eighth_response_C16.setAutoDraw(true);
    }

    // *eighth_mouse_response* updates
    if (t >= 0.0 && eighth_mouse_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      eighth_mouse_response.tStart = t;  // (not accounting for frame time here)
      eighth_mouse_response.frameNStart = frameN;  // exact frame index
      
      eighth_mouse_response.status = PsychoJS.Status.STARTED;
      prevButtonState = eighth_mouse_response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (eighth_mouse_response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = eighth_mouse_response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          _mouseXYs = eighth_mouse_response.getPos();
          eighth_mouse_response.x.push(_mouseXYs[0]);
          eighth_mouse_response.y.push(_mouseXYs[1]);
          eighth_mouse_response.leftButton.push(_mouseButtons[0]);
          eighth_mouse_response.midButton.push(_mouseButtons[1]);
          eighth_mouse_response.rightButton.push(_mouseButtons[2]);
          eighth_mouse_response.time.push(eighth_mouse_response.mouseClock.getTime());
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [eighth_response_C1, eighth_response_C2, eighth_response_C3, eighth_response_C4, eighth_response_C5, eighth_response_C6, eighth_response_C7, eighth_response_C8, eighth_response_C9, eighth_response_C10, eighth_response_C11, eighth_response_C12, eighth_response_C13, eighth_response_C14, eighth_response_C15, eighth_response_C16]) {
            if (obj.contains(eighth_mouse_response)) {
              gotValidClick = true;
              eighth_mouse_response.clicked_name.push(obj.name)
            }
          }
        }
      }
    }
    if (((eighth_mouse_response.clicked_name.length > 0) && (clicked_frame === null))) {
        clicked_frame = frameN;
        clicked_circle = eval(eighth_mouse_response.clicked_name[0]);
        clicked_circle.setFillColor(new util.Color([1, 1, 1]));
    }
    if (((clicked_frame !== null) && (frameN > (clicked_frame + 20)))) {
        clicked_circle.setFillColor(new util.Color([(- 1.0), (- 1.0), (- 1.0)]));
        continueRoutine = false;
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Wait_For_Eighth_ResponseComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Wait_For_Eighth_ResponseRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Wait_For_Eighth_Response'-------
    Wait_For_Eighth_ResponseComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('eighth_mouse_response.x', eighth_mouse_response.x);
    psychoJS.experiment.addData('eighth_mouse_response.y', eighth_mouse_response.y);
    psychoJS.experiment.addData('eighth_mouse_response.leftButton', eighth_mouse_response.leftButton);
    psychoJS.experiment.addData('eighth_mouse_response.midButton', eighth_mouse_response.midButton);
    psychoJS.experiment.addData('eighth_mouse_response.rightButton', eighth_mouse_response.rightButton);
    psychoJS.experiment.addData('eighth_mouse_response.time', eighth_mouse_response.time);
    psychoJS.experiment.addData('eighth_mouse_response.clicked_name', eighth_mouse_response.clicked_name);
    
    /* Syntax Error: Fix Python code */
    // the Routine "Wait_For_Eighth_Response" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Check_outcomeComponents;
function Check_outcomeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Check_outcome'-------
    t = 0;
    Check_outcomeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    corr = 0;
    trial_counter = (trial_counter + 1);
    if ((circle_loop === 3)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    trials_correct = (trials_correct + 1);
                }
            }
        }
    }
    if ((circle_loop === 4)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                        trials_correct = (trials_correct + 1);
                    }
                }
            }
        }
    }
    if ((circle_loop === 5)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                        if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                            trials_correct = (trials_correct + 1);
                        }
                    }
                }
            }
        }
    }
    if ((circle_loop === 6)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                        if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                            if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                trials_correct = (trials_correct + 1);
                            }
                        }
                    }
                }
            }
        }
    }
    if ((circle_loop === 7)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                        if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                            if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                if ((seventh_mouse_response.clicked_name[0] === Correct_response_circle7)) {
                                    trials_correct = (trials_correct + 1);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if ((circle_loop === 8)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    if ((fourth_mouse_response.clicked_name[0] === Correct_response_circle4)) {
                        if ((fifth_mouse_response.clicked_name[0] === Correct_response_circle5)) {
                            if ((sixth_mouse_response.clicked_name[0] === Correct_response_circle6)) {
                                if ((seventh_mouse_response.clicked_name[0] === Correct_response_circle7)) {
                                    if ((eighth_mouse_response.clicked_name[0] === Correct_response_circle8)) {
                                        trials_correct = (trials_correct + 1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if ((circle_loop > 2)) {
        if (((trial_counter === 2) && (trials_correct === 2))) {
            Circle_Blocks.finished = true;
        }
        if (((trial_counter === 2) && (trials_correct === 0))) {
            end_experiment = 1;
            Circle_Blocks.finished = true;
        }
        if (((trial_counter === 3) && (trials_correct === 1))) {
            end_experiment = 1;
            Circle_Blocks.finished = true;
        }
        if (((trial_counter === 3) && (trials_correct > 1))) {
            Circle_Blocks.finished = true;
        }
    }
    
    console.log(trials_correct)
    console.log(trial_counter)
    
    
    // keep track of which components have finished
    Check_outcomeComponents = [];
    
    Check_outcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Check_outcomeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Check_outcome'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Check_outcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if ((circle_loop < 3)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    corr = 1;
                }
            }
        }
    } else {
        corr = 0;
        }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Check_outcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Check_outcomeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Check_outcome'-------
    Check_outcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    console.log(corr)
    console.log(circle_loop)
    if ((corr === 1)) {
        msg = "Correct!";
    } else {
        msg = "Incorrect";
        }
    
    console.log(msg)
    
    if ((circle_loop < 3)) {
        if ((first_mouse_response.clicked_name[0] === Correct_response_circle1)) {
            if ((second_mouse_response.clicked_name[0] === Correct_response_circle2)) {
                if ((third_mouse_response.clicked_name[0] === Correct_response_circle3)) {
                    trials_correct = (trials_correct + 1);
                }
            }
        }
    }
    
    console.log(trials_correct)
    
    if ((circle_loop === 2)) {
        if ((trial_counter === 2) && (trials_correct === 2)) {
            Circle_Blocks.finished = true;
        }
        if ((trial_counter === 4)) {
            Circle_Blocks.finished = true;
        }
    }
    
    // the Routine "Check_outcome" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Blank_ScreenComponents;
function Blank_ScreenRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Blank_Screen'-------
    t = 0;
    Blank_ScreenClock.reset(); // clock
    frameN = -1;
    routineTimer.add(0.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Blank_ScreenComponents = [];
    Blank_ScreenComponents.push(text);
    
    Blank_ScreenComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Blank_ScreenRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Blank_Screen'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Blank_ScreenClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text* updates
    if (t >= 0.0 && text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text.tStart = t;  // (not accounting for frame time here)
      text.frameNStart = frameN;  // exact frame index
      
      text.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text.status === PsychoJS.Status.STARTED || text.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Blank_ScreenComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Blank_ScreenRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Blank_Screen'-------
    Blank_ScreenComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var feedbackComponents;
function feedbackRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback'-------
    t = 0;
    feedbackClock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    text_4.setText(msg);
    // keep track of which components have finished
    feedbackComponents = [];
    feedbackComponents.push(text_4);
    
    feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedbackRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_4* updates
    if (t >= 0.0 && text_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_4.tStart = t;  // (not accounting for frame time here)
      text_4.frameNStart = frameN;  // exact frame index
      
      text_4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_4.status === PsychoJS.Status.STARTED || text_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_4.setAutoDraw(false);
    }
    if ((circle_loop < 3)) {
        continueRoutine = true;
    } else {
        continueRoutine = false;
    }
    
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedbackRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback'-------
    feedbackComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_allKeys;
var Repeat_InstructionsComponents;
function Repeat_InstructionsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Repeat_Instructions'-------
    t = 0;
    Repeat_InstructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp.keys = undefined;
    key_resp.rt = undefined;
    _key_resp_allKeys = [];
    // keep track of which components have finished
    Repeat_InstructionsComponents = [];
    Repeat_InstructionsComponents.push(repeat_inst);
    Repeat_InstructionsComponents.push(key_resp);
    Repeat_InstructionsComponents.push(text_5);
    
    Repeat_InstructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Repeat_InstructionsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Repeat_Instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Repeat_InstructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *repeat_inst* updates
    if (t >= 0.0 && repeat_inst.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      repeat_inst.tStart = t;  // (not accounting for frame time here)
      repeat_inst.frameNStart = frameN;  // exact frame index
      
      repeat_inst.setAutoDraw(true);
    }

    console.log(trials_correct)
    console.log(trial_counter)
    if ((circle_loop < 3)) {
        if ((trial_counter < 2)) {
            continueRoutine = false;
        } else if ((trial_counter === 2)) {
            if (trials_correct ===2){
                continueRoutine = false;
                practice_correct = 1;
                }
            else {
                continueRoutine = true;
                }
        } else if ((trial_counter === 3)) {
            continueRoutine = false;
        } else if ((trial_counter === 4) && (trials_correct > 2)) {
            continueRoutine = false;
        } else {
            continueRoutine = false;
            } 
    }else {
        continueRoutine = false;
    }
    
    if ((circle_loop < 3)) {
        if ((practice_correct === 1)) {
            continueRoutine = false;
        }
    }
    
    console.log(practice_correct);
    
    // *key_resp* updates
    if (t >= 0.0 && key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp.tStart = t;  // (not accounting for frame time here)
      key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp.clearEvents(); });
    }

    if (key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_allKeys = _key_resp_allKeys.concat(theseKeys);
      if (_key_resp_allKeys.length > 0) {
        key_resp.keys = _key_resp_allKeys[_key_resp_allKeys.length - 1].name;  // just the last key pressed
        key_resp.rt = _key_resp_allKeys[_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_5* updates
    if (t >= 0.0 && text_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_5.tStart = t;  // (not accounting for frame time here)
      text_5.frameNStart = frameN;  // exact frame index
      
      text_5.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Repeat_InstructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Repeat_InstructionsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Repeat_Instructions'-------
    Repeat_InstructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp.keys', key_resp.keys);
    if (typeof key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp.rt', key_resp.rt);
        routineTimer.reset();
        }
    
    key_resp.stop();
    // the Routine "Repeat_Instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var check_end_experimentComponents;
function check_end_experimentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'check_end_experiment'-------
    t = 0;
    check_end_experimentClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    if ((end_experiment === 1)) {
        Meta_Loop.finished = true;
    }
    
    // keep track of which components have finished
    check_end_experimentComponents = [];
    
    check_end_experimentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function check_end_experimentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'check_end_experiment'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = check_end_experimentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    check_end_experimentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function check_end_experimentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'check_end_experiment'-------
    check_end_experimentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "check_end_experiment" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Get_ExperimenterComponents;
function Get_ExperimenterRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Get_Experimenter'-------
    t = 0;
    Get_ExperimenterClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.000000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Get_ExperimenterComponents = [];
    Get_ExperimenterComponents.push(text_11);
    Get_ExperimenterComponents.push(b_text_15);
    
    Get_ExperimenterComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Get_ExperimenterRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Get_Experimenter'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Get_ExperimenterClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_11* updates
    if (t >= 0.0 && text_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_11.tStart = t;  // (not accounting for frame time here)
      text_11.frameNStart = frameN;  // exact frame index
      
      text_11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_11.status === PsychoJS.Status.STARTED || text_11.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_11.setAutoDraw(false);
    }
    
    // *b_text_15* updates
    if (t >= 0.0 && b_text_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      b_text_15.tStart = t;  // (not accounting for frame time here)
      b_text_15.frameNStart = frameN;  // exact frame index
      
      b_text_15.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((b_text_15.status === PsychoJS.Status.STARTED || b_text_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      b_text_15.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Get_ExperimenterComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Get_ExperimenterRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Get_Experimenter'-------
    Get_ExperimenterComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_2_allKeys;
var InstructionsComponents;
function InstructionsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Instructions'-------
    t = 0;
    InstructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_2.keys = undefined;
    key_resp_2.rt = undefined;
    _key_resp_2_allKeys = [];
    // keep track of which components have finished
    InstructionsComponents = [];
    InstructionsComponents.push(instructions);
    InstructionsComponents.push(key_resp_2);
    
    InstructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function InstructionsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = InstructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *instructions* updates
    if (t >= 0.0 && instructions.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      instructions.tStart = t;  // (not accounting for frame time here)
      instructions.frameNStart = frameN;  // exact frame index
      
      instructions.setAutoDraw(true);
    }

    
    // *key_resp_2* updates
    if (t >= 0.0 && key_resp_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_2.tStart = t;  // (not accounting for frame time here)
      key_resp_2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_2.clearEvents(); });
    }

    if (key_resp_2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_2.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_2_allKeys = _key_resp_2_allKeys.concat(theseKeys);
      if (_key_resp_2_allKeys.length > 0) {
        key_resp_2.keys = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].name;  // just the last key pressed
        key_resp_2.rt = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    InstructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function InstructionsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Instructions'-------
    InstructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_2.keys', key_resp_2.keys);
    if (typeof key_resp_2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_2.rt', key_resp_2.rt);
        routineTimer.reset();
        }
    
    key_resp_2.stop();
    // the Routine "Instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_3_allKeys;
var get_readyComponents;
function get_readyRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'get_ready'-------
    t = 0;
    get_readyClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_3.keys = undefined;
    key_resp_3.rt = undefined;
    _key_resp_3_allKeys = [];
    // keep track of which components have finished
    get_readyComponents = [];
    get_readyComponents.push(text_6);
    get_readyComponents.push(key_resp_3);
    get_readyComponents.push(text_7);
    
    get_readyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function get_readyRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'get_ready'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = get_readyClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_6* updates
    if (t >= 0.0 && text_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_6.tStart = t;  // (not accounting for frame time here)
      text_6.frameNStart = frameN;  // exact frame index
      
      text_6.setAutoDraw(true);
    }

    
    // *key_resp_3* updates
    if (t >= 0.0 && key_resp_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_3.tStart = t;  // (not accounting for frame time here)
      key_resp_3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_3.clearEvents(); });
    }

    if (key_resp_3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_3.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_3_allKeys = _key_resp_3_allKeys.concat(theseKeys);
      if (_key_resp_3_allKeys.length > 0) {
        key_resp_3.keys = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].name;  // just the last key pressed
        key_resp_3.rt = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_7* updates
    if (t >= 0.0 && text_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_7.tStart = t;  // (not accounting for frame time here)
      text_7.frameNStart = frameN;  // exact frame index
      
      text_7.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    get_readyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function get_readyRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'get_ready'-------
    get_readyComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_3.keys', key_resp_3.keys);
    if (typeof key_resp_3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_3.rt', key_resp_3.rt);
        routineTimer.reset();
        }
    
    key_resp_3.stop();
    // the Routine "get_ready" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var code_metaComponents;
function code_metaRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'code_meta'-------
    t = 0;
    code_metaClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // keep track of which components have finished
    code_metaComponents = [];
    
    code_metaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function code_metaRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'code_meta'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = code_metaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    code_metaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function code_metaRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'code_meta'-------
    code_metaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "code_meta" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var nList;
var Presentation_practiceComponents;
function Presentation_practiceRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Presentation_practice'-------
    t = 0;
    Presentation_practiceClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // Convert sequence to list
    var output = [],
        sNumber = digits.toString();
    
    for (var i = 0, len = sNumber.length; i < len; i += 1) {
        output.push(+sNumber.charAt(i));
    }
    
    nList = digits.toString().split('').map((i)=>Number(i))
    // keep track of which components have finished
    Presentation_practiceComponents = [];
    Presentation_practiceComponents.push(fixation_2);
    Presentation_practiceComponents.push(pres_text_2);
    
    Presentation_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


var i;
function Presentation_practiceRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Presentation_practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Presentation_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_2* updates
    if (t >= 0.0 && fixation_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_2.tStart = t;  // (not accounting for frame time here)
      fixation_2.frameNStart = frameN;  // exact frame index
      
      fixation_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fixation_2.status === PsychoJS.Status.STARTED || fixation_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fixation_2.setAutoDraw(false);
    }
    
    // *pres_text_2* updates
    if (t >= 1 && pres_text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pres_text_2.tStart = t;  // (not accounting for frame time here)
      pres_text_2.frameNStart = frameN;  // exact frame index
      
      pres_text_2.setAutoDraw(true);
    }

    // Convert time ti a list index
    i = Math.floor(t-1);
    // console.log(i)
    // console.log(nList.length)
    // console.log(fixation_2)
    // console.log(pres_text_2.text)
    // pres_text_2.text = 'a'
    // console.log(pres_text_2.text)
    
    // Index current number in the list
    // or end routine if all numbers presented
    if (i === nList.length) {
        continueRoutine = false;
    } else if (i < 0){
        pres_text_2.text = ' '
    } else {
        console.log(pres_text_2.text)
        pres_text_2.text = nList[i]
    }
    
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Presentation_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Presentation_practiceRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Presentation_practice'-------
    Presentation_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "Presentation_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_4_allKeys;
var n;
var modify;
var textAdd;
var Recall_practiceComponents;
function Recall_practiceRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Recall_practice'-------
    t = 0;
    Recall_practiceClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_4.keys = undefined;
    key_resp_4.rt = undefined;
    _key_resp_4_allKeys = [];
    n = 0;
    modify = false;
    textAdd = '';
    pts_response_2.text = '';
    current_resp = '';
    console.log(pts_response_2.text)
    console.log(current_resp)
    if (pts_response_2.text === 'space'){
        pts_response_2.text = '';
        }
    // keep track of which components have finished
    Recall_practiceComponents = [];
    Recall_practiceComponents.push(recall_text_2);
    Recall_practiceComponents.push(key_resp_4);
    Recall_practiceComponents.push(pts_response_2);
    
    Recall_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Recall_practiceRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Recall_practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Recall_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *recall_text_2* updates
    if (t >= 0 && recall_text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      recall_text_2.tStart = t;  // (not accounting for frame time here)
      recall_text_2.frameNStart = frameN;  // exact frame index
      
      recall_text_2.setAutoDraw(true);
    }

    
    // *key_resp_4* updates
    if (t >= 0 && key_resp_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_4.tStart = t;  // (not accounting for frame time here)
      key_resp_4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.clearEvents(); });
    }

    if (key_resp_4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_4.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return', 'backspace'], waitRelease: false});
      _key_resp_4_allKeys = _key_resp_4_allKeys.concat(theseKeys);
      if (_key_resp_4_allKeys.length > 0) {
        key_resp_4.keys = _key_resp_4_allKeys.map((key) => key.name);  // storing all keys
        key_resp_4.rt = _key_resp_4_allKeys.map((key) => key.rt);
      }
    }
    
    console.log(current_resp)
    console.log(pts_response_2.text)
    console.log(n)
    
    
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
     }
    
    if (n < 1){
        textAdd = ''
    }
    
    
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        pts_response_2.text = pts_response_2.text.slice(0, -1);
        textAdd = undefined;
    } else if (['lshift', 'rshift'].includes(textAdd)) {
            modify = true;
    } else if (textAdd !== undefined) {
        if (modify) {
            pts_response_2.text = pts_response_2.text + textAdd.toUpperCase();
            modify = false;
        } else {
            pts_response_2.text = pts_response_2.text + textAdd
        }
        textAdd = undefined;
    }
     
    
    current_resp = pts_response_2.text
    n = n + 1
    console.log(n)
    
    // *pts_response_2* updates
    if (t >= 0 && pts_response_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pts_response_2.tStart = t;  // (not accounting for frame time here)
      pts_response_2.frameNStart = frameN;  // exact frame index
      
      pts_response_2.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Recall_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var correct;
var msg_color;
function Recall_practiceRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Recall_practice'-------
    Recall_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_4.keys', key_resp_4.keys);
    if (typeof key_resp_4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_4.rt', key_resp_4.rt);
        }
    
    key_resp_4.stop();
    correct = 0;
    
    if (Number(current_resp) === digits_corr) {
        correct = 1;
        msg = "Correct";
        msg_color = 'green';
        psychoJS.experiment.addData("correct", correct)
    } else {
        msg = "Incorrect";
        msg_color = 'red';
        psychoJS.experiment.addData("Incorrect", correct)
    }
    psychoJS.experiment.addData("response", current_resp);
    
    allResponses_p.push(correct)
    pts_response_2.text = '';
    
    console.log(allResponses_p)
    // the Routine "Recall_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var feedback_practiceComponents;
function feedback_practiceRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_practice'-------
    t = 0;
    feedback_practiceClock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    text_8.setColor(new util.Color(msg_color));
    text_8.setText(msg);
    // keep track of which components have finished
    feedback_practiceComponents = [];
    feedback_practiceComponents.push(text_8);
    
    feedback_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_practiceRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_8* updates
    if (t >= 0.0 && text_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_8.tStart = t;  // (not accounting for frame time here)
      text_8.frameNStart = frameN;  // exact frame index
      
      text_8.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_8.status === PsychoJS.Status.STARTED || text_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_8.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_practiceRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_practice'-------
    feedback_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    
    
    
    
    return Scheduler.Event.NEXT;
  };
}


var code_endComponents;
function code_endRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'code_end'-------
    t = 0;
    code_endClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    console.log(allResponses_p)
    
    if (allResponses_p.length === 2 && allResponses_p.slice(-2).reduce((a,b)=>a+b) > 1) {
        trials_2.finished = true;
    } else if (allResponses_p.length === 2 && allResponses_p.slice(-2).reduce((a,b)=>a+b) < 2) {
        //trials.finished = true;
        allResponses_p = [];
        condition_counter = condition_counter + 1 
    }
    
    console.log(allResponses_p)
    // keep track of which components have finished
    code_endComponents = [];
    
    code_endComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function code_endRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'code_end'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = code_endClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    code_endComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function code_endRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'code_end'-------
    code_endComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "code_end" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_6_allKeys;
var repeat_instructionsComponents;
function repeat_instructionsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'repeat_instructions'-------
    t = 0;
    repeat_instructionsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_6.keys = undefined;
    key_resp_6.rt = undefined;
    _key_resp_6_allKeys = [];
    // keep track of which components have finished
    repeat_instructionsComponents = [];
    repeat_instructionsComponents.push(text_9);
    repeat_instructionsComponents.push(key_resp_6);
    repeat_instructionsComponents.push(text_10);
    
    repeat_instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function repeat_instructionsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'repeat_instructions'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = repeat_instructionsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_9* updates
    if (t >= 0.0 && text_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_9.tStart = t;  // (not accounting for frame time here)
      text_9.frameNStart = frameN;  // exact frame index
      
      text_9.setAutoDraw(true);
    }

    console.log(condition_counter);
    console.log(allResponses_p.length);
    
    if (condition_counter === 0) {
        continueRoutine = false;
    } else if (condition_counter > 1){
        continueRoutine = false;
        } else if (condition_counter === 1 && allResponses_p.length < 2){
            continueRoutine = true;
            }else if (condition_counter === 1 && allResponses_p.slice(-2).reduce((a,b)=>a+b) > 1){
                continueRoutine = false;
                } else if (key_resp_6.keys === 'space') {
                    continueRoutine = false;
                    }
    
    
    
    // *key_resp_6* updates
    if (t >= 0.0 && key_resp_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_6.tStart = t;  // (not accounting for frame time here)
      key_resp_6.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_6.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_6.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_6.clearEvents(); });
    }

    if (key_resp_6.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_6.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_6_allKeys = _key_resp_6_allKeys.concat(theseKeys);
      if (_key_resp_6_allKeys.length > 0) {
        key_resp_6.keys = _key_resp_6_allKeys[_key_resp_6_allKeys.length - 1].name;  // just the last key pressed
        key_resp_6.rt = _key_resp_6_allKeys[_key_resp_6_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_10* updates
    if (t >= 0.0 && text_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_10.tStart = t;  // (not accounting for frame time here)
      text_10.frameNStart = frameN;  // exact frame index
      
      text_10.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    repeat_instructionsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function repeat_instructionsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'repeat_instructions'-------
    repeat_instructionsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_6.keys', key_resp_6.keys);
    if (typeof key_resp_6.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_6.rt', key_resp_6.rt);
        routineTimer.reset();
        }
    
    key_resp_6.stop();
    // the Routine "repeat_instructions" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_5_allKeys;
var real_trialsComponents;
function real_trialsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'real_trials'-------
    t = 0;
    real_trialsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_5.keys = undefined;
    key_resp_5.rt = undefined;
    _key_resp_5_allKeys = [];
    // keep track of which components have finished
    real_trialsComponents = [];
    real_trialsComponents.push(get_ready_real_trial);
    real_trialsComponents.push(press_space);
    real_trialsComponents.push(key_resp_5);
    
    real_trialsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function real_trialsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'real_trials'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = real_trialsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *get_ready_real_trial* updates
    if (t >= 0.0 && get_ready_real_trial.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      get_ready_real_trial.tStart = t;  // (not accounting for frame time here)
      get_ready_real_trial.frameNStart = frameN;  // exact frame index
      
      get_ready_real_trial.setAutoDraw(true);
    }

    
    // *press_space* updates
    if (t >= 0.0 && press_space.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      press_space.tStart = t;  // (not accounting for frame time here)
      press_space.frameNStart = frameN;  // exact frame index
      
      press_space.setAutoDraw(true);
    }

    
    // *key_resp_5* updates
    if (t >= 0.0 && key_resp_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_5.tStart = t;  // (not accounting for frame time here)
      key_resp_5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.clearEvents(); });
    }

    if (key_resp_5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_5.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_5_allKeys = _key_resp_5_allKeys.concat(theseKeys);
      if (_key_resp_5_allKeys.length > 0) {
        key_resp_5.keys = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].name;  // just the last key pressed
        key_resp_5.rt = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    real_trialsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function real_trialsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'real_trials'-------
    real_trialsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_5.keys', key_resp_5.keys);
    if (typeof key_resp_5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_5.rt', key_resp_5.rt);
        routineTimer.reset();
        }
    
    key_resp_5.stop();
    // the Routine "real_trials" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var PresentationComponents;
function PresentationRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Presentation'-------
    t = 0;
    PresentationClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // Convert sequence to list
    nList = digits.toString().split('').map((i)=>Number(i))
    // keep track of which components have finished
    PresentationComponents = [];
    PresentationComponents.push(fixation);
    PresentationComponents.push(pres_text);
    
    PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function PresentationRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Presentation'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = PresentationClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation* updates
    if (t >= 0.0 && fixation.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation.tStart = t;  // (not accounting for frame time here)
      fixation.frameNStart = frameN;  // exact frame index
      
      fixation.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fixation.status === PsychoJS.Status.STARTED || fixation.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fixation.setAutoDraw(false);
    }
    
    // *pres_text* updates
    if (t >= 1 && pres_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pres_text.tStart = t;  // (not accounting for frame time here)
      pres_text.frameNStart = frameN;  // exact frame index
      
      pres_text.setAutoDraw(true);
    }

    // Convert time ti a list index
    i = Math.floor(t-1);
    
    // Index current number in the list
    // or end routine if all numbers presented
    
    if (i === nList.length) {
        continueRoutine = false;
    } else if (i < 0){
        pres_text.text = ' '
    } else {
        pres_text.text = nList[i]
    }
    
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    PresentationComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function PresentationRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Presentation'-------
    PresentationComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    pres_text.text = ''
    // the Routine "Presentation" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_7_allKeys;
var nn;
var RecallComponents;
function RecallRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Recall'-------
    t = 0;
    RecallClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_7.keys = undefined;
    key_resp_7.rt = undefined;
    _key_resp_7_allKeys = [];
    nn = 0;
    // keep track of which components have finished
    RecallComponents = [];
    RecallComponents.push(recall_text);
    RecallComponents.push(key_resp_7);
    RecallComponents.push(pts_response);
    
    RecallComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function RecallRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Recall'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = RecallClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *recall_text* updates
    if (t >= 0 && recall_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      recall_text.tStart = t;  // (not accounting for frame time here)
      recall_text.frameNStart = frameN;  // exact frame index
      
      recall_text.setAutoDraw(true);
    }

    
    // *key_resp_7* updates
    if (t >= 0 && key_resp_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_7.tStart = t;  // (not accounting for frame time here)
      key_resp_7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_7.clearEvents(); });
    }

    if (key_resp_7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_7.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return', 'backspace'], waitRelease: false});
      _key_resp_7_allKeys = _key_resp_7_allKeys.concat(theseKeys);
      if (_key_resp_7_allKeys.length > 0) {
        key_resp_7.keys = _key_resp_7_allKeys.map((key) => key.name);  // storing all keys
        key_resp_7.rt = _key_resp_7_allKeys.map((key) => key.rt);
      }
    }
    
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    
    if (nn < 1){
        textAdd = '';
    }
    
    
    
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        pts_response.text = pts_response.text.slice(0, -1);
        textAdd = undefined;
    } else if (['lshift', 'rshift'].includes(textAdd)) {
            modify = true;
    } else if (textAdd !== undefined) {
        if (modify) {
            pts_response.text = pts_response.text + textAdd.toUpperCase();
            modify = false;
        } else {
            pts_response.text = pts_response.text + textAdd
        }
        textAdd = undefined;
    }
     
    nn = nn + 1;
    current_resp = pts_response.text
    
    // *pts_response* updates
    if (t >= 0 && pts_response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pts_response.tStart = t;  // (not accounting for frame time here)
      pts_response.frameNStart = frameN;  // exact frame index
      
      pts_response.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    RecallComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function RecallRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Recall'-------
    RecallComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_7.keys', key_resp_7.keys);
    if (typeof key_resp_7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_7.rt', key_resp_7.rt);
        }
    
    key_resp_7.stop();
    correct = 0;
    
    if (Number(current_resp) === digits_corr) {
        correct = 1;
        msg = "Correct";
        msg_color = 'green';
        psychoJS.experiment.addData("correct", correct)
    } else {
        msg = "Incorrect";
        msg_color = 'red';
        psychoJS.experiment.addData("Incorrect", correct)
    }
    psychoJS.experiment.addData("response", current_resp);
    
    allResponses.push(correct)
    pts_response.text = '';
    // the Routine "Recall" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var FeedbackComponents;
function FeedbackRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Feedback'-------
    t = 0;
    FeedbackClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // keep track of which components have finished
    FeedbackComponents = [];
    
    FeedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function FeedbackRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Feedback'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FeedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FeedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FeedbackRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Feedback'-------
    FeedbackComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // Original logic:
    // for incorrect, check that two responses exist
    // and that their sum of last two responses is zero
    
    
    //Changing logic from original code
    //Now, when allResponses == 2
    //If sum of the 2 responses == 0, end experiment
    //If sum of the 2 responses is > 0 (i.e., 1 or 2), then keep going with the experiment
    
    console.log(allResponses.length);
    if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 2) {
        trials.finished = true;
        allResponses = [];
    } else if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 0) {
        trials.finished = true;
        blocks.finished = true;
    } else if (allResponses.length === 2 && allResponses.slice(-2).reduce((a,b)=>a+b) === 1) {
        trials.finished = false;
    } else if (allResponses.length === 3 && allResponses.slice(-2).reduce((a,b)=>a+b) === 2) {
        trials.finished = true;
        allResponses = [];
    } else if (allResponses.length === 3 && allResponses.slice(-2).reduce((a,b)=>a+b) < 2) {
        trials.finished = true;
        blocks.finished = true;
        }
    
    //var sum = 0;
    //for (var i = 0; i < allResponses.length; i++){
    //  sum += allResponses[i];
    //}
    
    //if (allResponses.length === 2 && sum === 0) {
    //    trials.finished = true;
    //    blocks.finished = true;
    //} else if (allResponses.length === 2 && sum > 0) {
    //    //trials.finished = true;
    //    allResponses = [];
    //}
    
    
    // the Routine "Feedback" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var EndComponents;
function EndRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'End'-------
    t = 0;
    EndClock.reset(); // clock
    frameN = -1;
    routineTimer.add(3.000000);
    // update component parameters for each repeat
    // keep track of which components have finished
    EndComponents = [];
    EndComponents.push(thank_you);
    EndComponents.push(before_closing);
    
    EndComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function EndRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'End'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = EndClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *thank_you* updates
    if (t >= 0.0 && thank_you.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      thank_you.tStart = t;  // (not accounting for frame time here)
      thank_you.frameNStart = frameN;  // exact frame index
      
      thank_you.setAutoDraw(true);
    }

    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((thank_you.status === PsychoJS.Status.STARTED || thank_you.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      thank_you.setAutoDraw(false);
    }
    
    // *before_closing* updates
    if (t >= 0.0 && before_closing.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      before_closing.tStart = t;  // (not accounting for frame time here)
      before_closing.frameNStart = frameN;  // exact frame index
      
      before_closing.setAutoDraw(true);
    }

    frameRemains = 0.0 + 3 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((before_closing.status === PsychoJS.Status.STARTED || before_closing.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      before_closing.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    EndComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function EndRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'End'-------
    EndComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_10_allKeys;
var Welcome_2Components;
function Welcome_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Welcome_2'-------
    t = 0;
    Welcome_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_10.keys = undefined;
    key_resp_10.rt = undefined;
    _key_resp_10_allKeys = [];
    // keep track of which components have finished
    Welcome_2Components = [];
    Welcome_2Components.push(white_background_10);
    Welcome_2Components.push(text_15);
    Welcome_2Components.push(text_17);
    Welcome_2Components.push(key_resp_10);
    
    Welcome_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Welcome_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Welcome_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Welcome_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_10* updates
    if (t >= 0.0 && white_background_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_10.tStart = t;  // (not accounting for frame time here)
      white_background_10.frameNStart = frameN;  // exact frame index
      
      white_background_10.setAutoDraw(true);
    }

    
    // *text_15* updates
    if (t >= 0.0 && text_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_15.tStart = t;  // (not accounting for frame time here)
      text_15.frameNStart = frameN;  // exact frame index
      
      text_15.setAutoDraw(true);
    }

    
    // *text_17* updates
    if (t >= 0.0 && text_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_17.tStart = t;  // (not accounting for frame time here)
      text_17.frameNStart = frameN;  // exact frame index
      
      text_17.setAutoDraw(true);
    }

    
    // *key_resp_10* updates
    if (t >= 0.0 && key_resp_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_10.tStart = t;  // (not accounting for frame time here)
      key_resp_10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.clearEvents(); });
    }

    if (key_resp_10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_10.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_10_allKeys = _key_resp_10_allKeys.concat(theseKeys);
      if (_key_resp_10_allKeys.length > 0) {
        key_resp_10.keys = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].name;  // just the last key pressed
        key_resp_10.rt = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Welcome_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Welcome_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Welcome_2'-------
    Welcome_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_10.keys', key_resp_10.keys);
    if (typeof key_resp_10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_10.rt', key_resp_10.rt);
        routineTimer.reset();
        }
    
    key_resp_10.stop();
    // the Routine "Welcome_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_27_allKeys;
var IntroA_2Components;
function IntroA_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroA_2'-------
    t = 0;
    IntroA_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_27.keys = undefined;
    key_resp_27.rt = undefined;
    _key_resp_27_allKeys = [];
    // keep track of which components have finished
    IntroA_2Components = [];
    IntroA_2Components.push(white_background_25);
    IntroA_2Components.push(image_11);
    IntroA_2Components.push(text_40);
    IntroA_2Components.push(text_46);
    IntroA_2Components.push(key_resp_27);
    
    IntroA_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroA_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroA_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_25* updates
    if (t >= 0.0 && white_background_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_25.tStart = t;  // (not accounting for frame time here)
      white_background_25.frameNStart = frameN;  // exact frame index
      
      white_background_25.setAutoDraw(true);
    }

    
    // *image_11* updates
    if (t >= 0.0 && image_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_11.tStart = t;  // (not accounting for frame time here)
      image_11.frameNStart = frameN;  // exact frame index
      
      image_11.setAutoDraw(true);
    }

    
    // *text_40* updates
    if (t >= 0.0 && text_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_40.tStart = t;  // (not accounting for frame time here)
      text_40.frameNStart = frameN;  // exact frame index
      
      text_40.setAutoDraw(true);
    }

    
    // *text_46* updates
    if (t >= 0.0 && text_46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_46.tStart = t;  // (not accounting for frame time here)
      text_46.frameNStart = frameN;  // exact frame index
      
      text_46.setAutoDraw(true);
    }

    
    // *key_resp_27* updates
    if (t >= 0.0 && key_resp_27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_27.tStart = t;  // (not accounting for frame time here)
      key_resp_27.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      key_resp_27.clock.reset();
      key_resp_27.start();
    }

    if (key_resp_27.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_27.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_27_allKeys = _key_resp_27_allKeys.concat(theseKeys);
      if (_key_resp_27_allKeys.length > 0) {
        key_resp_27.keys = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].name;  // just the last key pressed
        key_resp_27.rt = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroA_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroA_2'-------
    IntroA_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "IntroA_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_28_allKeys;
var IntroB_2Components;
function IntroB_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroB_2'-------
    t = 0;
    IntroB_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_28.keys = undefined;
    key_resp_28.rt = undefined;
    _key_resp_28_allKeys = [];
    // keep track of which components have finished
    IntroB_2Components = [];
    IntroB_2Components.push(white_background_21);
    IntroB_2Components.push(text_52);
    IntroB_2Components.push(text_53);
    IntroB_2Components.push(key_resp_28);
    
    IntroB_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroB_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroB_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_21* updates
    if (t >= 0.0 && white_background_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_21.tStart = t;  // (not accounting for frame time here)
      white_background_21.frameNStart = frameN;  // exact frame index
      
      white_background_21.setAutoDraw(true);
    }

    
    // *text_52* updates
    if (t >= 0.0 && text_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_52.tStart = t;  // (not accounting for frame time here)
      text_52.frameNStart = frameN;  // exact frame index
      
      text_52.setAutoDraw(true);
    }

    
    // *text_53* updates
    if (t >= 0.0 && text_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_53.tStart = t;  // (not accounting for frame time here)
      text_53.frameNStart = frameN;  // exact frame index
      
      text_53.setAutoDraw(true);
    }

    
    // *key_resp_28* updates
    if (t >= 0.0 && key_resp_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_28.tStart = t;  // (not accounting for frame time here)
      key_resp_28.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_28.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_28.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_28.clearEvents(); });
    }

    if (key_resp_28.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_28.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_28_allKeys = _key_resp_28_allKeys.concat(theseKeys);
      if (_key_resp_28_allKeys.length > 0) {
        key_resp_28.keys = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].name;  // just the last key pressed
        key_resp_28.rt = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroB_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroB_2'-------
    IntroB_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "IntroB_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_11_allKeys;
var Example1Components;
function Example1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Example1'-------
    t = 0;
    Example1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_11.keys = undefined;
    key_resp_11.rt = undefined;
    _key_resp_11_allKeys = [];
    // keep track of which components have finished
    Example1Components = [];
    Example1Components.push(white_background_14);
    Example1Components.push(text_18);
    Example1Components.push(image_3);
    Example1Components.push(key_resp_11);
    Example1Components.push(text_60);
    
    Example1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Example1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Example1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Example1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_14* updates
    if (t >= 0.0 && white_background_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_14.tStart = t;  // (not accounting for frame time here)
      white_background_14.frameNStart = frameN;  // exact frame index
      
      white_background_14.setAutoDraw(true);
    }

    
    // *text_18* updates
    if (t >= 0.0 && text_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_18.tStart = t;  // (not accounting for frame time here)
      text_18.frameNStart = frameN;  // exact frame index
      
      text_18.setAutoDraw(true);
    }

    
    // *image_3* updates
    if (t >= 0.0 && image_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_3.tStart = t;  // (not accounting for frame time here)
      image_3.frameNStart = frameN;  // exact frame index
      
      image_3.setAutoDraw(true);
    }

    
    // *key_resp_11* updates
    if (t >= 0.0 && key_resp_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_11.tStart = t;  // (not accounting for frame time here)
      key_resp_11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.clearEvents(); });
    }

    if (key_resp_11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_11.getKeys({keyList: ['m'], waitRelease: false});
      _key_resp_11_allKeys = _key_resp_11_allKeys.concat(theseKeys);
      if (_key_resp_11_allKeys.length > 0) {
        key_resp_11.keys = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].name;  // just the last key pressed
        key_resp_11.rt = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_60* updates
    if (t >= 0.0 && text_60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_60.tStart = t;  // (not accounting for frame time here)
      text_60.frameNStart = frameN;  // exact frame index
      
      text_60.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Example1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Example1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Example1'-------
    Example1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_11.keys', key_resp_11.keys);
    if (typeof key_resp_11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_11.rt', key_resp_11.rt);
        routineTimer.reset();
        }
    
    key_resp_11.stop();
    // the Routine "Example1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_12_allKeys;
var Example2Components;
function Example2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Example2'-------
    t = 0;
    Example2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_12.keys = undefined;
    key_resp_12.rt = undefined;
    _key_resp_12_allKeys = [];
    // keep track of which components have finished
    Example2Components = [];
    Example2Components.push(white_background_12);
    Example2Components.push(text_19);
    Example2Components.push(image_4);
    Example2Components.push(key_resp_12);
    Example2Components.push(text_61);
    
    Example2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Example2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Example2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Example2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_12* updates
    if (t >= 0.0 && white_background_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_12.tStart = t;  // (not accounting for frame time here)
      white_background_12.frameNStart = frameN;  // exact frame index
      
      white_background_12.setAutoDraw(true);
    }

    
    // *text_19* updates
    if (t >= 0.0 && text_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_19.tStart = t;  // (not accounting for frame time here)
      text_19.frameNStart = frameN;  // exact frame index
      
      text_19.setAutoDraw(true);
    }

    
    // *image_4* updates
    if (t >= 0.0 && image_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_4.tStart = t;  // (not accounting for frame time here)
      image_4.frameNStart = frameN;  // exact frame index
      
      image_4.setAutoDraw(true);
    }

    
    // *key_resp_12* updates
    if (t >= 0.0 && key_resp_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_12.tStart = t;  // (not accounting for frame time here)
      key_resp_12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.clearEvents(); });
    }

    if (key_resp_12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_12.getKeys({keyList: ['z'], waitRelease: false});
      _key_resp_12_allKeys = _key_resp_12_allKeys.concat(theseKeys);
      if (_key_resp_12_allKeys.length > 0) {
        key_resp_12.keys = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].name;  // just the last key pressed
        key_resp_12.rt = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_61* updates
    if (t >= 0.0 && text_61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_61.tStart = t;  // (not accounting for frame time here)
      text_61.frameNStart = frameN;  // exact frame index
      
      text_61.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Example2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Example2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Example2'-------
    Example2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_12.keys', key_resp_12.keys);
    if (typeof key_resp_12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_12.rt', key_resp_12.rt);
        routineTimer.reset();
        }
    
    key_resp_12.stop();
    // the Routine "Example2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_32_allKeys;
var Quick_ReminderComponents;
function Quick_ReminderRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Quick_Reminder'-------
    t = 0;
    Quick_ReminderClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_32.keys = undefined;
    key_resp_32.rt = undefined;
    _key_resp_32_allKeys = [];
    // keep track of which components have finished
    Quick_ReminderComponents = [];
    Quick_ReminderComponents.push(white_background_19);
    Quick_ReminderComponents.push(text_71);
    Quick_ReminderComponents.push(key_resp_32);
    Quick_ReminderComponents.push(text_72);
    
    Quick_ReminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_ReminderRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Quick_Reminder'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Quick_ReminderClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_19* updates
    if (t >= 0.0 && white_background_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_19.tStart = t;  // (not accounting for frame time here)
      white_background_19.frameNStart = frameN;  // exact frame index
      
      white_background_19.setAutoDraw(true);
    }

    
    // *text_71* updates
    if (t >= 0.0 && text_71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_71.tStart = t;  // (not accounting for frame time here)
      text_71.frameNStart = frameN;  // exact frame index
      
      text_71.setAutoDraw(true);
    }

    
    // *key_resp_32* updates
    if (t >= 0.0 && key_resp_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_32.tStart = t;  // (not accounting for frame time here)
      key_resp_32.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_32.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_32.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_32.clearEvents(); });
    }

    if (key_resp_32.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_32.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_32_allKeys = _key_resp_32_allKeys.concat(theseKeys);
      if (_key_resp_32_allKeys.length > 0) {
        key_resp_32.keys = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].name;  // just the last key pressed
        key_resp_32.rt = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_72* updates
    if (t >= 0.0 && text_72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_72.tStart = t;  // (not accounting for frame time here)
      text_72.frameNStart = frameN;  // exact frame index
      
      text_72.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Quick_ReminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_ReminderRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Quick_Reminder'-------
    Quick_ReminderComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_32.keys', key_resp_32.keys);
    if (typeof key_resp_32.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_32.rt', key_resp_32.rt);
        routineTimer.reset();
        }
    
    key_resp_32.stop();
    // the Routine "Quick_Reminder" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_13_allKeys;
var Practice_congruentComponents;
function Practice_congruentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_congruent'-------
    t = 0;
    Practice_congruentClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_13.keys = undefined;
    key_resp_13.rt = undefined;
    _key_resp_13_allKeys = [];
    // keep track of which components have finished
    Practice_congruentComponents = [];
    Practice_congruentComponents.push(white_background_7);
    Practice_congruentComponents.push(text_20);
    Practice_congruentComponents.push(text_21);
    Practice_congruentComponents.push(key_resp_13);
    
    Practice_congruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_congruentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_congruent'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_congruentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_7* updates
    if (t >= 0.0 && white_background_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_7.tStart = t;  // (not accounting for frame time here)
      white_background_7.frameNStart = frameN;  // exact frame index
      
      white_background_7.setAutoDraw(true);
    }

    
    // *text_20* updates
    if (t >= 0.0 && text_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_20.tStart = t;  // (not accounting for frame time here)
      text_20.frameNStart = frameN;  // exact frame index
      
      text_20.setAutoDraw(true);
    }

    
    // *text_21* updates
    if (t >= 0.0 && text_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_21.tStart = t;  // (not accounting for frame time here)
      text_21.frameNStart = frameN;  // exact frame index
      
      text_21.setAutoDraw(true);
    }

    
    // *key_resp_13* updates
    if (t >= 0.0 && key_resp_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_13.tStart = t;  // (not accounting for frame time here)
      key_resp_13.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_13.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.clearEvents(); });
    }

    if (key_resp_13.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_13.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_13_allKeys = _key_resp_13_allKeys.concat(theseKeys);
      if (_key_resp_13_allKeys.length > 0) {
        key_resp_13.keys = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].name;  // just the last key pressed
        key_resp_13.rt = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_congruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_congruentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_congruent'-------
    Practice_congruentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_13.keys', key_resp_13.keys);
    if (typeof key_resp_13.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_13.rt', key_resp_13.rt);
        routineTimer.reset();
        }
    
    key_resp_13.stop();
    // the Routine "Practice_congruent" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_14_allKeys;
var Practice_trial_congruentComponents;
function Practice_trial_congruentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_congruent'-------
    t = 0;
    Practice_trial_congruentClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_5.setImage(Heart);
    key_resp_14.keys = undefined;
    key_resp_14.rt = undefined;
    _key_resp_14_allKeys = [];
    var color_msg_incongruent01;
    var msg_incongruent01;
    // keep track of which components have finished
    Practice_trial_congruentComponents = [];
    Practice_trial_congruentComponents.push(white_background_17);
    Practice_trial_congruentComponents.push(text_22);
    Practice_trial_congruentComponents.push(text_64);
    Practice_trial_congruentComponents.push(image_5);
    Practice_trial_congruentComponents.push(text_28);
    Practice_trial_congruentComponents.push(key_resp_14);
    
    Practice_trial_congruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_congruentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_congruent'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_congruentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_17* updates
    if (t >= 0.0 && white_background_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_17.tStart = t;  // (not accounting for frame time here)
      white_background_17.frameNStart = frameN;  // exact frame index
      
      white_background_17.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_17.status === PsychoJS.Status.STARTED || white_background_17.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_17.setAutoDraw(false);
    }
    
    // *text_22* updates
    if (t >= 0.0 && text_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_22.tStart = t;  // (not accounting for frame time here)
      text_22.frameNStart = frameN;  // exact frame index
      
      text_22.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_22.status === PsychoJS.Status.STARTED || text_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_22.setAutoDraw(false);
    }
    
    // *text_64* updates
    if (t >= 0.5 && text_64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_64.tStart = t;  // (not accounting for frame time here)
      text_64.frameNStart = frameN;  // exact frame index
      
      text_64.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_64.status === PsychoJS.Status.STARTED || text_64.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_64.setAutoDraw(false);
    }
    
    // *image_5* updates
    if (t >= 1.0 && image_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_5.tStart = t;  // (not accounting for frame time here)
      image_5.frameNStart = frameN;  // exact frame index
      
      image_5.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_5.status === PsychoJS.Status.STARTED || image_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_5.setAutoDraw(false);
    }
    
    // *text_28* updates
    if (t >= 1.75 && text_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_28.tStart = t;  // (not accounting for frame time here)
      text_28.frameNStart = frameN;  // exact frame index
      
      text_28.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_28.status === PsychoJS.Status.STARTED || text_28.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_28.setAutoDraw(false);
    }
    
    // *key_resp_14* updates
    if (t >= 1.0 && key_resp_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_14.tStart = t;  // (not accounting for frame time here)
      key_resp_14.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_14.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_14.status === PsychoJS.Status.STARTED || key_resp_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_14.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_14.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_14.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_14_allKeys = _key_resp_14_allKeys.concat(theseKeys);
      if (_key_resp_14_allKeys.length > 0) {
        key_resp_14.keys = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].name;  // just the last key pressed
        key_resp_14.rt = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_14.keys == corAns) {
            key_resp_14.corr = 1;
        } else {
            key_resp_14.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_congruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var msg_incongruent01;
var color_msg_incongruent01;
function Practice_trial_congruentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_congruent'-------
    Practice_trial_congruentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_14.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_14.corr = 1;  // correct non-response
      } else {
         key_resp_14.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_14.keys', key_resp_14.keys);
    psychoJS.experiment.addData('key_resp_14.corr', key_resp_14.corr);
    if (typeof key_resp_14.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_14.rt', key_resp_14.rt);
        routineTimer.reset();
        }
    
    key_resp_14.stop();
      if (key_resp_14.keys === undefined) {
          msg_incongruent01 = 'No response'
          color_msg_incongruent01 = 'black'
          } else {
          if (key_resp_14.corr > 0){
              msg_incongruent01 = 'Correct'
              color_msg_incongruent01 = 'green'
          } else {
              msg_incongruent01 = 'Incorrect'
              color_msg_incongruent01 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_congruent_1Components;
function feedback_hf_congruent_1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_congruent_1'-------
    t = 0;
    feedback_hf_congruent_1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_108.setColor(new util.Color(color_msg_incongruent01));
    text_108.setText(msg_incongruent01);
    // keep track of which components have finished
    feedback_hf_congruent_1Components = [];
    feedback_hf_congruent_1Components.push(white_background_33);
    feedback_hf_congruent_1Components.push(text_108);
    
    feedback_hf_congruent_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_congruent_1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_congruent_1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_congruent_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_33* updates
    if (t >= 0.0 && white_background_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_33.tStart = t;  // (not accounting for frame time here)
      white_background_33.frameNStart = frameN;  // exact frame index
      
      white_background_33.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_33.status === PsychoJS.Status.STARTED || white_background_33.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_33.setAutoDraw(false);
    }
    
    // *text_108* updates
    if (t >= 0.0 && text_108.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_108.tStart = t;  // (not accounting for frame time here)
      text_108.frameNStart = frameN;  // exact frame index
      
      text_108.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_108.status === PsychoJS.Status.STARTED || text_108.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_108.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_congruent_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_congruent_1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_congruent_1'-------
    feedback_hf_congruent_1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_37_allKeys;
var nCorrhf01;
var congruent_reminderComponents;
function congruent_reminderRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'congruent_reminder'-------
    t = 0;
    congruent_reminderClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_37.keys = undefined;
    key_resp_37.rt = undefined;
    _key_resp_37_allKeys = [];
    nCorrhf01 = 0;
    console.log("hf_congruent02")
    console.log(nCorrhf01)
      for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
        if ('key_resp_14.corr' in psychoJS.experiment._trialsData[eachResp]) {
        nCorrhf01 += psychoJS.experiment._trialsData[eachResp]['key_resp_14.corr'];
        }
      }
    
    
    console.log("hf_congruent02")
    console.log(nCorrhf01)
    
    // keep track of which components have finished
    congruent_reminderComponents = [];
    congruent_reminderComponents.push(white_background_41);
    congruent_reminderComponents.push(text_102);
    congruent_reminderComponents.push(text_103);
    congruent_reminderComponents.push(key_resp_37);
    
    congruent_reminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function congruent_reminderRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'congruent_reminder'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = congruent_reminderClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_41* updates
    if (t >= 0.0 && white_background_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_41.tStart = t;  // (not accounting for frame time here)
      white_background_41.frameNStart = frameN;  // exact frame index
      
      white_background_41.setAutoDraw(true);
    }

    
    // *text_102* updates
    if (t >= 0.0 && text_102.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_102.tStart = t;  // (not accounting for frame time here)
      text_102.frameNStart = frameN;  // exact frame index
      
      text_102.setAutoDraw(true);
    }

    
    // *text_103* updates
    if (t >= 0.0 && text_103.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_103.tStart = t;  // (not accounting for frame time here)
      text_103.frameNStart = frameN;  // exact frame index
      
      text_103.setAutoDraw(true);
    }

    
    // *key_resp_37* updates
    if (t >= 0.0 && key_resp_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_37.tStart = t;  // (not accounting for frame time here)
      key_resp_37.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_37.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_37.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_37.clearEvents(); });
    }

    if (key_resp_37.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_37.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_37_allKeys = _key_resp_37_allKeys.concat(theseKeys);
      if (_key_resp_37_allKeys.length > 0) {
        key_resp_37.keys = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].name;  // just the last key pressed
        key_resp_37.rt = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    if (nCorrhf01 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } 
    else if (key_resp_37.keys === 'space') {
        continueRoutine = false;
        }
    else {
        console.log("false")
        continueRoutine = true;
        }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    congruent_reminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function congruent_reminderRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'congruent_reminder'-------
    congruent_reminderComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "congruent_reminder" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_21_allKeys;
var Practice_trial_congruent_2Components;
function Practice_trial_congruent_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_congruent_2'-------
    t = 0;
    Practice_trial_congruent_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_13.setImage(Heart);
    key_resp_21.keys = undefined;
    key_resp_21.rt = undefined;
    _key_resp_21_allKeys = [];
    var msg_incongruent02;
    var color_msg_incongruent02;
    
    console.log("hf_congruent02")
    console.log(nCorrhf01)
    // keep track of which components have finished
    Practice_trial_congruent_2Components = [];
    Practice_trial_congruent_2Components.push(white_background_32);
    Practice_trial_congruent_2Components.push(text_93);
    Practice_trial_congruent_2Components.push(text_94);
    Practice_trial_congruent_2Components.push(image_13);
    Practice_trial_congruent_2Components.push(text_95);
    Practice_trial_congruent_2Components.push(key_resp_21);
    
    Practice_trial_congruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_congruent_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_congruent_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_congruent_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_32* updates
    if (t >= 0.0 && white_background_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_32.tStart = t;  // (not accounting for frame time here)
      white_background_32.frameNStart = frameN;  // exact frame index
      
      white_background_32.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_32.status === PsychoJS.Status.STARTED || white_background_32.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_32.setAutoDraw(false);
    }
    
    // *text_93* updates
    if (t >= 0.0 && text_93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_93.tStart = t;  // (not accounting for frame time here)
      text_93.frameNStart = frameN;  // exact frame index
      
      text_93.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_93.status === PsychoJS.Status.STARTED || text_93.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_93.setAutoDraw(false);
    }
    
    // *text_94* updates
    if (t >= 0.5 && text_94.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_94.tStart = t;  // (not accounting for frame time here)
      text_94.frameNStart = frameN;  // exact frame index
      
      text_94.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_94.status === PsychoJS.Status.STARTED || text_94.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_94.setAutoDraw(false);
    }
    
    // *image_13* updates
    if (t >= 1.0 && image_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_13.tStart = t;  // (not accounting for frame time here)
      image_13.frameNStart = frameN;  // exact frame index
      
      image_13.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_13.status === PsychoJS.Status.STARTED || image_13.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_13.setAutoDraw(false);
    }
    
    // *text_95* updates
    if (t >= 1.75 && text_95.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_95.tStart = t;  // (not accounting for frame time here)
      text_95.frameNStart = frameN;  // exact frame index
      
      text_95.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_95.status === PsychoJS.Status.STARTED || text_95.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_95.setAutoDraw(false);
    }
    
    // *key_resp_21* updates
    if (t >= 1.0 && key_resp_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_21.tStart = t;  // (not accounting for frame time here)
      key_resp_21.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_21.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_21.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_21.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_21.status === PsychoJS.Status.STARTED || key_resp_21.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_21.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_21.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_21.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_21_allKeys = _key_resp_21_allKeys.concat(theseKeys);
      if (_key_resp_21_allKeys.length > 0) {
        key_resp_21.keys = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].name;  // just the last key pressed
        key_resp_21.rt = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_21.keys == corAns) {
            key_resp_21.corr = 1;
        } else {
            key_resp_21.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    var msg_incongruent02;
    var color_msg_incongruent02;
    
    console.log("hf_congruent02")
    console.log(nCorrhf01)
    if (nCorrhf01 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_congruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var msg_incongruent02;
var color_msg_incongruent02;
function Practice_trial_congruent_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_congruent_2'-------
    Practice_trial_congruent_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_21.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_21.corr = 1;  // correct non-response
      } else {
         key_resp_21.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_21.keys', key_resp_21.keys);
    psychoJS.experiment.addData('key_resp_21.corr', key_resp_21.corr);
    if (typeof key_resp_21.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_21.rt', key_resp_21.rt);
        routineTimer.reset();
        }
    
    key_resp_21.stop();
      if (key_resp_21.keys === undefined) {
          msg_incongruent02 = 'No Response'
          color_msg_incongruent02 = 'black'
          } else {
          if (key_resp_21.corr > 0){
              msg_incongruent02 = 'Correct'
              color_msg_incongruent02 = 'green'
          } else {
              msg_incongruent02 = 'Incorrect'
              color_msg_incongruent02 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_congruent_2Components;
function feedback_hf_congruent_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_congruent_2'-------
    t = 0;
    feedback_hf_congruent_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_114.setColor(new util.Color(color_msg_incongruent02));
    text_114.setText(msg_incongruent02);
    // keep track of which components have finished
    feedback_hf_congruent_2Components = [];
    feedback_hf_congruent_2Components.push(white_background_34);
    feedback_hf_congruent_2Components.push(text_114);
    
    feedback_hf_congruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_congruent_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_congruent_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_congruent_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_34* updates
    if (t >= 0.0 && white_background_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_34.tStart = t;  // (not accounting for frame time here)
      white_background_34.frameNStart = frameN;  // exact frame index
      
      white_background_34.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_34.status === PsychoJS.Status.STARTED || white_background_34.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_34.setAutoDraw(false);
    }
    
    // *text_114* updates
    if (t >= 0.0 && text_114.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_114.tStart = t;  // (not accounting for frame time here)
      text_114.frameNStart = frameN;  // exact frame index
      
      text_114.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_114.status === PsychoJS.Status.STARTED || text_114.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_114.setAutoDraw(false);
    }
    console.log("hf_congruent02")
    console.log(nCorrhf01)
    if (nCorrhf01 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_congruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_congruent_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_congruent_2'-------
    feedback_hf_congruent_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_15_allKeys;
var ReadyComponents;
function ReadyRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Ready'-------
    t = 0;
    ReadyClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_15.keys = undefined;
    key_resp_15.rt = undefined;
    _key_resp_15_allKeys = [];
    // keep track of which components have finished
    ReadyComponents = [];
    ReadyComponents.push(white_background_30);
    ReadyComponents.push(text_29);
    ReadyComponents.push(key_resp_15);
    ReadyComponents.push(text_30);
    
    ReadyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function ReadyRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Ready'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = ReadyClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_30* updates
    if (t >= 0.0 && white_background_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_30.tStart = t;  // (not accounting for frame time here)
      white_background_30.frameNStart = frameN;  // exact frame index
      
      white_background_30.setAutoDraw(true);
    }

    
    // *text_29* updates
    if (t >= 0.0 && text_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_29.tStart = t;  // (not accounting for frame time here)
      text_29.frameNStart = frameN;  // exact frame index
      
      text_29.setAutoDraw(true);
    }

    
    // *key_resp_15* updates
    if (t >= 0.0 && key_resp_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_15.tStart = t;  // (not accounting for frame time here)
      key_resp_15.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_15.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.clearEvents(); });
    }

    if (key_resp_15.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_15.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_15_allKeys = _key_resp_15_allKeys.concat(theseKeys);
      if (_key_resp_15_allKeys.length > 0) {
        key_resp_15.keys = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].name;  // just the last key pressed
        key_resp_15.rt = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_30* updates
    if (t >= 0.0 && text_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_30.tStart = t;  // (not accounting for frame time here)
      text_30.frameNStart = frameN;  // exact frame index
      
      text_30.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ReadyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ReadyRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Ready'-------
    ReadyComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_15.keys', key_resp_15.keys);
    if (typeof key_resp_15.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_15.rt', key_resp_15.rt);
        routineTimer.reset();
        }
    
    key_resp_15.stop();
    // the Routine "Ready" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _heart_resp_allKeys;
var HeartsComponents;
function HeartsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Hearts'-------
    t = 0;
    HeartsClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    hearts.setImage(Hearts);
    heart_resp.keys = undefined;
    heart_resp.rt = undefined;
    _heart_resp_allKeys = [];
    // keep track of which components have finished
    HeartsComponents = [];
    HeartsComponents.push(white_background_6);
    HeartsComponents.push(text_23);
    HeartsComponents.push(text_65);
    HeartsComponents.push(hearts);
    HeartsComponents.push(text_31);
    HeartsComponents.push(heart_resp);
    
    HeartsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function HeartsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Hearts'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = HeartsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_6* updates
    if (t >= 0.0 && white_background_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_6.tStart = t;  // (not accounting for frame time here)
      white_background_6.frameNStart = frameN;  // exact frame index
      
      white_background_6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_6.status === PsychoJS.Status.STARTED || white_background_6.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_6.setAutoDraw(false);
    }
    
    // *text_23* updates
    if (t >= 0 && text_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_23.tStart = t;  // (not accounting for frame time here)
      text_23.frameNStart = frameN;  // exact frame index
      
      text_23.setAutoDraw(true);
    }

    frameRemains = 0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_23.status === PsychoJS.Status.STARTED || text_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_23.setAutoDraw(false);
    }
    
    // *text_65* updates
    if (t >= 0.5 && text_65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_65.tStart = t;  // (not accounting for frame time here)
      text_65.frameNStart = frameN;  // exact frame index
      
      text_65.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_65.status === PsychoJS.Status.STARTED || text_65.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_65.setAutoDraw(false);
    }
    
    // *hearts* updates
    if (t >= 1.0 && hearts.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      hearts.tStart = t;  // (not accounting for frame time here)
      hearts.frameNStart = frameN;  // exact frame index
      
      hearts.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((hearts.status === PsychoJS.Status.STARTED || hearts.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      hearts.setAutoDraw(false);
    }
    
    // *text_31* updates
    if (t >= 1.75 && text_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_31.tStart = t;  // (not accounting for frame time here)
      text_31.frameNStart = frameN;  // exact frame index
      
      text_31.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_31.status === PsychoJS.Status.STARTED || text_31.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_31.setAutoDraw(false);
    }
    
    // *heart_resp* updates
    if (t >= 1.0 && heart_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      heart_resp.tStart = t;  // (not accounting for frame time here)
      heart_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { heart_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { heart_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { heart_resp.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((heart_resp.status === PsychoJS.Status.STARTED || heart_resp.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      heart_resp.status = PsychoJS.Status.FINISHED;
  }

    if (heart_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = heart_resp.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _heart_resp_allKeys = _heart_resp_allKeys.concat(theseKeys);
      if (_heart_resp_allKeys.length > 0) {
        heart_resp.keys = _heart_resp_allKeys[_heart_resp_allKeys.length - 1].name;  // just the last key pressed
        heart_resp.rt = _heart_resp_allKeys[_heart_resp_allKeys.length - 1].rt;
        // was this correct?
        if (heart_resp.keys == corAns) {
            heart_resp.corr = 1;
        } else {
            heart_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    HeartsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function HeartsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Hearts'-------
    HeartsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (heart_resp.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         heart_resp.corr = 1;  // correct non-response
      } else {
         heart_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('heart_resp.keys', heart_resp.keys);
    psychoJS.experiment.addData('heart_resp.corr', heart_resp.corr);
    if (typeof heart_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('heart_resp.rt', heart_resp.rt);
        routineTimer.reset();
        }
    
    heart_resp.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_16_allKeys;
var IntroA_3Components;
function IntroA_3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroA_3'-------
    t = 0;
    IntroA_3Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_16.keys = undefined;
    key_resp_16.rt = undefined;
    _key_resp_16_allKeys = [];
    // keep track of which components have finished
    IntroA_3Components = [];
    IntroA_3Components.push(white_background_26);
    IntroA_3Components.push(text_32);
    IntroA_3Components.push(key_resp_16);
    IntroA_3Components.push(text_33);
    IntroA_3Components.push(image_12);
    
    IntroA_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroA_3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroA_3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_26* updates
    if (t >= 0.0 && white_background_26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_26.tStart = t;  // (not accounting for frame time here)
      white_background_26.frameNStart = frameN;  // exact frame index
      
      white_background_26.setAutoDraw(true);
    }

    
    // *text_32* updates
    if (t >= 0.0 && text_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_32.tStart = t;  // (not accounting for frame time here)
      text_32.frameNStart = frameN;  // exact frame index
      
      text_32.setAutoDraw(true);
    }

    
    // *key_resp_16* updates
    if (t >= 0.0 && key_resp_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_16.tStart = t;  // (not accounting for frame time here)
      key_resp_16.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_16.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.clearEvents(); });
    }

    if (key_resp_16.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_16.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_16_allKeys = _key_resp_16_allKeys.concat(theseKeys);
      if (_key_resp_16_allKeys.length > 0) {
        key_resp_16.keys = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].name;  // just the last key pressed
        key_resp_16.rt = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_33* updates
    if (t >= 0.0 && text_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_33.tStart = t;  // (not accounting for frame time here)
      text_33.frameNStart = frameN;  // exact frame index
      
      text_33.setAutoDraw(true);
    }

    
    // *image_12* updates
    if (t >= 0.0 && image_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_12.tStart = t;  // (not accounting for frame time here)
      image_12.frameNStart = frameN;  // exact frame index
      
      image_12.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroA_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroA_3'-------
    IntroA_3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_16.keys', key_resp_16.keys);
    if (typeof key_resp_16.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_16.rt', key_resp_16.rt);
        routineTimer.reset();
        }
    
    key_resp_16.stop();
    // the Routine "IntroA_3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_17_allKeys;
var IntroB_3Components;
function IntroB_3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroB_3'-------
    t = 0;
    IntroB_3Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_17.keys = undefined;
    key_resp_17.rt = undefined;
    _key_resp_17_allKeys = [];
    // keep track of which components have finished
    IntroB_3Components = [];
    IntroB_3Components.push(white_background_20);
    IntroB_3Components.push(text_47);
    IntroB_3Components.push(text_34);
    IntroB_3Components.push(key_resp_17);
    
    IntroB_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroB_3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroB_3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_20* updates
    if (t >= 0.0 && white_background_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_20.tStart = t;  // (not accounting for frame time here)
      white_background_20.frameNStart = frameN;  // exact frame index
      
      white_background_20.setAutoDraw(true);
    }

    
    // *text_47* updates
    if (t >= 0.0 && text_47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_47.tStart = t;  // (not accounting for frame time here)
      text_47.frameNStart = frameN;  // exact frame index
      
      text_47.setAutoDraw(true);
    }

    
    // *text_34* updates
    if (t >= 0.0 && text_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_34.tStart = t;  // (not accounting for frame time here)
      text_34.frameNStart = frameN;  // exact frame index
      
      text_34.setAutoDraw(true);
    }

    
    // *key_resp_17* updates
    if (t >= 0.0 && key_resp_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_17.tStart = t;  // (not accounting for frame time here)
      key_resp_17.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_17.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.clearEvents(); });
    }

    if (key_resp_17.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_17.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_17_allKeys = _key_resp_17_allKeys.concat(theseKeys);
      if (_key_resp_17_allKeys.length > 0) {
        key_resp_17.keys = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].name;  // just the last key pressed
        key_resp_17.rt = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroB_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroB_3'-------
    IntroB_3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_17.keys', key_resp_17.keys);
    if (typeof key_resp_17.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_17.rt', key_resp_17.rt);
        routineTimer.reset();
        }
    
    key_resp_17.stop();
    // the Routine "IntroB_3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_18_allKeys;
var Example3Components;
function Example3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Example3'-------
    t = 0;
    Example3Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_18.keys = undefined;
    key_resp_18.rt = undefined;
    _key_resp_18_allKeys = [];
    // keep track of which components have finished
    Example3Components = [];
    Example3Components.push(white_background_13);
    Example3Components.push(text_35);
    Example3Components.push(image_6);
    Example3Components.push(key_resp_18);
    Example3Components.push(text_62);
    
    Example3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Example3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Example3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Example3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_13* updates
    if (t >= 0.0 && white_background_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_13.tStart = t;  // (not accounting for frame time here)
      white_background_13.frameNStart = frameN;  // exact frame index
      
      white_background_13.setAutoDraw(true);
    }

    
    // *text_35* updates
    if (t >= 0.0 && text_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_35.tStart = t;  // (not accounting for frame time here)
      text_35.frameNStart = frameN;  // exact frame index
      
      text_35.setAutoDraw(true);
    }

    
    // *image_6* updates
    if (t >= 0.0 && image_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_6.tStart = t;  // (not accounting for frame time here)
      image_6.frameNStart = frameN;  // exact frame index
      
      image_6.setAutoDraw(true);
    }

    
    // *key_resp_18* updates
    if (t >= 0.0 && key_resp_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_18.tStart = t;  // (not accounting for frame time here)
      key_resp_18.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_18.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.clearEvents(); });
    }

    if (key_resp_18.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_18.getKeys({keyList: ['z'], waitRelease: false});
      _key_resp_18_allKeys = _key_resp_18_allKeys.concat(theseKeys);
      if (_key_resp_18_allKeys.length > 0) {
        key_resp_18.keys = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].name;  // just the last key pressed
        key_resp_18.rt = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_62* updates
    if (t >= 0.0 && text_62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_62.tStart = t;  // (not accounting for frame time here)
      text_62.frameNStart = frameN;  // exact frame index
      
      text_62.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Example3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Example3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Example3'-------
    Example3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_18.keys', key_resp_18.keys);
    if (typeof key_resp_18.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_18.rt', key_resp_18.rt);
        routineTimer.reset();
        }
    
    key_resp_18.stop();
    // the Routine "Example3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_19_allKeys;
var Example4Components;
function Example4RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Example4'-------
    t = 0;
    Example4Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_19.keys = undefined;
    key_resp_19.rt = undefined;
    _key_resp_19_allKeys = [];
    // keep track of which components have finished
    Example4Components = [];
    Example4Components.push(white_background_11);
    Example4Components.push(text_36);
    Example4Components.push(image_7);
    Example4Components.push(key_resp_19);
    Example4Components.push(text_63);
    
    Example4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Example4RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Example4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Example4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_11* updates
    if (t >= 0.0 && white_background_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_11.tStart = t;  // (not accounting for frame time here)
      white_background_11.frameNStart = frameN;  // exact frame index
      
      white_background_11.setAutoDraw(true);
    }

    
    // *text_36* updates
    if (t >= 0.0 && text_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_36.tStart = t;  // (not accounting for frame time here)
      text_36.frameNStart = frameN;  // exact frame index
      
      text_36.setAutoDraw(true);
    }

    
    // *image_7* updates
    if (t >= 0.0 && image_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_7.tStart = t;  // (not accounting for frame time here)
      image_7.frameNStart = frameN;  // exact frame index
      
      image_7.setAutoDraw(true);
    }

    
    // *key_resp_19* updates
    if (t >= 0.0 && key_resp_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_19.tStart = t;  // (not accounting for frame time here)
      key_resp_19.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_19.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_19.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_19.clearEvents(); });
    }

    if (key_resp_19.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_19.getKeys({keyList: ['m'], waitRelease: false});
      _key_resp_19_allKeys = _key_resp_19_allKeys.concat(theseKeys);
      if (_key_resp_19_allKeys.length > 0) {
        key_resp_19.keys = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].name;  // just the last key pressed
        key_resp_19.rt = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_63* updates
    if (t >= 0.0 && text_63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_63.tStart = t;  // (not accounting for frame time here)
      text_63.frameNStart = frameN;  // exact frame index
      
      text_63.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Example4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Example4RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Example4'-------
    Example4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_19.keys', key_resp_19.keys);
    if (typeof key_resp_19.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_19.rt', key_resp_19.rt);
        routineTimer.reset();
        }
    
    key_resp_19.stop();
    // the Routine "Example4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_34_allKeys;
var Quick_Reminder_IncongruentComponents;
function Quick_Reminder_IncongruentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Quick_Reminder_Incongruent'-------
    t = 0;
    Quick_Reminder_IncongruentClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_34.keys = undefined;
    key_resp_34.rt = undefined;
    _key_resp_34_allKeys = [];
    // keep track of which components have finished
    Quick_Reminder_IncongruentComponents = [];
    Quick_Reminder_IncongruentComponents.push(white_background_28);
    Quick_Reminder_IncongruentComponents.push(text_75);
    Quick_Reminder_IncongruentComponents.push(key_resp_34);
    Quick_Reminder_IncongruentComponents.push(text_76);
    
    Quick_Reminder_IncongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_Reminder_IncongruentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Quick_Reminder_Incongruent'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Quick_Reminder_IncongruentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_28* updates
    if (t >= 0.0 && white_background_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_28.tStart = t;  // (not accounting for frame time here)
      white_background_28.frameNStart = frameN;  // exact frame index
      
      white_background_28.setAutoDraw(true);
    }

    
    // *text_75* updates
    if (t >= 0.0 && text_75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_75.tStart = t;  // (not accounting for frame time here)
      text_75.frameNStart = frameN;  // exact frame index
      
      text_75.setAutoDraw(true);
    }

    
    // *key_resp_34* updates
    if (t >= 0.0 && key_resp_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_34.tStart = t;  // (not accounting for frame time here)
      key_resp_34.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_34.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_34.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_34.clearEvents(); });
    }

    if (key_resp_34.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_34.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_34_allKeys = _key_resp_34_allKeys.concat(theseKeys);
      if (_key_resp_34_allKeys.length > 0) {
        key_resp_34.keys = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].name;  // just the last key pressed
        key_resp_34.rt = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_76* updates
    if (t >= 0.0 && text_76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_76.tStart = t;  // (not accounting for frame time here)
      text_76.frameNStart = frameN;  // exact frame index
      
      text_76.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Quick_Reminder_IncongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_Reminder_IncongruentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Quick_Reminder_Incongruent'-------
    Quick_Reminder_IncongruentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_34.keys', key_resp_34.keys);
    if (typeof key_resp_34.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_34.rt', key_resp_34.rt);
        routineTimer.reset();
        }
    
    key_resp_34.stop();
    // the Routine "Quick_Reminder_Incongruent" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_20_allKeys;
var Practice_IncongruentComponents;
function Practice_IncongruentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_Incongruent'-------
    t = 0;
    Practice_IncongruentClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_20.keys = undefined;
    key_resp_20.rt = undefined;
    _key_resp_20_allKeys = [];
    // keep track of which components have finished
    Practice_IncongruentComponents = [];
    Practice_IncongruentComponents.push(white_background_8);
    Practice_IncongruentComponents.push(text_37);
    Practice_IncongruentComponents.push(text_38);
    Practice_IncongruentComponents.push(key_resp_20);
    
    Practice_IncongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_IncongruentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_Incongruent'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_IncongruentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_8* updates
    if (t >= 0.0 && white_background_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_8.tStart = t;  // (not accounting for frame time here)
      white_background_8.frameNStart = frameN;  // exact frame index
      
      white_background_8.setAutoDraw(true);
    }

    
    // *text_37* updates
    if (t >= 0.0 && text_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_37.tStart = t;  // (not accounting for frame time here)
      text_37.frameNStart = frameN;  // exact frame index
      
      text_37.setAutoDraw(true);
    }

    
    // *text_38* updates
    if (t >= 0.0 && text_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_38.tStart = t;  // (not accounting for frame time here)
      text_38.frameNStart = frameN;  // exact frame index
      
      text_38.setAutoDraw(true);
    }

    
    // *key_resp_20* updates
    if (t >= 0.0 && key_resp_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_20.tStart = t;  // (not accounting for frame time here)
      key_resp_20.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_20.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_20.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_20.clearEvents(); });
    }

    if (key_resp_20.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_20.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_20_allKeys = _key_resp_20_allKeys.concat(theseKeys);
      if (_key_resp_20_allKeys.length > 0) {
        key_resp_20.keys = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].name;  // just the last key pressed
        key_resp_20.rt = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_IncongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_IncongruentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_Incongruent'-------
    Practice_IncongruentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_20.keys', key_resp_20.keys);
    if (typeof key_resp_20.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_20.rt', key_resp_20.rt);
        routineTimer.reset();
        }
    
    key_resp_20.stop();
    // the Routine "Practice_Incongruent" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_22_allKeys;
var Practice_trial_incongruentComponents;
function Practice_trial_incongruentRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_incongruent'-------
    t = 0;
    Practice_trial_incongruentClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_8.setImage(Flowers);
    key_resp_22.keys = undefined;
    key_resp_22.rt = undefined;
    _key_resp_22_allKeys = [];
    var msg_incongruent01;
    var color_msg_incongruent01;
    
    // keep track of which components have finished
    Practice_trial_incongruentComponents = [];
    Practice_trial_incongruentComponents.push(white_background_22);
    Practice_trial_incongruentComponents.push(text_39);
    Practice_trial_incongruentComponents.push(text_66);
    Practice_trial_incongruentComponents.push(image_8);
    Practice_trial_incongruentComponents.push(text_48);
    Practice_trial_incongruentComponents.push(key_resp_22);
    
    Practice_trial_incongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_incongruentRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_incongruent'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_incongruentClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_22* updates
    if (t >= 0.0 && white_background_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_22.tStart = t;  // (not accounting for frame time here)
      white_background_22.frameNStart = frameN;  // exact frame index
      
      white_background_22.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_22.status === PsychoJS.Status.STARTED || white_background_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_22.setAutoDraw(false);
    }
    
    // *text_39* updates
    if (t >= 0.0 && text_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_39.tStart = t;  // (not accounting for frame time here)
      text_39.frameNStart = frameN;  // exact frame index
      
      text_39.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_39.status === PsychoJS.Status.STARTED || text_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_39.setAutoDraw(false);
    }
    
    // *text_66* updates
    if (t >= 0.5 && text_66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_66.tStart = t;  // (not accounting for frame time here)
      text_66.frameNStart = frameN;  // exact frame index
      
      text_66.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_66.status === PsychoJS.Status.STARTED || text_66.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_66.setAutoDraw(false);
    }
    
    // *image_8* updates
    if (t >= 1.0 && image_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_8.tStart = t;  // (not accounting for frame time here)
      image_8.frameNStart = frameN;  // exact frame index
      
      image_8.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_8.status === PsychoJS.Status.STARTED || image_8.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_8.setAutoDraw(false);
    }
    
    // *text_48* updates
    if (t >= 1.75 && text_48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_48.tStart = t;  // (not accounting for frame time here)
      text_48.frameNStart = frameN;  // exact frame index
      
      text_48.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_48.status === PsychoJS.Status.STARTED || text_48.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_48.setAutoDraw(false);
    }
    
    // *key_resp_22* updates
    if (t >= 1.0 && key_resp_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_22.tStart = t;  // (not accounting for frame time here)
      key_resp_22.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_22.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_22.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_22.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_22.status === PsychoJS.Status.STARTED || key_resp_22.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_22.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_22.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_22.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_22_allKeys = _key_resp_22_allKeys.concat(theseKeys);
      if (_key_resp_22_allKeys.length > 0) {
        key_resp_22.keys = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].name;  // just the last key pressed
        key_resp_22.rt = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_22.keys == corAns) {
            key_resp_22.corr = 1;
        } else {
            key_resp_22.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_incongruentComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_incongruentRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_incongruent'-------
    Practice_trial_incongruentComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_22.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_22.corr = 1;  // correct non-response
      } else {
         key_resp_22.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_22.keys', key_resp_22.keys);
    psychoJS.experiment.addData('key_resp_22.corr', key_resp_22.corr);
    if (typeof key_resp_22.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_22.rt', key_resp_22.rt);
        routineTimer.reset();
        }
    
    key_resp_22.stop();
      if (key_resp_22.keys === undefined) {
          msg_incongruent01 = 'No Response'
          color_msg_incongruent01 = 'black'
          } else {
          if (key_resp_22.corr > 0){
              msg_incongruent01 = 'Correct'
              color_msg_incongruent01 = 'green'
          } else {
              msg_incongruent01 = 'Incorrect'
              color_msg_incongruent01 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_incongruent_1Components;
function feedback_hf_incongruent_1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_incongruent_1'-------
    t = 0;
    feedback_hf_incongruent_1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_113.setColor(new util.Color(color_msg_incongruent01));
    text_113.setText(msg_incongruent01);
    // keep track of which components have finished
    feedback_hf_incongruent_1Components = [];
    feedback_hf_incongruent_1Components.push(white_background_38);
    feedback_hf_incongruent_1Components.push(text_113);
    
    feedback_hf_incongruent_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_incongruent_1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_incongruent_1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_incongruent_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_38* updates
    if (t >= 0.0 && white_background_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_38.tStart = t;  // (not accounting for frame time here)
      white_background_38.frameNStart = frameN;  // exact frame index
      
      white_background_38.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_38.status === PsychoJS.Status.STARTED || white_background_38.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_38.setAutoDraw(false);
    }
    
    // *text_113* updates
    if (t >= 0.0 && text_113.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_113.tStart = t;  // (not accounting for frame time here)
      text_113.frameNStart = frameN;  // exact frame index
      
      text_113.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_113.status === PsychoJS.Status.STARTED || text_113.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_113.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_incongruent_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_incongruent_1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_incongruent_1'-------
    feedback_hf_incongruent_1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_38_allKeys;
var nCorrhf02;
var incongruent_reminderComponents;
function incongruent_reminderRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'incongruent_reminder'-------
    t = 0;
    incongruent_reminderClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_38.keys = undefined;
    key_resp_38.rt = undefined;
    _key_resp_38_allKeys = [];
    nCorrhf02 = 0;
    console.log("hf_incongruent02")
    console.log(nCorrhf02)
      for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
        if ('key_resp_22.corr' in psychoJS.experiment._trialsData[eachResp]) {
        nCorrhf02 += psychoJS.experiment._trialsData[eachResp]['key_resp_22.corr'];
        }
      }
    
    
    
    // keep track of which components have finished
    incongruent_reminderComponents = [];
    incongruent_reminderComponents.push(white_background_42);
    incongruent_reminderComponents.push(text_104);
    incongruent_reminderComponents.push(text_105);
    incongruent_reminderComponents.push(key_resp_38);
    
    incongruent_reminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function incongruent_reminderRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'incongruent_reminder'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = incongruent_reminderClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_42* updates
    if (t >= 0.0 && white_background_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_42.tStart = t;  // (not accounting for frame time here)
      white_background_42.frameNStart = frameN;  // exact frame index
      
      white_background_42.setAutoDraw(true);
    }

    
    // *text_104* updates
    if (t >= 0.0 && text_104.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_104.tStart = t;  // (not accounting for frame time here)
      text_104.frameNStart = frameN;  // exact frame index
      
      text_104.setAutoDraw(true);
    }

    
    // *text_105* updates
    if (t >= 0.0 && text_105.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_105.tStart = t;  // (not accounting for frame time here)
      text_105.frameNStart = frameN;  // exact frame index
      
      text_105.setAutoDraw(true);
    }

    
    // *key_resp_38* updates
    if (t >= 0.0 && key_resp_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_38.tStart = t;  // (not accounting for frame time here)
      key_resp_38.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_38.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_38.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_38.clearEvents(); });
    }

    if (key_resp_38.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_38.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_38_allKeys = _key_resp_38_allKeys.concat(theseKeys);
      if (_key_resp_38_allKeys.length > 0) {
        key_resp_38.keys = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].name;  // just the last key pressed
        key_resp_38.rt = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    console.log("hf_incongruent02")
    console.log(nCorrhf02)
    if (nCorrhf02 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } 
    else if (key_resp_38.keys === 'space') {
        continueRoutine = false; // until we're told otherwise
            }
    else {
        console.log("false")
        continueRoutine = true;
        }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    incongruent_reminderComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function incongruent_reminderRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'incongruent_reminder'-------
    incongruent_reminderComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_38.keys', key_resp_38.keys);
    if (typeof key_resp_38.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_38.rt', key_resp_38.rt);
        routineTimer.reset();
        }
    
    key_resp_38.stop();
    if (key_resp_38.keys === 'space') {
        continueRoutine = false; // until we're told otherwise
            }
    // the Routine "incongruent_reminder" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_23_allKeys;
var Practice_trial_incongruent_2Components;
function Practice_trial_incongruent_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_incongruent_2'-------
    t = 0;
    Practice_trial_incongruent_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_14.setImage(Flowers);
    key_resp_23.keys = undefined;
    key_resp_23.rt = undefined;
    _key_resp_23_allKeys = [];
    var msg_incongruent02; 
    var color_msg_incongruent02 ;
    
    console.log("hf_incongruent02")
    console.log(nCorrhf02)
    
    // keep track of which components have finished
    Practice_trial_incongruent_2Components = [];
    Practice_trial_incongruent_2Components.push(white_background_35);
    Practice_trial_incongruent_2Components.push(text_96);
    Practice_trial_incongruent_2Components.push(text_97);
    Practice_trial_incongruent_2Components.push(image_14);
    Practice_trial_incongruent_2Components.push(text_98);
    Practice_trial_incongruent_2Components.push(key_resp_23);
    
    Practice_trial_incongruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_incongruent_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_incongruent_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_incongruent_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_35* updates
    if (t >= 0.0 && white_background_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_35.tStart = t;  // (not accounting for frame time here)
      white_background_35.frameNStart = frameN;  // exact frame index
      
      white_background_35.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_35.status === PsychoJS.Status.STARTED || white_background_35.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_35.setAutoDraw(false);
    }
    
    // *text_96* updates
    if (t >= 0.0 && text_96.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_96.tStart = t;  // (not accounting for frame time here)
      text_96.frameNStart = frameN;  // exact frame index
      
      text_96.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_96.status === PsychoJS.Status.STARTED || text_96.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_96.setAutoDraw(false);
    }
    
    // *text_97* updates
    if (t >= 0.5 && text_97.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_97.tStart = t;  // (not accounting for frame time here)
      text_97.frameNStart = frameN;  // exact frame index
      
      text_97.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_97.status === PsychoJS.Status.STARTED || text_97.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_97.setAutoDraw(false);
    }
    
    // *image_14* updates
    if (t >= 1.0 && image_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_14.tStart = t;  // (not accounting for frame time here)
      image_14.frameNStart = frameN;  // exact frame index
      
      image_14.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_14.status === PsychoJS.Status.STARTED || image_14.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_14.setAutoDraw(false);
    }
    
    // *text_98* updates
    if (t >= 1.75 && text_98.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_98.tStart = t;  // (not accounting for frame time here)
      text_98.frameNStart = frameN;  // exact frame index
      
      text_98.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_98.status === PsychoJS.Status.STARTED || text_98.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_98.setAutoDraw(false);
    }
    
    // *key_resp_23* updates
    if (t >= 1.0 && key_resp_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_23.tStart = t;  // (not accounting for frame time here)
      key_resp_23.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_23.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_23.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_23.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_23.status === PsychoJS.Status.STARTED || key_resp_23.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_23.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_23.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_23.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_23_allKeys = _key_resp_23_allKeys.concat(theseKeys);
      if (_key_resp_23_allKeys.length > 0) {
        key_resp_23.keys = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].name;  // just the last key pressed
        key_resp_23.rt = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_23.keys == corAns) {
            key_resp_23.corr = 1;
        } else {
            key_resp_23.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    if (nCorrhf02 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_incongruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_incongruent_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_incongruent_2'-------
    Practice_trial_incongruent_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_23.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_23.corr = 1;  // correct non-response
      } else {
         key_resp_23.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_23.keys', key_resp_23.keys);
    psychoJS.experiment.addData('key_resp_23.corr', key_resp_23.corr);
    if (typeof key_resp_23.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_23.rt', key_resp_23.rt);
        routineTimer.reset();
        }
    
    key_resp_23.stop();
      if (key_resp_23.keys === undefined) {
          msg_incongruent02 = 'No Response'
          color_msg_incongruent02 = 'black'
          } else {
          if (key_resp_23.corr > 0){
              msg_incongruent02 = 'Correct'
              color_msg_incongruent02 = 'green'
          } else {
              msg_incongruent02 = 'Incorrect'
              color_msg_incongruent02 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_incongruent_2Components;
function feedback_hf_incongruent_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_incongruent_2'-------
    t = 0;
    feedback_hf_incongruent_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_112.setColor(new util.Color(color_msg_incongruent02));
    text_112.setText(msg_incongruent02);
    console.log("hf_incongruent02")
    console.log(nCorrhf02)
    
    // keep track of which components have finished
    feedback_hf_incongruent_2Components = [];
    feedback_hf_incongruent_2Components.push(white_background_37);
    feedback_hf_incongruent_2Components.push(text_112);
    
    feedback_hf_incongruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_incongruent_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_incongruent_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_incongruent_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_37* updates
    if (t >= 0.0 && white_background_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_37.tStart = t;  // (not accounting for frame time here)
      white_background_37.frameNStart = frameN;  // exact frame index
      
      white_background_37.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_37.status === PsychoJS.Status.STARTED || white_background_37.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_37.setAutoDraw(false);
    }
    
    // *text_112* updates
    if (t >= 0.0 && text_112.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_112.tStart = t;  // (not accounting for frame time here)
      text_112.frameNStart = frameN;  // exact frame index
      
      text_112.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_112.status === PsychoJS.Status.STARTED || text_112.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_112.setAutoDraw(false);
    }
    if (nCorrhf02 > 2) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_incongruent_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_incongruent_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_incongruent_2'-------
    feedback_hf_incongruent_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_24_allKeys;
var Ready2Components;
function Ready2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Ready2'-------
    t = 0;
    Ready2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_24.keys = undefined;
    key_resp_24.rt = undefined;
    _key_resp_24_allKeys = [];
    // keep track of which components have finished
    Ready2Components = [];
    Ready2Components.push(white_background_3);
    Ready2Components.push(text_49);
    Ready2Components.push(text_50);
    Ready2Components.push(key_resp_24);
    
    Ready2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Ready2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Ready2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Ready2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_3* updates
    if (t >= 0.0 && white_background_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_3.tStart = t;  // (not accounting for frame time here)
      white_background_3.frameNStart = frameN;  // exact frame index
      
      white_background_3.setAutoDraw(true);
    }

    
    // *text_49* updates
    if (t >= 0.0 && text_49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_49.tStart = t;  // (not accounting for frame time here)
      text_49.frameNStart = frameN;  // exact frame index
      
      text_49.setAutoDraw(true);
    }

    
    // *text_50* updates
    if (t >= 0.0 && text_50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_50.tStart = t;  // (not accounting for frame time here)
      text_50.frameNStart = frameN;  // exact frame index
      
      text_50.setAutoDraw(true);
    }

    
    // *key_resp_24* updates
    if (t >= 0.0 && key_resp_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_24.tStart = t;  // (not accounting for frame time here)
      key_resp_24.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_24.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_24.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_24.clearEvents(); });
    }

    if (key_resp_24.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_24.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_24_allKeys = _key_resp_24_allKeys.concat(theseKeys);
      if (_key_resp_24_allKeys.length > 0) {
        key_resp_24.keys = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].name;  // just the last key pressed
        key_resp_24.rt = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Ready2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Ready2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Ready2'-------
    Ready2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_24.keys', key_resp_24.keys);
    if (typeof key_resp_24.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_24.rt', key_resp_24.rt);
        routineTimer.reset();
        }
    
    key_resp_24.stop();
    // the Routine "Ready2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_25_allKeys;
var FlowersComponents;
function FlowersRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Flowers'-------
    t = 0;
    FlowersClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image.setImage(Flowers);
    key_resp_25.keys = undefined;
    key_resp_25.rt = undefined;
    _key_resp_25_allKeys = [];
    // keep track of which components have finished
    FlowersComponents = [];
    FlowersComponents.push(white_background_16);
    FlowersComponents.push(text_51);
    FlowersComponents.push(text_67);
    FlowersComponents.push(image);
    FlowersComponents.push(text_54);
    FlowersComponents.push(key_resp_25);
    
    FlowersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function FlowersRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Flowers'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = FlowersClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_16* updates
    if (t >= 0.0 && white_background_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_16.tStart = t;  // (not accounting for frame time here)
      white_background_16.frameNStart = frameN;  // exact frame index
      
      white_background_16.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_16.status === PsychoJS.Status.STARTED || white_background_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_16.setAutoDraw(false);
    }
    
    // *text_51* updates
    if (t >= 0.0 && text_51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_51.tStart = t;  // (not accounting for frame time here)
      text_51.frameNStart = frameN;  // exact frame index
      
      text_51.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_51.status === PsychoJS.Status.STARTED || text_51.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_51.setAutoDraw(false);
    }
    
    // *text_67* updates
    if (t >= 0.5 && text_67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_67.tStart = t;  // (not accounting for frame time here)
      text_67.frameNStart = frameN;  // exact frame index
      
      text_67.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_67.status === PsychoJS.Status.STARTED || text_67.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_67.setAutoDraw(false);
    }
    
    // *image* updates
    if (t >= 1.0 && image.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image.tStart = t;  // (not accounting for frame time here)
      image.frameNStart = frameN;  // exact frame index
      
      image.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image.status === PsychoJS.Status.STARTED || image.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image.setAutoDraw(false);
    }
    
    // *text_54* updates
    if (t >= 1.75 && text_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_54.tStart = t;  // (not accounting for frame time here)
      text_54.frameNStart = frameN;  // exact frame index
      
      text_54.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_54.status === PsychoJS.Status.STARTED || text_54.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_54.setAutoDraw(false);
    }
    
    // *key_resp_25* updates
    if (t >= 1.0 && key_resp_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_25.tStart = t;  // (not accounting for frame time here)
      key_resp_25.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_25.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_25.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_25.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_25.status === PsychoJS.Status.STARTED || key_resp_25.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_25.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_25.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_25.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_25_allKeys = _key_resp_25_allKeys.concat(theseKeys);
      if (_key_resp_25_allKeys.length > 0) {
        key_resp_25.keys = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].name;  // just the last key pressed
        key_resp_25.rt = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_25.keys == corAns) {
            key_resp_25.corr = 1;
        } else {
            key_resp_25.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    FlowersComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function FlowersRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Flowers'-------
    FlowersComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_25.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_25.corr = 1;  // correct non-response
      } else {
         key_resp_25.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_25.keys', key_resp_25.keys);
    psychoJS.experiment.addData('key_resp_25.corr', key_resp_25.corr);
    if (typeof key_resp_25.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_25.rt', key_resp_25.rt);
        routineTimer.reset();
        }
    
    key_resp_25.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_26_allKeys;
var IntroA_4Components;
function IntroA_4RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroA_4'-------
    t = 0;
    IntroA_4Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_26.keys = undefined;
    key_resp_26.rt = undefined;
    _key_resp_26_allKeys = [];
    // keep track of which components have finished
    IntroA_4Components = [];
    IntroA_4Components.push(white_background_27);
    IntroA_4Components.push(text_55);
    IntroA_4Components.push(key_resp_26);
    IntroA_4Components.push(text_56);
    
    IntroA_4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_4RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroA_4'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroA_4Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_27* updates
    if (t >= 0.0 && white_background_27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_27.tStart = t;  // (not accounting for frame time here)
      white_background_27.frameNStart = frameN;  // exact frame index
      
      white_background_27.setAutoDraw(true);
    }

    
    // *text_55* updates
    if (t >= 0.0 && text_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_55.tStart = t;  // (not accounting for frame time here)
      text_55.frameNStart = frameN;  // exact frame index
      
      text_55.setAutoDraw(true);
    }

    
    // *key_resp_26* updates
    if (t >= 0.0 && key_resp_26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_26.tStart = t;  // (not accounting for frame time here)
      key_resp_26.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_26.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_26.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_26.clearEvents(); });
    }

    if (key_resp_26.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_26.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_26_allKeys = _key_resp_26_allKeys.concat(theseKeys);
      if (_key_resp_26_allKeys.length > 0) {
        key_resp_26.keys = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].name;  // just the last key pressed
        key_resp_26.rt = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_56* updates
    if (t >= 0.0 && text_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_56.tStart = t;  // (not accounting for frame time here)
      text_56.frameNStart = frameN;  // exact frame index
      
      text_56.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroA_4Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroA_4RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroA_4'-------
    IntroA_4Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_26.keys', key_resp_26.keys);
    if (typeof key_resp_26.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_26.rt', key_resp_26.rt);
        routineTimer.reset();
        }
    
    key_resp_26.stop();
    // the Routine "IntroA_4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_29_allKeys;
var IntroB_5Components;
function IntroB_5RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroB_5'-------
    t = 0;
    IntroB_5Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_29.keys = undefined;
    key_resp_29.rt = undefined;
    _key_resp_29_allKeys = [];
    // keep track of which components have finished
    IntroB_5Components = [];
    IntroB_5Components.push(white_background_18);
    IntroB_5Components.push(text_57);
    IntroB_5Components.push(text_58);
    IntroB_5Components.push(key_resp_29);
    
    IntroB_5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_5RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroB_5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroB_5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_18* updates
    if (t >= 0.0 && white_background_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_18.tStart = t;  // (not accounting for frame time here)
      white_background_18.frameNStart = frameN;  // exact frame index
      
      white_background_18.setAutoDraw(true);
    }

    
    // *text_57* updates
    if (t >= 0.0 && text_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_57.tStart = t;  // (not accounting for frame time here)
      text_57.frameNStart = frameN;  // exact frame index
      
      text_57.setAutoDraw(true);
    }

    
    // *text_58* updates
    if (t >= 0.0 && text_58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_58.tStart = t;  // (not accounting for frame time here)
      text_58.frameNStart = frameN;  // exact frame index
      
      text_58.setAutoDraw(true);
    }

    
    // *key_resp_29* updates
    if (t >= 0.0 && key_resp_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_29.tStart = t;  // (not accounting for frame time here)
      key_resp_29.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_29.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_29.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_29.clearEvents(); });
    }

    if (key_resp_29.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_29.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_29_allKeys = _key_resp_29_allKeys.concat(theseKeys);
      if (_key_resp_29_allKeys.length > 0) {
        key_resp_29.keys = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].name;  // just the last key pressed
        key_resp_29.rt = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroB_5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroB_5RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroB_5'-------
    IntroB_5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_29.keys', key_resp_29.keys);
    if (typeof key_resp_29.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_29.rt', key_resp_29.rt);
        routineTimer.reset();
        }
    
    key_resp_29.stop();
    // the Routine "IntroB_5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_31_allKeys;
var IntroC_11Components;
function IntroC_11RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroC_11'-------
    t = 0;
    IntroC_11Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_31.keys = undefined;
    key_resp_31.rt = undefined;
    _key_resp_31_allKeys = [];
    // keep track of which components have finished
    IntroC_11Components = [];
    IntroC_11Components.push(white_background_23);
    IntroC_11Components.push(text_69);
    IntroC_11Components.push(text_70);
    IntroC_11Components.push(key_resp_31);
    
    IntroC_11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroC_11RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroC_11'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroC_11Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_23* updates
    if (t >= 0.0 && white_background_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_23.tStart = t;  // (not accounting for frame time here)
      white_background_23.frameNStart = frameN;  // exact frame index
      
      white_background_23.setAutoDraw(true);
    }

    
    // *text_69* updates
    if (t >= 0.0 && text_69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_69.tStart = t;  // (not accounting for frame time here)
      text_69.frameNStart = frameN;  // exact frame index
      
      text_69.setAutoDraw(true);
    }

    
    // *text_70* updates
    if (t >= 0.0 && text_70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_70.tStart = t;  // (not accounting for frame time here)
      text_70.frameNStart = frameN;  // exact frame index
      
      text_70.setAutoDraw(true);
    }

    
    // *key_resp_31* updates
    if (t >= 0.0 && key_resp_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_31.tStart = t;  // (not accounting for frame time here)
      key_resp_31.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_31.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_31.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_31.clearEvents(); });
    }

    if (key_resp_31.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_31.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_31_allKeys = _key_resp_31_allKeys.concat(theseKeys);
      if (_key_resp_31_allKeys.length > 0) {
        key_resp_31.keys = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].name;  // just the last key pressed
        key_resp_31.rt = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroC_11Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroC_11RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroC_11'-------
    IntroC_11Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_31.keys', key_resp_31.keys);
    if (typeof key_resp_31.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_31.rt', key_resp_31.rt);
        routineTimer.reset();
        }
    
    key_resp_31.stop();
    // the Routine "IntroC_11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_30_allKeys;
var IntroC_2Components;
function IntroC_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'IntroC_2'-------
    t = 0;
    IntroC_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    text_74.setText('Press the space bar to continue.');
    key_resp_30.keys = undefined;
    key_resp_30.rt = undefined;
    _key_resp_30_allKeys = [];
    // keep track of which components have finished
    IntroC_2Components = [];
    IntroC_2Components.push(white_background_24);
    IntroC_2Components.push(text_73);
    IntroC_2Components.push(text_74);
    IntroC_2Components.push(key_resp_30);
    
    IntroC_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroC_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'IntroC_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = IntroC_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_24* updates
    if (t >= 0.0 && white_background_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_24.tStart = t;  // (not accounting for frame time here)
      white_background_24.frameNStart = frameN;  // exact frame index
      
      white_background_24.setAutoDraw(true);
    }

    
    // *text_73* updates
    if (t >= 0.0 && text_73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_73.tStart = t;  // (not accounting for frame time here)
      text_73.frameNStart = frameN;  // exact frame index
      
      text_73.setAutoDraw(true);
    }

    
    // *text_74* updates
    if (t >= 0.0 && text_74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_74.tStart = t;  // (not accounting for frame time here)
      text_74.frameNStart = frameN;  // exact frame index
      
      text_74.setAutoDraw(true);
    }

    
    // *key_resp_30* updates
    if (t >= 0.0 && key_resp_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_30.tStart = t;  // (not accounting for frame time here)
      key_resp_30.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_30.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_30.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_30.clearEvents(); });
    }

    if (key_resp_30.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_30.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_30_allKeys = _key_resp_30_allKeys.concat(theseKeys);
      if (_key_resp_30_allKeys.length > 0) {
        key_resp_30.keys = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].name;  // just the last key pressed
        key_resp_30.rt = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    IntroC_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function IntroC_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'IntroC_2'-------
    IntroC_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_30.keys', key_resp_30.keys);
    if (typeof key_resp_30.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_30.rt', key_resp_30.rt);
        routineTimer.reset();
        }
    
    key_resp_30.stop();
    // the Routine "IntroC_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_33_allKeys;
var Quick_Reminder_MixedComponents;
function Quick_Reminder_MixedRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Quick_Reminder_Mixed'-------
    t = 0;
    Quick_Reminder_MixedClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_33.keys = undefined;
    key_resp_33.rt = undefined;
    _key_resp_33_allKeys = [];
    // keep track of which components have finished
    Quick_Reminder_MixedComponents = [];
    Quick_Reminder_MixedComponents.push(white_background_29);
    Quick_Reminder_MixedComponents.push(text_77);
    Quick_Reminder_MixedComponents.push(key_resp_33);
    Quick_Reminder_MixedComponents.push(text_78);
    
    Quick_Reminder_MixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_Reminder_MixedRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Quick_Reminder_Mixed'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Quick_Reminder_MixedClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_29* updates
    if (t >= 0.0 && white_background_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_29.tStart = t;  // (not accounting for frame time here)
      white_background_29.frameNStart = frameN;  // exact frame index
      
      white_background_29.setAutoDraw(true);
    }

    
    // *text_77* updates
    if (t >= 0.0 && text_77.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_77.tStart = t;  // (not accounting for frame time here)
      text_77.frameNStart = frameN;  // exact frame index
      
      text_77.setAutoDraw(true);
    }

    
    // *key_resp_33* updates
    if (t >= 0.0 && key_resp_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_33.tStart = t;  // (not accounting for frame time here)
      key_resp_33.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_33.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_33.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_33.clearEvents(); });
    }

    if (key_resp_33.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_33.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_33_allKeys = _key_resp_33_allKeys.concat(theseKeys);
      if (_key_resp_33_allKeys.length > 0) {
        key_resp_33.keys = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].name;  // just the last key pressed
        key_resp_33.rt = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_78* updates
    if (t >= 0.0 && text_78.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_78.tStart = t;  // (not accounting for frame time here)
      text_78.frameNStart = frameN;  // exact frame index
      
      text_78.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Quick_Reminder_MixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Quick_Reminder_MixedRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Quick_Reminder_Mixed'-------
    Quick_Reminder_MixedComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_33.keys', key_resp_33.keys);
    if (typeof key_resp_33.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_33.rt', key_resp_33.rt);
        routineTimer.reset();
        }
    
    key_resp_33.stop();
    // the Routine "Quick_Reminder_Mixed" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_35_allKeys;
var Practice_mixedComponents;
function Practice_mixedRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_mixed'-------
    t = 0;
    Practice_mixedClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_35.keys = undefined;
    key_resp_35.rt = undefined;
    _key_resp_35_allKeys = [];
    // keep track of which components have finished
    Practice_mixedComponents = [];
    Practice_mixedComponents.push(white_background_2);
    Practice_mixedComponents.push(text_79);
    Practice_mixedComponents.push(key_resp_35);
    Practice_mixedComponents.push(text_80);
    
    Practice_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_mixedRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_mixed'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_mixedClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_2* updates
    if (t >= 0.0 && white_background_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_2.tStart = t;  // (not accounting for frame time here)
      white_background_2.frameNStart = frameN;  // exact frame index
      
      white_background_2.setAutoDraw(true);
    }

    
    // *text_79* updates
    if (t >= 0.0 && text_79.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_79.tStart = t;  // (not accounting for frame time here)
      text_79.frameNStart = frameN;  // exact frame index
      
      text_79.setAutoDraw(true);
    }

    
    // *key_resp_35* updates
    if (t >= 0.0 && key_resp_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_35.tStart = t;  // (not accounting for frame time here)
      key_resp_35.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_35.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_35.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_35.clearEvents(); });
    }

    if (key_resp_35.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_35.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_35_allKeys = _key_resp_35_allKeys.concat(theseKeys);
      if (_key_resp_35_allKeys.length > 0) {
        key_resp_35.keys = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].name;  // just the last key pressed
        key_resp_35.rt = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_80* updates
    if (t >= 0.0 && text_80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_80.tStart = t;  // (not accounting for frame time here)
      text_80.frameNStart = frameN;  // exact frame index
      
      text_80.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_mixedRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_mixed'-------
    Practice_mixedComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_35.keys', key_resp_35.keys);
    if (typeof key_resp_35.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_35.rt', key_resp_35.rt);
        routineTimer.reset();
        }
    
    key_resp_35.stop();
    // the Routine "Practice_mixed" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_36_allKeys;
var Practice_trial_mixedComponents;
function Practice_trial_mixedRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_mixed'-------
    t = 0;
    Practice_trial_mixedClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_9.setImage(Hearts_Flowers);
    key_resp_36.keys = undefined;
    key_resp_36.rt = undefined;
    _key_resp_36_allKeys = [];
    var msg_mixed01;
    var color_msg_mixed01;
    // keep track of which components have finished
    Practice_trial_mixedComponents = [];
    Practice_trial_mixedComponents.push(white_background_15);
    Practice_trial_mixedComponents.push(text_81);
    Practice_trial_mixedComponents.push(text_82);
    Practice_trial_mixedComponents.push(image_9);
    Practice_trial_mixedComponents.push(text_83);
    Practice_trial_mixedComponents.push(key_resp_36);
    
    Practice_trial_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_mixedRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_mixed'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_mixedClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_15* updates
    if (t >= 0.0 && white_background_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_15.tStart = t;  // (not accounting for frame time here)
      white_background_15.frameNStart = frameN;  // exact frame index
      
      white_background_15.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_15.status === PsychoJS.Status.STARTED || white_background_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_15.setAutoDraw(false);
    }
    
    // *text_81* updates
    if (t >= 0.0 && text_81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_81.tStart = t;  // (not accounting for frame time here)
      text_81.frameNStart = frameN;  // exact frame index
      
      text_81.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_81.status === PsychoJS.Status.STARTED || text_81.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_81.setAutoDraw(false);
    }
    
    // *text_82* updates
    if (t >= 0.5 && text_82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_82.tStart = t;  // (not accounting for frame time here)
      text_82.frameNStart = frameN;  // exact frame index
      
      text_82.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_82.status === PsychoJS.Status.STARTED || text_82.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_82.setAutoDraw(false);
    }
    
    // *image_9* updates
    if (t >= 1.0 && image_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_9.tStart = t;  // (not accounting for frame time here)
      image_9.frameNStart = frameN;  // exact frame index
      
      image_9.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_9.status === PsychoJS.Status.STARTED || image_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_9.setAutoDraw(false);
    }
    
    // *text_83* updates
    if (t >= 1.75 && text_83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_83.tStart = t;  // (not accounting for frame time here)
      text_83.frameNStart = frameN;  // exact frame index
      
      text_83.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_83.status === PsychoJS.Status.STARTED || text_83.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_83.setAutoDraw(false);
    }
    
    // *key_resp_36* updates
    if (t >= 1.0 && key_resp_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_36.tStart = t;  // (not accounting for frame time here)
      key_resp_36.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_36.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_36.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_36.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_36.status === PsychoJS.Status.STARTED || key_resp_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_36.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_36.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_36.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_36_allKeys = _key_resp_36_allKeys.concat(theseKeys);
      if (_key_resp_36_allKeys.length > 0) {
        key_resp_36.keys = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].name;  // just the last key pressed
        key_resp_36.rt = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_36.keys == corAns) {
            key_resp_36.corr = 1;
        } else {
            key_resp_36.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var msg_mixed01;
var color_msg_mixed01;
function Practice_trial_mixedRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_mixed'-------
    Practice_trial_mixedComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_36.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_36.corr = 1;  // correct non-response
      } else {
         key_resp_36.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_36.keys', key_resp_36.keys);
    psychoJS.experiment.addData('key_resp_36.corr', key_resp_36.corr);
    if (typeof key_resp_36.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_36.rt', key_resp_36.rt);
        routineTimer.reset();
        }
    
    key_resp_36.stop();
      if (key_resp_36.keys === undefined) {
          msg_mixed01 = 'No response'
          color_msg_mixed01 = 'black'
          } else {
          if (key_resp_36.corr > 0){
              msg_mixed01 = 'Correct'
              color_msg_mixed01 = 'green'
          } else {
              msg_mixed01 = 'Incorrect'
              color_msg_mixed01 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_mixed_1Components;
function feedback_hf_mixed_1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_mixed_1'-------
    t = 0;
    feedback_hf_mixed_1Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_110.setColor(new util.Color(color_msg_mixed01));
    text_110.setText(msg_mixed01);
    // keep track of which components have finished
    feedback_hf_mixed_1Components = [];
    feedback_hf_mixed_1Components.push(white_background_39);
    feedback_hf_mixed_1Components.push(text_110);
    
    feedback_hf_mixed_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_mixed_1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_mixed_1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_mixed_1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_39* updates
    if (t >= 0.0 && white_background_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_39.tStart = t;  // (not accounting for frame time here)
      white_background_39.frameNStart = frameN;  // exact frame index
      
      white_background_39.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_39.status === PsychoJS.Status.STARTED || white_background_39.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_39.setAutoDraw(false);
    }
    
    // *text_110* updates
    if (t >= 0.0 && text_110.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_110.tStart = t;  // (not accounting for frame time here)
      text_110.frameNStart = frameN;  // exact frame index
      
      text_110.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_110.status === PsychoJS.Status.STARTED || text_110.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_110.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_mixed_1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_mixed_1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_mixed_1'-------
    feedback_hf_mixed_1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_39_allKeys;
var nCorrhf03;
var reminder_mixedComponents;
function reminder_mixedRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'reminder_mixed'-------
    t = 0;
    reminder_mixedClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_39.keys = undefined;
    key_resp_39.rt = undefined;
    _key_resp_39_allKeys = [];
    nCorrhf03 = 0;
    console.log("hf_mixed03")
    console.log(nCorrhf03)
      for (eachResp=0; eachResp<psychoJS.experiment._trialsData.length; eachResp++){
        if ('key_resp_36.corr' in psychoJS.experiment._trialsData[eachResp]) {
        nCorrhf03 += psychoJS.experiment._trialsData[eachResp]['key_resp_36.corr'];
        }
      }
    
    
    
    // keep track of which components have finished
    reminder_mixedComponents = [];
    reminder_mixedComponents.push(white_background_43);
    reminder_mixedComponents.push(text_106);
    reminder_mixedComponents.push(text_107);
    reminder_mixedComponents.push(key_resp_39);
    
    reminder_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function reminder_mixedRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'reminder_mixed'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = reminder_mixedClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_43* updates
    if (t >= 0.0 && white_background_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_43.tStart = t;  // (not accounting for frame time here)
      white_background_43.frameNStart = frameN;  // exact frame index
      
      white_background_43.setAutoDraw(true);
    }

    
    // *text_106* updates
    if (t >= 0.0 && text_106.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_106.tStart = t;  // (not accounting for frame time here)
      text_106.frameNStart = frameN;  // exact frame index
      
      text_106.setAutoDraw(true);
    }

    
    // *text_107* updates
    if (t >= 0.0 && text_107.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_107.tStart = t;  // (not accounting for frame time here)
      text_107.frameNStart = frameN;  // exact frame index
      
      text_107.setAutoDraw(true);
    }

    
    // *key_resp_39* updates
    if (t >= 0.0 && key_resp_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_39.tStart = t;  // (not accounting for frame time here)
      key_resp_39.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_39.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_39.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_39.clearEvents(); });
    }

    if (key_resp_39.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_39.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_39_allKeys = _key_resp_39_allKeys.concat(theseKeys);
      if (_key_resp_39_allKeys.length > 0) {
        key_resp_39.keys = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].name;  // just the last key pressed
        key_resp_39.rt = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    console.log("hf_mixed03")
    console.log(nCorrhf03)
    if (nCorrhf03 > 5) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } 
    else if (key_resp_39.keys === 'space') {
            continueRoutine = false;
            }
    else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    reminder_mixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function reminder_mixedRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'reminder_mixed'-------
    reminder_mixedComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_39.keys', key_resp_39.keys);
    if (typeof key_resp_39.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_39.rt', key_resp_39.rt);
        routineTimer.reset();
        }
    
    key_resp_39.stop();
    // the Routine "reminder_mixed" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_40_allKeys;
var Practice_trial_mixed_2Components;
function Practice_trial_mixed_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Practice_trial_mixed_2'-------
    t = 0;
    Practice_trial_mixed_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_15.setImage(Hearts_Flowers);
    key_resp_40.keys = undefined;
    key_resp_40.rt = undefined;
    _key_resp_40_allKeys = [];
    var color_msg_mixed02;
    var msg_mixed02;
    
    
    // keep track of which components have finished
    Practice_trial_mixed_2Components = [];
    Practice_trial_mixed_2Components.push(white_background_36);
    Practice_trial_mixed_2Components.push(text_99);
    Practice_trial_mixed_2Components.push(text_100);
    Practice_trial_mixed_2Components.push(image_15);
    Practice_trial_mixed_2Components.push(text_101);
    Practice_trial_mixed_2Components.push(key_resp_40);
    
    Practice_trial_mixed_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Practice_trial_mixed_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Practice_trial_mixed_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Practice_trial_mixed_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_36* updates
    if (t >= 0.0 && white_background_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_36.tStart = t;  // (not accounting for frame time here)
      white_background_36.frameNStart = frameN;  // exact frame index
      
      white_background_36.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_36.status === PsychoJS.Status.STARTED || white_background_36.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_36.setAutoDraw(false);
    }
    
    // *text_99* updates
    if (t >= 0.0 && text_99.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_99.tStart = t;  // (not accounting for frame time here)
      text_99.frameNStart = frameN;  // exact frame index
      
      text_99.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_99.status === PsychoJS.Status.STARTED || text_99.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_99.setAutoDraw(false);
    }
    
    // *text_100* updates
    if (t >= 0.5 && text_100.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_100.tStart = t;  // (not accounting for frame time here)
      text_100.frameNStart = frameN;  // exact frame index
      
      text_100.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_100.status === PsychoJS.Status.STARTED || text_100.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_100.setAutoDraw(false);
    }
    
    // *image_15* updates
    if (t >= 1.0 && image_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_15.tStart = t;  // (not accounting for frame time here)
      image_15.frameNStart = frameN;  // exact frame index
      
      image_15.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_15.status === PsychoJS.Status.STARTED || image_15.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_15.setAutoDraw(false);
    }
    
    // *text_101* updates
    if (t >= 1.75 && text_101.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_101.tStart = t;  // (not accounting for frame time here)
      text_101.frameNStart = frameN;  // exact frame index
      
      text_101.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_101.status === PsychoJS.Status.STARTED || text_101.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_101.setAutoDraw(false);
    }
    
    // *key_resp_40* updates
    if (t >= 1.0 && key_resp_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_40.tStart = t;  // (not accounting for frame time here)
      key_resp_40.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_40.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_40.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_40.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_40.status === PsychoJS.Status.STARTED || key_resp_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_40.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_40.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_40.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_40_allKeys = _key_resp_40_allKeys.concat(theseKeys);
      if (_key_resp_40_allKeys.length > 0) {
        key_resp_40.keys = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].name;  // just the last key pressed
        key_resp_40.rt = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_40.keys == corAns) {
            key_resp_40.corr = 1;
        } else {
            key_resp_40.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    console.log("hf_mixed03")
    console.log(nCorrhf03)
    if (nCorrhf03 > 5) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Practice_trial_mixed_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var msg_mixed02;
var color_msg_mixed02;
function Practice_trial_mixed_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Practice_trial_mixed_2'-------
    Practice_trial_mixed_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_40.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_40.corr = 1;  // correct non-response
      } else {
         key_resp_40.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_40.keys', key_resp_40.keys);
    psychoJS.experiment.addData('key_resp_40.corr', key_resp_40.corr);
    if (typeof key_resp_40.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_40.rt', key_resp_40.rt);
        routineTimer.reset();
        }
    
    key_resp_40.stop();
      if (key_resp_40.keys === undefined) {
          msg_mixed02 = 'No response'
          color_msg_mixed02 = 'black'
          } else {
          if (key_resp_40.corr > 0){
              msg_mixed02 = 'Correct'
              color_msg_mixed02 = 'green'
          } else {
              msg_mixed02 = 'Incorrect'
              color_msg_mixed02 = 'red'
          }
          }
    return Scheduler.Event.NEXT;
  };
}


var feedback_hf_mixed_2Components;
function feedback_hf_mixed_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_hf_mixed_2'-------
    t = 0;
    feedback_hf_mixed_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.500000);
    // update component parameters for each repeat
    text_109.setColor(new util.Color(color_msg_mixed02));
    text_109.setText(msg_mixed02);
    console.log("hf_mixed03")
    console.log(nCorrhf03)
    
    // keep track of which components have finished
    feedback_hf_mixed_2Components = [];
    feedback_hf_mixed_2Components.push(white_background_40);
    feedback_hf_mixed_2Components.push(text_109);
    
    feedback_hf_mixed_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_mixed_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_hf_mixed_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_hf_mixed_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_40* updates
    if (t >= 0.0 && white_background_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_40.tStart = t;  // (not accounting for frame time here)
      white_background_40.frameNStart = frameN;  // exact frame index
      
      white_background_40.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_40.status === PsychoJS.Status.STARTED || white_background_40.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_40.setAutoDraw(false);
    }
    
    // *text_109* updates
    if (t >= 0.0 && text_109.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_109.tStart = t;  // (not accounting for frame time here)
      text_109.frameNStart = frameN;  // exact frame index
      
      text_109.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_109.status === PsychoJS.Status.STARTED || text_109.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_109.setAutoDraw(false);
    }
    if (nCorrhf03 > 5) {
        console.log("true")
        continueRoutine = false; // until we're told otherwise
        } else {
            console.log("false")
            continueRoutine = true;
            }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_hf_mixed_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_hf_mixed_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_hf_mixed_2'-------
    feedback_hf_mixed_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_41_allKeys;
var Ready3Components;
function Ready3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Ready3'-------
    t = 0;
    Ready3Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_41.keys = undefined;
    key_resp_41.rt = undefined;
    _key_resp_41_allKeys = [];
    // keep track of which components have finished
    Ready3Components = [];
    Ready3Components.push(white_background_4);
    Ready3Components.push(text_84);
    Ready3Components.push(key_resp_41);
    Ready3Components.push(text_85);
    
    Ready3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Ready3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Ready3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Ready3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_4* updates
    if (t >= 0.0 && white_background_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_4.tStart = t;  // (not accounting for frame time here)
      white_background_4.frameNStart = frameN;  // exact frame index
      
      white_background_4.setAutoDraw(true);
    }

    
    // *text_84* updates
    if (t >= 0.0 && text_84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_84.tStart = t;  // (not accounting for frame time here)
      text_84.frameNStart = frameN;  // exact frame index
      
      text_84.setAutoDraw(true);
    }

    
    // *key_resp_41* updates
    if (t >= 0.0 && key_resp_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_41.tStart = t;  // (not accounting for frame time here)
      key_resp_41.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_41.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_41.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_41.clearEvents(); });
    }

    if (key_resp_41.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_41.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_41_allKeys = _key_resp_41_allKeys.concat(theseKeys);
      if (_key_resp_41_allKeys.length > 0) {
        key_resp_41.keys = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].name;  // just the last key pressed
        key_resp_41.rt = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_85* updates
    if (t >= 0.0 && text_85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_85.tStart = t;  // (not accounting for frame time here)
      text_85.frameNStart = frameN;  // exact frame index
      
      text_85.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Ready3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Ready3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Ready3'-------
    Ready3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_41.keys', key_resp_41.keys);
    if (typeof key_resp_41.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_41.rt', key_resp_41.rt);
        routineTimer.reset();
        }
    
    key_resp_41.stop();
    // the Routine "Ready3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_42_allKeys;
var mixed_firstComponents;
function mixed_firstRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'mixed_first'-------
    t = 0;
    mixed_firstClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    key_resp_42.keys = undefined;
    key_resp_42.rt = undefined;
    _key_resp_42_allKeys = [];
    // keep track of which components have finished
    mixed_firstComponents = [];
    mixed_firstComponents.push(white_background_9);
    mixed_firstComponents.push(text_86);
    mixed_firstComponents.push(text_87);
    mixed_firstComponents.push(image_10);
    mixed_firstComponents.push(text_88);
    mixed_firstComponents.push(key_resp_42);
    
    mixed_firstComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function mixed_firstRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'mixed_first'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = mixed_firstClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_9* updates
    if (t >= 0.0 && white_background_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_9.tStart = t;  // (not accounting for frame time here)
      white_background_9.frameNStart = frameN;  // exact frame index
      
      white_background_9.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_9.status === PsychoJS.Status.STARTED || white_background_9.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_9.setAutoDraw(false);
    }
    
    // *text_86* updates
    if (t >= 0.0 && text_86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_86.tStart = t;  // (not accounting for frame time here)
      text_86.frameNStart = frameN;  // exact frame index
      
      text_86.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_86.status === PsychoJS.Status.STARTED || text_86.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_86.setAutoDraw(false);
    }
    
    // *text_87* updates
    if (t >= 0.5 && text_87.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_87.tStart = t;  // (not accounting for frame time here)
      text_87.frameNStart = frameN;  // exact frame index
      
      text_87.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_87.status === PsychoJS.Status.STARTED || text_87.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_87.setAutoDraw(false);
    }
    
    // *image_10* updates
    if (t >= 1.0 && image_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_10.tStart = t;  // (not accounting for frame time here)
      image_10.frameNStart = frameN;  // exact frame index
      
      image_10.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_10.status === PsychoJS.Status.STARTED || image_10.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_10.setAutoDraw(false);
    }
    
    // *text_88* updates
    if (t >= 1.75 && text_88.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_88.tStart = t;  // (not accounting for frame time here)
      text_88.frameNStart = frameN;  // exact frame index
      
      text_88.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_88.status === PsychoJS.Status.STARTED || text_88.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_88.setAutoDraw(false);
    }
    
    // *key_resp_42* updates
    if (t >= 1.0 && key_resp_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_42.tStart = t;  // (not accounting for frame time here)
      key_resp_42.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_42.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_42.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_42.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_42.status === PsychoJS.Status.STARTED || key_resp_42.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_42.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_42.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_42.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_42_allKeys = _key_resp_42_allKeys.concat(theseKeys);
      if (_key_resp_42_allKeys.length > 0) {
        key_resp_42.keys = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].name;  // just the last key pressed
        key_resp_42.rt = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_42.keys == "'m'") {
            key_resp_42.corr = 1;
        } else {
            key_resp_42.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    mixed_firstComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function mixed_firstRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'mixed_first'-------
    mixed_firstComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_42.keys === undefined) {
      if (['None','none',undefined].includes("'m'")) {
         key_resp_42.corr = 1;  // correct non-response
      } else {
         key_resp_42.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_42.keys', key_resp_42.keys);
    psychoJS.experiment.addData('key_resp_42.corr', key_resp_42.corr);
    if (typeof key_resp_42.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_42.rt', key_resp_42.rt);
        routineTimer.reset();
        }
    
    key_resp_42.stop();
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_43_allKeys;
var MixedComponents;
function MixedRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Mixed'-------
    t = 0;
    MixedClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    image_2.setImage(Hearts_Flowers);
    key_resp_43.keys = undefined;
    key_resp_43.rt = undefined;
    _key_resp_43_allKeys = [];
    // keep track of which components have finished
    MixedComponents = [];
    MixedComponents.push(white_background_5);
    MixedComponents.push(text_89);
    MixedComponents.push(text_90);
    MixedComponents.push(image_2);
    MixedComponents.push(text_91);
    MixedComponents.push(key_resp_43);
    
    MixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function MixedRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Mixed'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = MixedClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *white_background_5* updates
    if (t >= 0.0 && white_background_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      white_background_5.tStart = t;  // (not accounting for frame time here)
      white_background_5.frameNStart = frameN;  // exact frame index
      
      white_background_5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.25 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((white_background_5.status === PsychoJS.Status.STARTED || white_background_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      white_background_5.setAutoDraw(false);
    }
    
    // *text_89* updates
    if (t >= 0.0 && text_89.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_89.tStart = t;  // (not accounting for frame time here)
      text_89.frameNStart = frameN;  // exact frame index
      
      text_89.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_89.status === PsychoJS.Status.STARTED || text_89.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_89.setAutoDraw(false);
    }
    
    // *text_90* updates
    if (t >= 0.5 && text_90.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_90.tStart = t;  // (not accounting for frame time here)
      text_90.frameNStart = frameN;  // exact frame index
      
      text_90.setAutoDraw(true);
    }

    frameRemains = 0.5 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_90.status === PsychoJS.Status.STARTED || text_90.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_90.setAutoDraw(false);
    }
    
    // *image_2* updates
    if (t >= 1.0 && image_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_2.tStart = t;  // (not accounting for frame time here)
      image_2.frameNStart = frameN;  // exact frame index
      
      image_2.setAutoDraw(true);
    }

    frameRemains = 1.0 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_2.status === PsychoJS.Status.STARTED || image_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_2.setAutoDraw(false);
    }
    
    // *text_91* updates
    if (t >= 1.75 && text_91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_91.tStart = t;  // (not accounting for frame time here)
      text_91.frameNStart = frameN;  // exact frame index
      
      text_91.setAutoDraw(true);
    }

    frameRemains = 1.75 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_91.status === PsychoJS.Status.STARTED || text_91.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_91.setAutoDraw(false);
    }
    
    // *key_resp_43* updates
    if (t >= 1.0 && key_resp_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_43.tStart = t;  // (not accounting for frame time here)
      key_resp_43.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_43.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_43.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_43.clearEvents(); });
    }

    frameRemains = 1.0 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((key_resp_43.status === PsychoJS.Status.STARTED || key_resp_43.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      key_resp_43.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_43.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_43.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _key_resp_43_allKeys = _key_resp_43_allKeys.concat(theseKeys);
      if (_key_resp_43_allKeys.length > 0) {
        key_resp_43.keys = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].name;  // just the last key pressed
        key_resp_43.rt = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_43.keys == corAns) {
            key_resp_43.corr = 1;
        } else {
            key_resp_43.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    MixedComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function MixedRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Mixed'-------
    MixedComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // was no response the correct answer?!
    if (key_resp_43.keys === undefined) {
      if (['None','none',undefined].includes(corAns)) {
         key_resp_43.corr = 1;  // correct non-response
      } else {
         key_resp_43.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('key_resp_43.keys', key_resp_43.keys);
    psychoJS.experiment.addData('key_resp_43.corr', key_resp_43.corr);
    if (typeof key_resp_43.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_43.rt', key_resp_43.rt);
        routineTimer.reset();
        }
    
    key_resp_43.stop();
    return Scheduler.Event.NEXT;
  };
}


var Thank_YouComponents;
function Thank_YouRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Thank_You'-------
    t = 0;
    Thank_YouClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    Thank_YouComponents = [];
    Thank_YouComponents.push(text_92);
    Thank_YouComponents.push(text_111);
    
    Thank_YouComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Thank_YouRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Thank_You'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Thank_YouClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_92* updates
    if (t >= 0.0 && text_92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_92.tStart = t;  // (not accounting for frame time here)
      text_92.frameNStart = frameN;  // exact frame index
      
      text_92.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_92.status === PsychoJS.Status.STARTED || text_92.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_92.setAutoDraw(false);
    }
    
    // *text_111* updates
    if (t >= 0.0 && text_111.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_111.tStart = t;  // (not accounting for frame time here)
      text_111.frameNStart = frameN;  // exact frame index
      
      text_111.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_111.status === PsychoJS.Status.STARTED || text_111.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_111.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Thank_YouComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Thank_YouRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Thank_You'-------
    Thank_YouComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _oe_welcome_key_resp_allKeys;
var oe_welcomeComponents;
function oe_welcomeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_welcome'-------
    t = 0;
    oe_welcomeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_welcome_key_resp.keys = undefined;
    oe_welcome_key_resp.rt = undefined;
    _oe_welcome_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_welcomeComponents = [];
    oe_welcomeComponents.push(oe_welcome_txt_top);
    oe_welcomeComponents.push(oe_welcome_txt_bot);
    oe_welcomeComponents.push(oe_welcome_key_resp);
    
    oe_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_welcomeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_welcome'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_welcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_welcome_txt_top* updates
    if (t >= 0.0 && oe_welcome_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_welcome_txt_top.tStart = t;  // (not accounting for frame time here)
      oe_welcome_txt_top.frameNStart = frameN;  // exact frame index
      
      oe_welcome_txt_top.setAutoDraw(true);
    }

    
    // *oe_welcome_txt_bot* updates
    if (t >= 0.0 && oe_welcome_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_welcome_txt_bot.tStart = t;  // (not accounting for frame time here)
      oe_welcome_txt_bot.frameNStart = frameN;  // exact frame index
      
      oe_welcome_txt_bot.setAutoDraw(true);
    }

    
    // *oe_welcome_key_resp* updates
    if (t >= 0.0 && oe_welcome_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_welcome_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_welcome_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_welcome_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_welcome_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_welcome_key_resp.clearEvents(); });
    }

    if (oe_welcome_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_welcome_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _oe_welcome_key_resp_allKeys = _oe_welcome_key_resp_allKeys.concat(theseKeys);
      if (_oe_welcome_key_resp_allKeys.length > 0) {
        oe_welcome_key_resp.keys = _oe_welcome_key_resp_allKeys[_oe_welcome_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_welcome_key_resp.rt = _oe_welcome_key_resp_allKeys[_oe_welcome_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_welcomeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_welcome'-------
    oe_welcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_welcome" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _even_intro_key_resp_allKeys;
var even_introComponents;
function even_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'even_intro'-------
    t = 0;
    even_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    even_intro_key_resp.keys = undefined;
    even_intro_key_resp.rt = undefined;
    _even_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    even_introComponents = [];
    even_introComponents.push(even_intro_txt_top);
    even_introComponents.push(even_intro_txt_bot);
    even_introComponents.push(even_intro_key_resp);
    
    even_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function even_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'even_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = even_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *even_intro_txt_top* updates
    if (t >= 0.0 && even_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      even_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      even_intro_txt_top.setAutoDraw(true);
    }

    
    // *even_intro_txt_bot* updates
    if (t >= 0.0 && even_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      even_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      even_intro_txt_bot.setAutoDraw(true);
    }

    
    // *even_intro_key_resp* updates
    if (t >= 0.0 && even_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      even_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { even_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { even_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { even_intro_key_resp.clearEvents(); });
    }

    if (even_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = even_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _even_intro_key_resp_allKeys = _even_intro_key_resp_allKeys.concat(theseKeys);
      if (_even_intro_key_resp_allKeys.length > 0) {
        even_intro_key_resp.keys = _even_intro_key_resp_allKeys[_even_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        even_intro_key_resp.rt = _even_intro_key_resp_allKeys[_even_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    even_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function even_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'even_intro'-------
    even_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "even_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _even_eg1_key_resp_allKeys;
var even_eg1Components;
function even_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'even_eg1'-------
    t = 0;
    even_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    even_eg1_key_resp.keys = undefined;
    even_eg1_key_resp.rt = undefined;
    _even_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    even_eg1Components = [];
    even_eg1Components.push(even_eg1_txt_top);
    even_eg1Components.push(even_eg1_txt_num);
    even_eg1Components.push(even_eg1_txt_bot);
    even_eg1Components.push(even_eg1_key_resp);
    
    even_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function even_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'even_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = even_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *even_eg1_txt_top* updates
    if (t >= 0.0 && even_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      even_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      even_eg1_txt_top.setAutoDraw(true);
    }

    
    // *even_eg1_txt_num* updates
    if (t >= 0.0 && even_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      even_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      even_eg1_txt_num.setAutoDraw(true);
    }

    
    // *even_eg1_txt_bot* updates
    if (t >= 0.0 && even_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      even_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      even_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *even_eg1_key_resp* updates
    if (t >= 0.0 && even_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      even_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { even_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { even_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { even_eg1_key_resp.clearEvents(); });
    }

    if (even_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = even_eg1_key_resp.getKeys({keyList: ['z'], waitRelease: false});
      _even_eg1_key_resp_allKeys = _even_eg1_key_resp_allKeys.concat(theseKeys);
      if (_even_eg1_key_resp_allKeys.length > 0) {
        even_eg1_key_resp.keys = _even_eg1_key_resp_allKeys[_even_eg1_key_resp_allKeys.length - 1].name;  // just the last key pressed
        even_eg1_key_resp.rt = _even_eg1_key_resp_allKeys[_even_eg1_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    even_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function even_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'even_eg1'-------
    even_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "even_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _even_eg2_key_resp_allKeys;
var even_eg2Components;
function even_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'even_eg2'-------
    t = 0;
    even_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    even_eg2_key_resp.keys = undefined;
    even_eg2_key_resp.rt = undefined;
    _even_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    even_eg2Components = [];
    even_eg2Components.push(even_eg2_txt_top);
    even_eg2Components.push(even_eg2_txt_num);
    even_eg2Components.push(even_eg2_txt_bot);
    even_eg2Components.push(even_eg2_key_resp);
    
    even_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function even_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'even_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = even_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *even_eg2_txt_top* updates
    if (t >= 0.0 && even_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      even_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      even_eg2_txt_top.setAutoDraw(true);
    }

    
    // *even_eg2_txt_num* updates
    if (t >= 0.0 && even_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      even_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      even_eg2_txt_num.setAutoDraw(true);
    }

    
    // *even_eg2_txt_bot* updates
    if (t >= 0.0 && even_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      even_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      even_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *even_eg2_key_resp* updates
    if (t >= 0.0 && even_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      even_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { even_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { even_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { even_eg2_key_resp.clearEvents(); });
    }

    if (even_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = even_eg2_key_resp.getKeys({keyList: ['m'], waitRelease: false});
      _even_eg2_key_resp_allKeys = _even_eg2_key_resp_allKeys.concat(theseKeys);
      if (_even_eg2_key_resp_allKeys.length > 0) {
        even_eg2_key_resp.keys = _even_eg2_key_resp_allKeys[_even_eg2_key_resp_allKeys.length - 1].name;  // just the last key pressed
        even_eg2_key_resp.rt = _even_eg2_key_resp_allKeys[_even_eg2_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    even_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function even_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'even_eg2'-------
    even_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "even_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_speed_instr_key_resp_allKeys;
var oe_speed_instrComponents;
function oe_speed_instrRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_speed_instr'-------
    t = 0;
    oe_speed_instrClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_speed_instr_key_resp.keys = undefined;
    oe_speed_instr_key_resp.rt = undefined;
    _oe_speed_instr_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_speed_instrComponents = [];
    oe_speed_instrComponents.push(oe_speed_instr_top);
    oe_speed_instrComponents.push(oe_speed_instr_bot);
    oe_speed_instrComponents.push(oe_speed_instr_key_resp);
    
    oe_speed_instrComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_speed_instrRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_speed_instr'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_speed_instrClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_speed_instr_top* updates
    if (t >= 0.0 && oe_speed_instr_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_speed_instr_top.tStart = t;  // (not accounting for frame time here)
      oe_speed_instr_top.frameNStart = frameN;  // exact frame index
      
      oe_speed_instr_top.setAutoDraw(true);
    }

    
    // *oe_speed_instr_bot* updates
    if (t >= 0.0 && oe_speed_instr_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_speed_instr_bot.tStart = t;  // (not accounting for frame time here)
      oe_speed_instr_bot.frameNStart = frameN;  // exact frame index
      
      oe_speed_instr_bot.setAutoDraw(true);
    }

    
    // *oe_speed_instr_key_resp* updates
    if (t >= 0.0 && oe_speed_instr_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_speed_instr_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_speed_instr_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_speed_instr_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_speed_instr_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_speed_instr_key_resp.clearEvents(); });
    }

    if (oe_speed_instr_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_speed_instr_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _oe_speed_instr_key_resp_allKeys = _oe_speed_instr_key_resp_allKeys.concat(theseKeys);
      if (_oe_speed_instr_key_resp_allKeys.length > 0) {
        oe_speed_instr_key_resp.keys = _oe_speed_instr_key_resp_allKeys[_oe_speed_instr_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_speed_instr_key_resp.rt = _oe_speed_instr_key_resp_allKeys[_oe_speed_instr_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_speed_instrComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_speed_instrRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_speed_instr'-------
    oe_speed_instrComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('oe_speed_instr_key_resp.keys', oe_speed_instr_key_resp.keys);
    if (typeof oe_speed_instr_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('oe_speed_instr_key_resp.rt', oe_speed_instr_key_resp.rt);
        routineTimer.reset();
        }
    
    oe_speed_instr_key_resp.stop();
    // the Routine "oe_speed_instr" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_train_start_key_resp_allKeys;
var oe_train_startComponents;
function oe_train_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_train_start'-------
    t = 0;
    oe_train_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_train_start_key_resp.keys = undefined;
    oe_train_start_key_resp.rt = undefined;
    _oe_train_start_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_train_startComponents = [];
    oe_train_startComponents.push(oe_train_start_txt);
    oe_train_startComponents.push(oe_train_start_key_resp);
    
    oe_train_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_train_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_train_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_train_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_train_start_txt* updates
    if (t >= 0.0 && oe_train_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_train_start_txt.tStart = t;  // (not accounting for frame time here)
      oe_train_start_txt.frameNStart = frameN;  // exact frame index
      
      oe_train_start_txt.setAutoDraw(true);
    }

    
    // *oe_train_start_key_resp* updates
    if (t >= 0.0 && oe_train_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_train_start_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_train_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_train_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_train_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_train_start_key_resp.clearEvents(); });
    }

    if (oe_train_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_train_start_key_resp.getKeys({keyList: ['z', 'm'], waitRelease: false});
      _oe_train_start_key_resp_allKeys = _oe_train_start_key_resp_allKeys.concat(theseKeys);
      if (_oe_train_start_key_resp_allKeys.length > 0) {
        oe_train_start_key_resp.keys = _oe_train_start_key_resp_allKeys[_oe_train_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_train_start_key_resp.rt = _oe_train_start_key_resp_allKeys[_oe_train_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_train_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_train_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_train_start'-------
    oe_train_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_train_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_trial_key_resp_allKeys;
var oe_trialComponents;
function oe_trialRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_trial'-------
    t = 0;
    oe_trialClock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    oe_trial_txt_num.setPos(oe_position);
    oe_trial_txt_num.setText(oe_number);
    oe_trial_key_resp.keys = undefined;
    oe_trial_key_resp.rt = undefined;
    _oe_trial_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_trialComponents = [];
    oe_trialComponents.push(oe_trial_fixation);
    oe_trialComponents.push(oe_trial_txt_num);
    oe_trialComponents.push(oe_trial_key_resp);
    
    oe_trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_trialRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_trial'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_trial_fixation* updates
    if (t >= 0.0 && oe_trial_fixation.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_trial_fixation.tStart = t;  // (not accounting for frame time here)
      oe_trial_fixation.frameNStart = frameN;  // exact frame index
      
      oe_trial_fixation.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((oe_trial_fixation.status === PsychoJS.Status.STARTED || oe_trial_fixation.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      oe_trial_fixation.setAutoDraw(false);
    }
    
    // *oe_trial_txt_num* updates
    if (t >= 1 && oe_trial_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_trial_txt_num.tStart = t;  // (not accounting for frame time here)
      oe_trial_txt_num.frameNStart = frameN;  // exact frame index
      
      oe_trial_txt_num.setAutoDraw(true);
    }

    frameRemains = 1 + 0.75 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((oe_trial_txt_num.status === PsychoJS.Status.STARTED || oe_trial_txt_num.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      oe_trial_txt_num.setAutoDraw(false);
    }
    
    // *oe_trial_key_resp* updates
    if (t >= 1 && oe_trial_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_trial_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_trial_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_trial_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_trial_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_trial_key_resp.clearEvents(); });
    }

    frameRemains = 1 + 1.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((oe_trial_key_resp.status === PsychoJS.Status.STARTED || oe_trial_key_resp.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      oe_trial_key_resp.status = PsychoJS.Status.FINISHED;
  }

    if (oe_trial_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_trial_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _oe_trial_key_resp_allKeys = _oe_trial_key_resp_allKeys.concat(theseKeys);
      if (_oe_trial_key_resp_allKeys.length > 0) {
        oe_trial_key_resp.keys = _oe_trial_key_resp_allKeys[_oe_trial_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_trial_key_resp.rt = _oe_trial_key_resp_allKeys[_oe_trial_key_resp_allKeys.length - 1].rt;
        // was this correct?
        if (oe_trial_key_resp.keys == oe_correct) {
            oe_trial_key_resp.corr = 1;
        } else {
            oe_trial_key_resp.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var oe_feedback_color;
var oe_feedback_message;
function oe_trialRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_trial'-------
    oe_trialComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    if ((oe_trial_key_resp.keys === undefined)) {
        oe_feedback_color = "black";
        oe_feedback_message = "No response";
        if ((oe_trial_key_resp.corr > 0)) {
            oe_feedback_color = "green";
            oe_feedback_message = "Correct";
        } else {
            oe_feedback_color = "red";
            oe_feedback_message = "Incorrect";
        }
    }
    
    // was no response the correct answer?!
    if (oe_trial_key_resp.keys === undefined) {
      if (['None','none',undefined].includes(oe_correct)) {
         oe_trial_key_resp.corr = 1;  // correct non-response
      } else {
         oe_trial_key_resp.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for thisExp (ExperimentHandler)
    psychoJS.experiment.addData('oe_trial_key_resp.keys', oe_trial_key_resp.keys);
    psychoJS.experiment.addData('oe_trial_key_resp.corr', oe_trial_key_resp.corr);
    if (typeof oe_trial_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('oe_trial_key_resp.rt', oe_trial_key_resp.rt);
        routineTimer.reset();
        }
    
    oe_trial_key_resp.stop();
    return Scheduler.Event.NEXT;
  };
}


var oe_feedbackComponents;
function oe_feedbackRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_feedback'-------
    t = 0;
    oe_feedbackClock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    oe_feedback_txt.setColor(new util.Color(oe_feedback_color));
    oe_feedback_txt.setText(oe_feedback_message);
    // keep track of which components have finished
    oe_feedbackComponents = [];
    oe_feedbackComponents.push(oe_feedback_txt);
    
    oe_feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_feedbackRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_feedback'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_feedback_txt* updates
    if (t >= 0.0 && oe_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_feedback_txt.tStart = t;  // (not accounting for frame time here)
      oe_feedback_txt.frameNStart = frameN;  // exact frame index
      
      oe_feedback_txt.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((oe_feedback_txt.status === PsychoJS.Status.STARTED || oe_feedback_txt.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      oe_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_feedbackRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_feedback'-------
    oe_feedbackComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _even_test_start_key_resp_allKeys;
var even_test_startComponents;
function even_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'even_test_start'-------
    t = 0;
    even_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    even_test_start_key_resp.keys = undefined;
    even_test_start_key_resp.rt = undefined;
    _even_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    even_test_startComponents = [];
    even_test_startComponents.push(even_test_start_txt);
    even_test_startComponents.push(even_test_start_key_resp);
    
    even_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function even_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'even_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = even_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *even_test_start_txt* updates
    if (t >= 0.0 && even_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_test_start_txt.tStart = t;  // (not accounting for frame time here)
      even_test_start_txt.frameNStart = frameN;  // exact frame index
      
      even_test_start_txt.setAutoDraw(true);
    }

    
    // *even_test_start_key_resp* updates
    if (t >= 0.0 && even_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      even_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      even_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { even_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { even_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { even_test_start_key_resp.clearEvents(); });
    }

    if (even_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = even_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _even_test_start_key_resp_allKeys = _even_test_start_key_resp_allKeys.concat(theseKeys);
      if (_even_test_start_key_resp_allKeys.length > 0) {
        even_test_start_key_resp.keys = _even_test_start_key_resp_allKeys[_even_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        even_test_start_key_resp.rt = _even_test_start_key_resp_allKeys[_even_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    even_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function even_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'even_test_start'-------
    even_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "even_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _odd_intro_key_resp_allKeys;
var odd_introComponents;
function odd_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'odd_intro'-------
    t = 0;
    odd_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    odd_intro_key_resp.keys = undefined;
    odd_intro_key_resp.rt = undefined;
    _odd_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    odd_introComponents = [];
    odd_introComponents.push(odd_intro_txt_top);
    odd_introComponents.push(odd_intro_txt_bot);
    odd_introComponents.push(odd_intro_key_resp);
    
    odd_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'odd_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = odd_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *odd_intro_txt_top* updates
    if (t >= 0.0 && odd_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      odd_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      odd_intro_txt_top.setAutoDraw(true);
    }

    
    // *odd_intro_txt_bot* updates
    if (t >= 0.0 && odd_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      odd_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      odd_intro_txt_bot.setAutoDraw(true);
    }

    
    // *odd_intro_key_resp* updates
    if (t >= 0.0 && odd_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      odd_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { odd_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { odd_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { odd_intro_key_resp.clearEvents(); });
    }

    if (odd_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = odd_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _odd_intro_key_resp_allKeys = _odd_intro_key_resp_allKeys.concat(theseKeys);
      if (_odd_intro_key_resp_allKeys.length > 0) {
        odd_intro_key_resp.keys = _odd_intro_key_resp_allKeys[_odd_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        odd_intro_key_resp.rt = _odd_intro_key_resp_allKeys[_odd_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    odd_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'odd_intro'-------
    odd_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "odd_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _odd_eg1_key_resp_allKeys;
var odd_eg1Components;
function odd_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'odd_eg1'-------
    t = 0;
    odd_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    odd_eg1_key_resp.keys = undefined;
    odd_eg1_key_resp.rt = undefined;
    _odd_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    odd_eg1Components = [];
    odd_eg1Components.push(odd_eg1_txt_top);
    odd_eg1Components.push(odd_eg1_txt_num);
    odd_eg1Components.push(odd_eg1_txt_bot);
    odd_eg1Components.push(odd_eg1_key_resp);
    
    odd_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'odd_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = odd_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *odd_eg1_txt_top* updates
    if (t >= 0.0 && odd_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      odd_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      odd_eg1_txt_top.setAutoDraw(true);
    }

    
    // *odd_eg1_txt_num* updates
    if (t >= 0.0 && odd_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      odd_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      odd_eg1_txt_num.setAutoDraw(true);
    }

    
    // *odd_eg1_txt_bot* updates
    if (t >= 0.0 && odd_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      odd_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      odd_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *odd_eg1_key_resp* updates
    if (t >= 0.0 && odd_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      odd_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { odd_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { odd_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { odd_eg1_key_resp.clearEvents(); });
    }

    if (odd_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = odd_eg1_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _odd_eg1_key_resp_allKeys = _odd_eg1_key_resp_allKeys.concat(theseKeys);
      if (_odd_eg1_key_resp_allKeys.length > 0) {
        odd_eg1_key_resp.keys = _odd_eg1_key_resp_allKeys[_odd_eg1_key_resp_allKeys.length - 1].name;  // just the last key pressed
        odd_eg1_key_resp.rt = _odd_eg1_key_resp_allKeys[_odd_eg1_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    odd_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'odd_eg1'-------
    odd_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "odd_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _odd_eg2_key_resp_allKeys;
var odd_eg2Components;
function odd_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'odd_eg2'-------
    t = 0;
    odd_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    odd_eg2_key_resp.keys = undefined;
    odd_eg2_key_resp.rt = undefined;
    _odd_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    odd_eg2Components = [];
    odd_eg2Components.push(odd_eg2_txt_top);
    odd_eg2Components.push(odd_eg2_txt_num);
    odd_eg2Components.push(odd_eg2_txt_bot);
    odd_eg2Components.push(odd_eg2_key_resp);
    
    odd_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'odd_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = odd_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *odd_eg2_txt_top* updates
    if (t >= 0.0 && odd_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      odd_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      odd_eg2_txt_top.setAutoDraw(true);
    }

    
    // *odd_eg2_txt_num* updates
    if (t >= 0.0 && odd_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      odd_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      odd_eg2_txt_num.setAutoDraw(true);
    }

    
    // *odd_eg2_txt_bot* updates
    if (t >= 0.0 && odd_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      odd_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      odd_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *odd_eg2_key_resp* updates
    if (t >= 0.0 && odd_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      odd_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { odd_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { odd_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { odd_eg2_key_resp.clearEvents(); });
    }

    if (odd_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = odd_eg2_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _odd_eg2_key_resp_allKeys = _odd_eg2_key_resp_allKeys.concat(theseKeys);
      if (_odd_eg2_key_resp_allKeys.length > 0) {
        odd_eg2_key_resp.keys = _odd_eg2_key_resp_allKeys[_odd_eg2_key_resp_allKeys.length - 1].name;  // just the last key pressed
        odd_eg2_key_resp.rt = _odd_eg2_key_resp_allKeys[_odd_eg2_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    odd_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'odd_eg2'-------
    odd_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "odd_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _odd_test_start_key_resp_allKeys;
var odd_test_startComponents;
function odd_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'odd_test_start'-------
    t = 0;
    odd_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    odd_test_start_key_resp.keys = undefined;
    odd_test_start_key_resp.rt = undefined;
    _odd_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    odd_test_startComponents = [];
    odd_test_startComponents.push(odd_test_start_txt);
    odd_test_startComponents.push(odd_test_start_key_resp);
    
    odd_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'odd_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = odd_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *odd_test_start_txt* updates
    if (t >= 0.0 && odd_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_test_start_txt.tStart = t;  // (not accounting for frame time here)
      odd_test_start_txt.frameNStart = frameN;  // exact frame index
      
      odd_test_start_txt.setAutoDraw(true);
    }

    
    // *odd_test_start_key_resp* updates
    if (t >= 0.0 && odd_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      odd_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      odd_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { odd_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { odd_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { odd_test_start_key_resp.clearEvents(); });
    }

    if (odd_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = odd_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _odd_test_start_key_resp_allKeys = _odd_test_start_key_resp_allKeys.concat(theseKeys);
      if (_odd_test_start_key_resp_allKeys.length > 0) {
        odd_test_start_key_resp.keys = _odd_test_start_key_resp_allKeys[_odd_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        odd_test_start_key_resp.rt = _odd_test_start_key_resp_allKeys[_odd_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    odd_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function odd_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'odd_test_start'-------
    odd_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "odd_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_intro_key_resp_allKeys;
var oe_introComponents;
function oe_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_intro'-------
    t = 0;
    oe_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_intro_key_resp.keys = undefined;
    oe_intro_key_resp.rt = undefined;
    _oe_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_introComponents = [];
    oe_introComponents.push(oe_intro_txt_top);
    oe_introComponents.push(oe_intro_txt_bot);
    oe_introComponents.push(oe_intro_key_resp);
    
    oe_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_intro_txt_top* updates
    if (t >= 0.0 && oe_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      oe_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      oe_intro_txt_top.setAutoDraw(true);
    }

    
    // *oe_intro_txt_bot* updates
    if (t >= 0.0 && oe_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      oe_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      oe_intro_txt_bot.setAutoDraw(true);
    }

    
    // *oe_intro_key_resp* updates
    if (t >= 0.0 && oe_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_intro_key_resp.clearEvents(); });
    }

    if (oe_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _oe_intro_key_resp_allKeys = _oe_intro_key_resp_allKeys.concat(theseKeys);
      if (_oe_intro_key_resp_allKeys.length > 0) {
        oe_intro_key_resp.keys = _oe_intro_key_resp_allKeys[_oe_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_intro_key_resp.rt = _oe_intro_key_resp_allKeys[_oe_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_intro'-------
    oe_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_eg1_key_resp_allKeys;
var oe_eg1Components;
function oe_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_eg1'-------
    t = 0;
    oe_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_eg1_key_resp.keys = undefined;
    oe_eg1_key_resp.rt = undefined;
    _oe_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_eg1Components = [];
    oe_eg1Components.push(oe_eg1_txt_top);
    oe_eg1Components.push(oe_eg1_txt_num);
    oe_eg1Components.push(oe_eg1_txt_bot);
    oe_eg1Components.push(oe_eg1_key_resp);
    
    oe_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_eg1_txt_top* updates
    if (t >= 0.0 && oe_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      oe_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      oe_eg1_txt_top.setAutoDraw(true);
    }

    
    // *oe_eg1_txt_num* updates
    if (t >= 0.0 && oe_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      oe_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      oe_eg1_txt_num.setAutoDraw(true);
    }

    
    // *oe_eg1_txt_bot* updates
    if (t >= 0.0 && oe_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      oe_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      oe_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *oe_eg1_key_resp* updates
    if (t >= 0.0 && oe_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_eg1_key_resp.clearEvents(); });
    }

    if (oe_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_eg1_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _oe_eg1_key_resp_allKeys = _oe_eg1_key_resp_allKeys.concat(theseKeys);
      if (_oe_eg1_key_resp_allKeys.length > 0) {
        oe_eg1_key_resp.keys = _oe_eg1_key_resp_allKeys[_oe_eg1_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_eg1_key_resp.rt = _oe_eg1_key_resp_allKeys[_oe_eg1_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_eg1'-------
    oe_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_eg2_key_resp_allKeys;
var oe_eg2Components;
function oe_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_eg2'-------
    t = 0;
    oe_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_eg2_key_resp.keys = undefined;
    oe_eg2_key_resp.rt = undefined;
    _oe_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_eg2Components = [];
    oe_eg2Components.push(oe_eg2_txt_top);
    oe_eg2Components.push(oe_eg2_txt_num);
    oe_eg2Components.push(oe_eg2_txt_bot);
    oe_eg2Components.push(oe_eg2_key_resp);
    
    oe_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_eg2_txt_top* updates
    if (t >= 0.0 && oe_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      oe_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      oe_eg2_txt_top.setAutoDraw(true);
    }

    
    // *oe_eg2_txt_num* updates
    if (t >= 0.0 && oe_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      oe_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      oe_eg2_txt_num.setAutoDraw(true);
    }

    
    // *oe_eg2_txt_bot* updates
    if (t >= 0.0 && oe_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      oe_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      oe_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *oe_eg2_key_resp* updates
    if (t >= 0.0 && oe_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_eg2_key_resp.clearEvents(); });
    }

    if (oe_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_eg2_key_resp.getKeys({keyList: ['m', 'z'], waitRelease: false});
      _oe_eg2_key_resp_allKeys = _oe_eg2_key_resp_allKeys.concat(theseKeys);
      if (_oe_eg2_key_resp_allKeys.length > 0) {
        oe_eg2_key_resp.keys = _oe_eg2_key_resp_allKeys[_oe_eg2_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_eg2_key_resp.rt = _oe_eg2_key_resp_allKeys[_oe_eg2_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_eg2'-------
    oe_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _oe_test_start_key_resp_allKeys;
var oe_test_startComponents;
function oe_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'oe_test_start'-------
    t = 0;
    oe_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    oe_test_start_key_resp.keys = undefined;
    oe_test_start_key_resp.rt = undefined;
    _oe_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    oe_test_startComponents = [];
    oe_test_startComponents.push(oe_test_start_txt);
    oe_test_startComponents.push(oe_test_start_key_resp);
    
    oe_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'oe_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = oe_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *oe_test_start_txt* updates
    if (t >= 0.0 && oe_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_test_start_txt.tStart = t;  // (not accounting for frame time here)
      oe_test_start_txt.frameNStart = frameN;  // exact frame index
      
      oe_test_start_txt.setAutoDraw(true);
    }

    
    // *oe_test_start_key_resp* updates
    if (t >= 0.0 && oe_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      oe_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      oe_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { oe_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { oe_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { oe_test_start_key_resp.clearEvents(); });
    }

    if (oe_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = oe_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _oe_test_start_key_resp_allKeys = _oe_test_start_key_resp_allKeys.concat(theseKeys);
      if (_oe_test_start_key_resp_allKeys.length > 0) {
        oe_test_start_key_resp.keys = _oe_test_start_key_resp_allKeys[_oe_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        oe_test_start_key_resp.rt = _oe_test_start_key_resp_allKeys[_oe_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    oe_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function oe_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'oe_test_start'-------
    oe_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "oe_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_52_allKeys;
var welcomeComponents;
function welcomeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'welcome'-------
    t = 0;
    welcomeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_52.keys = undefined;
    key_resp_52.rt = undefined;
    _key_resp_52_allKeys = [];
    // keep track of which components have finished
    welcomeComponents = [];
    welcomeComponents.push(text_122);
    welcomeComponents.push(text_123);
    welcomeComponents.push(key_resp_52);
    
    welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function welcomeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'welcome'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = welcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_122* updates
    if (t >= 0.0 && text_122.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_122.tStart = t;  // (not accounting for frame time here)
      text_122.frameNStart = frameN;  // exact frame index
      
      text_122.setAutoDraw(true);
    }

    
    // *text_123* updates
    if (t >= 0.0 && text_123.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_123.tStart = t;  // (not accounting for frame time here)
      text_123.frameNStart = frameN;  // exact frame index
      
      text_123.setAutoDraw(true);
    }

    
    // *key_resp_52* updates
    if (t >= 0.0 && key_resp_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_52.tStart = t;  // (not accounting for frame time here)
      key_resp_52.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_52.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_52.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_52.clearEvents(); });
    }

    if (key_resp_52.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_52.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_52_allKeys = _key_resp_52_allKeys.concat(theseKeys);
      if (_key_resp_52_allKeys.length > 0) {
        key_resp_52.keys = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].name;  // just the last key pressed
        key_resp_52.rt = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function welcomeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'welcome'-------
    welcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_52.keys', key_resp_52.keys);
    if (typeof key_resp_52.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_52.rt', key_resp_52.rt);
        routineTimer.reset();
        }
    
    key_resp_52.stop();
    // the Routine "welcome" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_53_allKeys;
var Instructions_3Components;
function Instructions_3RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Instructions_3'-------
    t = 0;
    Instructions_3Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_53.keys = undefined;
    key_resp_53.rt = undefined;
    _key_resp_53_allKeys = [];
    // keep track of which components have finished
    Instructions_3Components = [];
    Instructions_3Components.push(instructions_2);
    Instructions_3Components.push(key_resp_53);
    Instructions_3Components.push(text_124);
    
    Instructions_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Instructions_3RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Instructions_3'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Instructions_3Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *instructions_2* updates
    if (t >= 0.0 && instructions_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      instructions_2.tStart = t;  // (not accounting for frame time here)
      instructions_2.frameNStart = frameN;  // exact frame index
      
      instructions_2.setAutoDraw(true);
    }

    
    // *key_resp_53* updates
    if (t >= 0.0 && key_resp_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_53.tStart = t;  // (not accounting for frame time here)
      key_resp_53.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_53.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_53.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_53.clearEvents(); });
    }

    if (key_resp_53.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_53.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_53_allKeys = _key_resp_53_allKeys.concat(theseKeys);
      if (_key_resp_53_allKeys.length > 0) {
        key_resp_53.keys = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].name;  // just the last key pressed
        key_resp_53.rt = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_124* updates
    if (t >= 0.0 && text_124.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_124.tStart = t;  // (not accounting for frame time here)
      text_124.frameNStart = frameN;  // exact frame index
      
      text_124.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Instructions_3Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Instructions_3RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Instructions_3'-------
    Instructions_3Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_53.keys', key_resp_53.keys);
    if (typeof key_resp_53.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_53.rt', key_resp_53.rt);
        routineTimer.reset();
        }
    
    key_resp_53.stop();
    // the Routine "Instructions_3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_54_allKeys;
var ExampleComponents;
function ExampleRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Example'-------
    t = 0;
    ExampleClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_54.keys = undefined;
    key_resp_54.rt = undefined;
    _key_resp_54_allKeys = [];
    // keep track of which components have finished
    ExampleComponents = [];
    ExampleComponents.push(example_text);
    ExampleComponents.push(example);
    ExampleComponents.push(example_text_2);
    ExampleComponents.push(key_resp_54);
    
    ExampleComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function ExampleRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Example'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = ExampleClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *example_text* updates
    if (t >= 0.0 && example_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      example_text.tStart = t;  // (not accounting for frame time here)
      example_text.frameNStart = frameN;  // exact frame index
      
      example_text.setAutoDraw(true);
    }

    
    // *example* updates
    if (t >= 0.0 && example.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      example.tStart = t;  // (not accounting for frame time here)
      example.frameNStart = frameN;  // exact frame index
      
      example.setAutoDraw(true);
    }

    
    // *example_text_2* updates
    if (t >= 0.0 && example_text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      example_text_2.tStart = t;  // (not accounting for frame time here)
      example_text_2.frameNStart = frameN;  // exact frame index
      
      example_text_2.setAutoDraw(true);
    }

    
    // *key_resp_54* updates
    if (t >= 0.0 && key_resp_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_54.tStart = t;  // (not accounting for frame time here)
      key_resp_54.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_54.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_54.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_54.clearEvents(); });
    }

    if (key_resp_54.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_54.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_54_allKeys = _key_resp_54_allKeys.concat(theseKeys);
      if (_key_resp_54_allKeys.length > 0) {
        key_resp_54.keys = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].name;  // just the last key pressed
        key_resp_54.rt = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ExampleComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ExampleRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Example'-------
    ExampleComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_54.keys', key_resp_54.keys);
    if (typeof key_resp_54.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_54.rt', key_resp_54.rt);
        routineTimer.reset();
        }
    
    key_resp_54.stop();
    // the Routine "Example" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_55_allKeys;
var lets_practiceComponents;
function lets_practiceRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'lets_practice'-------
    t = 0;
    lets_practiceClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_55.keys = undefined;
    key_resp_55.rt = undefined;
    _key_resp_55_allKeys = [];
    // keep track of which components have finished
    lets_practiceComponents = [];
    lets_practiceComponents.push(text_125);
    lets_practiceComponents.push(key_resp_55);
    lets_practiceComponents.push(text_126);
    
    lets_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function lets_practiceRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'lets_practice'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = lets_practiceClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_125* updates
    if (t >= 0.0 && text_125.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_125.tStart = t;  // (not accounting for frame time here)
      text_125.frameNStart = frameN;  // exact frame index
      
      text_125.setAutoDraw(true);
    }

    
    // *key_resp_55* updates
    if (t >= 0.0 && key_resp_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_55.tStart = t;  // (not accounting for frame time here)
      key_resp_55.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_55.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_55.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_55.clearEvents(); });
    }

    if (key_resp_55.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_55.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_55_allKeys = _key_resp_55_allKeys.concat(theseKeys);
      if (_key_resp_55_allKeys.length > 0) {
        key_resp_55.keys = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].name;  // just the last key pressed
        key_resp_55.rt = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    
    // *text_126* updates
    if (t >= 0.0 && text_126.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_126.tStart = t;  // (not accounting for frame time here)
      text_126.frameNStart = frameN;  // exact frame index
      
      text_126.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    lets_practiceComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function lets_practiceRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'lets_practice'-------
    lets_practiceComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_55.keys', key_resp_55.keys);
    if (typeof key_resp_55.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_55.rt', key_resp_55.rt);
        routineTimer.reset();
        }
    
    key_resp_55.stop();
    // the Routine "lets_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var timer_practice_wcst;
var beginning_practice_wcst;
var trials_practice_2Components;
function trials_practice_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'trials_practice_2'-------
    t = 0;
    trials_practice_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    trial_card_2.setImage(card);
    corr = 0;
    timer_practice_wcst = new util.Clock();
    beginning_practice_wcst = timer_practice_wcst.getTime();
    // setup some python lists for storing info about the response_2
    response_2.clicked_name = [];
    gotValidClick = false; // until a click is received
    // keep track of which components have finished
    trials_practice_2Components = [];
    trials_practice_2Components.push(fixation_4);
    trials_practice_2Components.push(one_red_dot_2);
    trials_practice_2Components.push(two_yellow_triangles_2);
    trials_practice_2Components.push(three_green_crosses_2);
    trials_practice_2Components.push(four_blue_stars_2);
    trials_practice_2Components.push(trial_card_2);
    trials_practice_2Components.push(response_2);
    
    trials_practice_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function trials_practice_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'trials_practice_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = trials_practice_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_4* updates
    if (t >= 0.0 && fixation_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_4.tStart = t;  // (not accounting for frame time here)
      fixation_4.frameNStart = frameN;  // exact frame index
      
      fixation_4.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fixation_4.status === PsychoJS.Status.STARTED || fixation_4.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fixation_4.setAutoDraw(false);
    }
    
    // *one_red_dot_2* updates
    if (t >= 0 && one_red_dot_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      one_red_dot_2.tStart = t;  // (not accounting for frame time here)
      one_red_dot_2.frameNStart = frameN;  // exact frame index
      
      one_red_dot_2.setAutoDraw(true);
    }

    
    // *two_yellow_triangles_2* updates
    if (t >= 0 && two_yellow_triangles_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      two_yellow_triangles_2.tStart = t;  // (not accounting for frame time here)
      two_yellow_triangles_2.frameNStart = frameN;  // exact frame index
      
      two_yellow_triangles_2.setAutoDraw(true);
    }

    
    // *three_green_crosses_2* updates
    if (t >= 0 && three_green_crosses_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      three_green_crosses_2.tStart = t;  // (not accounting for frame time here)
      three_green_crosses_2.frameNStart = frameN;  // exact frame index
      
      three_green_crosses_2.setAutoDraw(true);
    }

    
    // *four_blue_stars_2* updates
    if (t >= 0 && four_blue_stars_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      four_blue_stars_2.tStart = t;  // (not accounting for frame time here)
      four_blue_stars_2.frameNStart = frameN;  // exact frame index
      
      four_blue_stars_2.setAutoDraw(true);
    }

    
    // *trial_card_2* updates
    if (t >= 0.5 && trial_card_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      trial_card_2.tStart = t;  // (not accounting for frame time here)
      trial_card_2.frameNStart = frameN;  // exact frame index
      
      trial_card_2.setAutoDraw(true);
    }

    var current_practice_wcst = timer_practice_wcst.getTime();
    var allow_practice_wcst = (current_practice_wcst - beginning_practice_wcst);
    console.log(allow_practice_wcst)
    if(allow_practice_wcst < .499){
        continueRoutine = true;
        } else {
            for (var stimulus, _pj_c = 0, _pj_a = [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars], _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                stimulus = _pj_a[_pj_c];
                if (response_2.isPressedIn(stimulus)) {
                    var corrAnsMaybe = 'images/' + stimulus.name + '.jpg';
                    console.log(stimulus.name, corrAns, corrAnsMaybe === corrAns);
                    if ((corrAnsMaybe === corrAns)) {
                        corr = 1;
                        }
                    psychoJS.experiment.addData("correct", corr);
                    psychoJS.experiment.addData("wcst_rt", allow_practice_wcst);
                    continueRoutine = false;
        }
    }
    }
    
    
    
    // *response_2* updates
    if (t >= 0.5 && response_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      response_2.tStart = t;  // (not accounting for frame time here)
      response_2.frameNStart = frameN;  // exact frame index
      
      response_2.status = PsychoJS.Status.STARTED;
      response_2.mouseClock.reset();
      prevButtonState = response_2.getPressed();  // if button is down already this ISN'T a new click
      }
    if (response_2.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = response_2.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [one_red_dot_2, two_yellow_triangles_2, three_green_crosses_2, four_blue_stars_2]) {
            if (obj.contains(response_2)) {
              gotValidClick = true;
              response_2.clicked_name.push(obj.name)
            }
          }
          if (gotValidClick === true) { // abort routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    trials_practice_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function trials_practice_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'trials_practice_2'-------
    trials_practice_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    _mouseXYs = response_2.getPos();
    _mouseButtons = response_2.getPressed();
    psychoJS.experiment.addData('response_2.x', _mouseXYs[0]);
    psychoJS.experiment.addData('response_2.y', _mouseXYs[1]);
    psychoJS.experiment.addData('response_2.leftButton', _mouseButtons[0]);
    psychoJS.experiment.addData('response_2.midButton', _mouseButtons[1]);
    psychoJS.experiment.addData('response_2.rightButton', _mouseButtons[2]);
    if (response_2.clicked_name.length > 0) {
      psychoJS.experiment.addData('response_2.clicked_name', response_2.clicked_name[0]);}
    // the Routine "trials_practice_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var feedback_practice_2Components;
function feedback_practice_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'feedback_practice_2'-------
    t = 0;
    feedback_practice_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    if ((corr === 1)) {
        msg_color = 'green';
        msg = "Correct!";
    } else {
        msg_color = 'red';
        msg = "Incorrect";
    }
    
    
    
    feedback_text_2.setColor(new util.Color(msg_color));
    feedback_text_2.setText(msg);
    // keep track of which components have finished
    feedback_practice_2Components = [];
    feedback_practice_2Components.push(feedback_text_2);
    
    feedback_practice_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_practice_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'feedback_practice_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = feedback_practice_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *feedback_text_2* updates
    if (t >= 0 && feedback_text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      feedback_text_2.tStart = t;  // (not accounting for frame time here)
      feedback_text_2.frameNStart = frameN;  // exact frame index
      
      feedback_text_2.setAutoDraw(true);
    }

    frameRemains = 0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((feedback_text_2.status === PsychoJS.Status.STARTED || feedback_text_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      feedback_text_2.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    feedback_practice_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function feedback_practice_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'feedback_practice_2'-------
    feedback_practice_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    trial_counter = 0;
    condition_counter = 0;
    return Scheduler.Event.NEXT;
  };
}


var _key_resp_56_allKeys;
var readyComponents;
function readyRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'ready'-------
    t = 0;
    readyClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    key_resp_56.keys = undefined;
    key_resp_56.rt = undefined;
    _key_resp_56_allKeys = [];
    // keep track of which components have finished
    readyComponents = [];
    readyComponents.push(text_127);
    readyComponents.push(text_128);
    readyComponents.push(key_resp_56);
    
    readyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function readyRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'ready'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = readyClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_127* updates
    if (t >= 0.0 && text_127.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_127.tStart = t;  // (not accounting for frame time here)
      text_127.frameNStart = frameN;  // exact frame index
      
      text_127.setAutoDraw(true);
    }

    
    // *text_128* updates
    if (t >= 0.0 && text_128.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_128.tStart = t;  // (not accounting for frame time here)
      text_128.frameNStart = frameN;  // exact frame index
      
      text_128.setAutoDraw(true);
    }

    
    // *key_resp_56* updates
    if (t >= 0.0 && key_resp_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_56.tStart = t;  // (not accounting for frame time here)
      key_resp_56.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_56.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_56.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_56.clearEvents(); });
    }

    if (key_resp_56.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_56.getKeys({keyList: ['space'], waitRelease: false});
      _key_resp_56_allKeys = _key_resp_56_allKeys.concat(theseKeys);
      if (_key_resp_56_allKeys.length > 0) {
        key_resp_56.keys = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].name;  // just the last key pressed
        key_resp_56.rt = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    readyComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function readyRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'ready'-------
    readyComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('key_resp_56.keys', key_resp_56.keys);
    if (typeof key_resp_56.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_56.rt', key_resp_56.rt);
        routineTimer.reset();
        }
    
    key_resp_56.stop();
    // the Routine "ready" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var code_meta_2Components;
function code_meta_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'code_meta_2'-------
    t = 0;
    code_meta_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    // keep track of which components have finished
    code_meta_2Components = [];
    
    code_meta_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function code_meta_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'code_meta_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = code_meta_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    code_meta_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function code_meta_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'code_meta_2'-------
    code_meta_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "code_meta_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var timer_wcst;
var beginning_wcst;
var TrialsComponents;
function TrialsRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Trials'-------
    t = 0;
    TrialsClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    trial_card.setImage(card);
    corr = 0;
    timer_wcst = new util.Clock();
    beginning_wcst = timer_wcst.getTime();
    // setup some python lists for storing info about the response
    response.clicked_name = [];
    gotValidClick = false; // until a click is received
    // keep track of which components have finished
    TrialsComponents = [];
    TrialsComponents.push(fixation_5);
    TrialsComponents.push(one_red_dot);
    TrialsComponents.push(two_yellow_triangles);
    TrialsComponents.push(three_green_crosses);
    TrialsComponents.push(four_blue_stars);
    TrialsComponents.push(trial_card);
    TrialsComponents.push(response);
    
    TrialsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function TrialsRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Trials'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = TrialsClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *fixation_5* updates
    if (t >= 0.0 && fixation_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      fixation_5.tStart = t;  // (not accounting for frame time here)
      fixation_5.frameNStart = frameN;  // exact frame index
      
      fixation_5.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((fixation_5.status === PsychoJS.Status.STARTED || fixation_5.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      fixation_5.setAutoDraw(false);
    }
    
    // *one_red_dot* updates
    if (t >= 0 && one_red_dot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      one_red_dot.tStart = t;  // (not accounting for frame time here)
      one_red_dot.frameNStart = frameN;  // exact frame index
      
      one_red_dot.setAutoDraw(true);
    }

    
    // *two_yellow_triangles* updates
    if (t >= 0 && two_yellow_triangles.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      two_yellow_triangles.tStart = t;  // (not accounting for frame time here)
      two_yellow_triangles.frameNStart = frameN;  // exact frame index
      
      two_yellow_triangles.setAutoDraw(true);
    }

    
    // *three_green_crosses* updates
    if (t >= 0 && three_green_crosses.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      three_green_crosses.tStart = t;  // (not accounting for frame time here)
      three_green_crosses.frameNStart = frameN;  // exact frame index
      
      three_green_crosses.setAutoDraw(true);
    }

    
    // *four_blue_stars* updates
    if (t >= 0 && four_blue_stars.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      four_blue_stars.tStart = t;  // (not accounting for frame time here)
      four_blue_stars.frameNStart = frameN;  // exact frame index
      
      four_blue_stars.setAutoDraw(true);
    }

    
    // *trial_card* updates
    if (t >= 0.5 && trial_card.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      trial_card.tStart = t;  // (not accounting for frame time here)
      trial_card.frameNStart = frameN;  // exact frame index
      
      trial_card.setAutoDraw(true);
    }

    var current_wcst = timer_wcst.getTime();
    var allow_wcst = (current_wcst - beginning_wcst);
    console.log(allow_wcst)
    if(allow_wcst < .499){
        continueRoutine = true;
        } else {
            for (var stimulus, _pj_c = 0, _pj_a = [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars], _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {
                stimulus = _pj_a[_pj_c];
                if (response.isPressedIn(stimulus)) {
                    var corrAnsMaybe = 'images/' + stimulus.name + '.jpg';
                    console.log(stimulus.name, corrAns, corrAnsMaybe === corrAns);
                    if ((corrAnsMaybe === corrAns)) {
                        corr = 1;
                        }
                    var end_wcst = timer_wcst.getTime();
                    var time_wcst_trial = (end_wcst - beginning_wcst);
                    psychoJS.experiment.addData("wcst_rt", time_wcst_trial);
                    psychoJS.experiment.addData("correct", corr);
                    continueRoutine = false;
        }
    }
    }
    
    
    // *response* updates
    if (t >= 0.5 && response.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      response.tStart = t;  // (not accounting for frame time here)
      response.frameNStart = frameN;  // exact frame index
      
      response.status = PsychoJS.Status.STARTED;
      response.mouseClock.reset();
      prevButtonState = response.getPressed();  // if button is down already this ISN'T a new click
      }
    if (response.status === PsychoJS.Status.STARTED) {  // only update if started and not finished!
      _mouseButtons = response.getPressed();
      if (!_mouseButtons.every( (e,i,) => (e == prevButtonState[i]) )) { // button state changed?
        prevButtonState = _mouseButtons;
        if (_mouseButtons.reduce( (e, acc) => (e+acc) ) > 0) { // state changed to a new click
          // check if the mouse was inside our 'clickable' objects
          gotValidClick = false;
          for (const obj of [one_red_dot, two_yellow_triangles, three_green_crosses, four_blue_stars]) {
            if (obj.contains(response)) {
              gotValidClick = true;
              response.clicked_name.push(obj.name)
            }
          }
          if (gotValidClick === true) { // abort routine on response
            continueRoutine = false;
          }
        }
      }
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    TrialsComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function TrialsRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Trials'-------
    TrialsComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // store data for thisExp (ExperimentHandler)
    _mouseXYs = response.getPos();
    _mouseButtons = response.getPressed();
    psychoJS.experiment.addData('response.x', _mouseXYs[0]);
    psychoJS.experiment.addData('response.y', _mouseXYs[1]);
    psychoJS.experiment.addData('response.leftButton', _mouseButtons[0]);
    psychoJS.experiment.addData('response.midButton', _mouseButtons[1]);
    psychoJS.experiment.addData('response.rightButton', _mouseButtons[2]);
    if (response.clicked_name.length > 0) {
      psychoJS.experiment.addData('response.clicked_name', response.clicked_name[0]);}
    // the Routine "Trials" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var Feedback_2Components;
function Feedback_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'Feedback_2'-------
    t = 0;
    Feedback_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    if ((corr === 1)) {
        msg_color = 'green';
        msg = "Correct! ";
    } else {
        msg_color = 'red';
        msg = "Incorrect";
    }
    
    
    
    feedback_text.setColor(new util.Color(msg_color));
    feedback_text.setText(msg);
    // keep track of which components have finished
    Feedback_2Components = [];
    Feedback_2Components.push(feedback_text);
    
    Feedback_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function Feedback_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'Feedback_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = Feedback_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *feedback_text* updates
    if (t >= 0 && feedback_text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      feedback_text.tStart = t;  // (not accounting for frame time here)
      feedback_text.frameNStart = frameN;  // exact frame index
      
      feedback_text.setAutoDraw(true);
    }

    frameRemains = 0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((feedback_text.status === PsychoJS.Status.STARTED || feedback_text.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      feedback_text.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    Feedback_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function Feedback_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'Feedback_2'-------
    Feedback_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    if((trial_counter === 0 && corr === 1)){
        corr_trial_counter = 1;
        prev = 1;
    } else if ((trial_counter === 0 && corr === 0)) {
        corr_trial_counter = 0;
        prev = 0; 
    } else if ((trial_counter > 0 && corr === 1)){
        if((prev === 1)){
            corr_trial_counter = corr_trial_counter + 1;
            prev = 1;
        } else {
            corr_trial_counter = 1;
            prev =1;}
    } else {
        corr_trial_counter = 0;
        prev = 0;
    }
    
    console.log(corr_trial_counter);
    console.log(trial_counter);
    trial_counter = (trial_counter + 1);
    console.log(trial_counter);
    
    psychoJS.experiment.addData("trial_counter", trial_counter);
    
    if ((corr_trial_counter === 6)) {
        trials_3.finished = true;
        condition_counter = condition_counter + 1 
        corr_trial_counter = 0
        console.log(corr_trial_counter);
        console.log(condition_counter);
    }
    
    if ((trial_counter === 40)){
        trials_3.finished = true;
        }
    return Scheduler.Event.NEXT;
  };
}


var code_end_2Components;
function code_end_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'code_end_2'-------
    t = 0;
    code_end_2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    console.log(condition_counter)
    console.log(trial_counter)
    if ((condition_counter > 3)) {
        blocks_2.finished = true;
    } else if ((trial_counter === 40)){
        blocks_2.finished = true;
    } else {
        blocks_2.finished = false;
    }
    
    // keep track of which components have finished
    code_end_2Components = [];
    
    code_end_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function code_end_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'code_end_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = code_end_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    code_end_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function code_end_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'code_end_2'-------
    code_end_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "code_end_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var thank_you_5Components;
function thank_you_5RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'thank_you_5'-------
    t = 0;
    thank_you_5Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(2.500000);
    // update component parameters for each repeat
    // keep track of which components have finished
    thank_you_5Components = [];
    thank_you_5Components.push(text_129);
    
    thank_you_5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function thank_you_5RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'thank_you_5'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = thank_you_5Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *text_129* updates
    if (t >= 0.0 && text_129.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_129.tStart = t;  // (not accounting for frame time here)
      text_129.frameNStart = frameN;  // exact frame index
      
      text_129.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((text_129.status === PsychoJS.Status.STARTED || text_129.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      text_129.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    thank_you_5Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function thank_you_5RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'thank_you_5'-------
    thank_you_5Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _pm_welcome_key_resp_allKeys;
var pm_welcomeComponents;
function pm_welcomeRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_welcome'-------
    t = 0;
    pm_welcomeClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    pm_welcome_key_resp.keys = undefined;
    pm_welcome_key_resp.rt = undefined;
    _pm_welcome_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_welcomeComponents = [];
    pm_welcomeComponents.push(pm_welcome_txt_top);
    pm_welcomeComponents.push(pm_welcome_txt_bot);
    pm_welcomeComponents.push(pm_welcome_key_resp);
    
    pm_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_welcomeRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_welcome'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_welcomeClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pm_welcome_txt_top* updates
    if (t >= 0.0 && pm_welcome_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_welcome_txt_top.tStart = t;  // (not accounting for frame time here)
      pm_welcome_txt_top.frameNStart = frameN;  // exact frame index
      
      pm_welcome_txt_top.setAutoDraw(true);
    }

    
    // *pm_welcome_txt_bot* updates
    if (t >= 0.0 && pm_welcome_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_welcome_txt_bot.tStart = t;  // (not accounting for frame time here)
      pm_welcome_txt_bot.frameNStart = frameN;  // exact frame index
      
      pm_welcome_txt_bot.setAutoDraw(true);
    }

    
    // *pm_welcome_key_resp* updates
    if (t >= 0.0 && pm_welcome_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_welcome_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_welcome_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_welcome_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_welcome_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_welcome_key_resp.clearEvents(); });
    }

    if (pm_welcome_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_welcome_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _pm_welcome_key_resp_allKeys = _pm_welcome_key_resp_allKeys.concat(theseKeys);
      if (_pm_welcome_key_resp_allKeys.length > 0) {
        pm_welcome_key_resp.keys = _pm_welcome_key_resp_allKeys[_pm_welcome_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_welcome_key_resp.rt = _pm_welcome_key_resp_allKeys[_pm_welcome_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_welcomeComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_welcomeRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_welcome'-------
    pm_welcomeComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "pm_welcome" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _plus_intro_key_resp_allKeys;
var plus_introComponents;
function plus_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'plus_intro'-------
    t = 0;
    plus_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    plus_intro_key_resp.keys = undefined;
    plus_intro_key_resp.rt = undefined;
    _plus_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    plus_introComponents = [];
    plus_introComponents.push(plus_intro_txt_top);
    plus_introComponents.push(plus_intro_txt_bot);
    plus_introComponents.push(plus_intro_key_resp);
    
    plus_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'plus_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = plus_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *plus_intro_txt_top* updates
    if (t >= 0.0 && plus_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      plus_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      plus_intro_txt_top.setAutoDraw(true);
    }

    
    // *plus_intro_txt_bot* updates
    if (t >= 0.0 && plus_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      plus_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      plus_intro_txt_bot.setAutoDraw(true);
    }

    
    // *plus_intro_key_resp* updates
    if (t >= 0.0 && plus_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      plus_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { plus_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { plus_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { plus_intro_key_resp.clearEvents(); });
    }

    if (plus_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = plus_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _plus_intro_key_resp_allKeys = _plus_intro_key_resp_allKeys.concat(theseKeys);
      if (_plus_intro_key_resp_allKeys.length > 0) {
        plus_intro_key_resp.keys = _plus_intro_key_resp_allKeys[_plus_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        plus_intro_key_resp.rt = _plus_intro_key_resp_allKeys[_plus_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    plus_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'plus_intro'-------
    plus_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "plus_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var frame_n;
var _plus_eg1_key_resp_allKeys;
var plus_eg1Components;
function plus_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'plus_eg1'-------
    t = 0;
    plus_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    plus_eg1_key_resp.keys = undefined;
    plus_eg1_key_resp.rt = undefined;
    _plus_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    plus_eg1Components = [];
    plus_eg1Components.push(plus_eg1_txt_top);
    plus_eg1Components.push(plus_eg1_txt_num);
    plus_eg1Components.push(plus_eg1_txt_sym);
    plus_eg1Components.push(plus_eg1_txt_bot);
    plus_eg1Components.push(plus_eg1_key_resp);
    plus_eg1Components.push(plus_eg1_resp_txt);
    
    plus_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'plus_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = plus_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        plus_eg1_resp_txt.text = plus_eg1_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        plus_eg1_resp_txt.text = plus_eg1_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = plus_eg1_resp_txt.text
    
    // *plus_eg1_txt_top* updates
    if (t >= 0.0 && plus_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      plus_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      plus_eg1_txt_top.setAutoDraw(true);
    }

    
    // *plus_eg1_txt_num* updates
    if (t >= 0.0 && plus_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      plus_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      plus_eg1_txt_num.setAutoDraw(true);
    }

    
    // *plus_eg1_txt_sym* updates
    if (t >= 0.0 && plus_eg1_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_txt_sym.tStart = t;  // (not accounting for frame time here)
      plus_eg1_txt_sym.frameNStart = frameN;  // exact frame index
      
      plus_eg1_txt_sym.setAutoDraw(true);
    }

    
    // *plus_eg1_txt_bot* updates
    if (t >= 0.0 && plus_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      plus_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      plus_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *plus_eg1_key_resp* updates
    if (t >= 0.0 && plus_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      plus_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { plus_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { plus_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { plus_eg1_key_resp.clearEvents(); });
    }

    if (plus_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = plus_eg1_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _plus_eg1_key_resp_allKeys = _plus_eg1_key_resp_allKeys.concat(theseKeys);
      if (_plus_eg1_key_resp_allKeys.length > 0) {
        plus_eg1_key_resp.keys = _plus_eg1_key_resp_allKeys.map((key) => key.name);  // storing all keys
        plus_eg1_key_resp.rt = _plus_eg1_key_resp_allKeys.map((key) => key.rt);
      }
    }
    
    
    // *plus_eg1_resp_txt* updates
    if (t >= 0.0 && plus_eg1_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg1_resp_txt.tStart = t;  // (not accounting for frame time here)
      plus_eg1_resp_txt.frameNStart = frameN;  // exact frame index
      
      plus_eg1_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    plus_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'plus_eg1'-------
    plus_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('plus_eg1_key_resp.keys', plus_eg1_key_resp.keys);
    if (typeof plus_eg1_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('plus_eg1_key_resp.rt', plus_eg1_key_resp.rt);
        }
    
    plus_eg1_key_resp.stop();
    // the Routine "plus_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _plus_eg2_key_resp_allKeys;
var plus_eg2Components;
function plus_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'plus_eg2'-------
    t = 0;
    plus_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    plus_eg2_key_resp.keys = undefined;
    plus_eg2_key_resp.rt = undefined;
    _plus_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    plus_eg2Components = [];
    plus_eg2Components.push(plus_eg2_txt_top);
    plus_eg2Components.push(plus_eg2_txt_num);
    plus_eg2Components.push(plus_eg2_txt_sym);
    plus_eg2Components.push(plus_eg2_txt_bot);
    plus_eg2Components.push(plus_eg2_key_resp);
    plus_eg2Components.push(plus_eg2_resp_txt);
    
    plus_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'plus_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = plus_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        plus_eg2_resp_txt.text = plus_eg2_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        plus_eg2_resp_txt.text = plus_eg2_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = plus_eg2_resp_txt.text
    
    // *plus_eg2_txt_top* updates
    if (t >= 0.0 && plus_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      plus_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      plus_eg2_txt_top.setAutoDraw(true);
    }

    
    // *plus_eg2_txt_num* updates
    if (t >= 0.0 && plus_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      plus_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      plus_eg2_txt_num.setAutoDraw(true);
    }

    
    // *plus_eg2_txt_sym* updates
    if (t >= 0.0 && plus_eg2_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_txt_sym.tStart = t;  // (not accounting for frame time here)
      plus_eg2_txt_sym.frameNStart = frameN;  // exact frame index
      
      plus_eg2_txt_sym.setAutoDraw(true);
    }

    
    // *plus_eg2_txt_bot* updates
    if (t >= 0.0 && plus_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      plus_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      plus_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *plus_eg2_key_resp* updates
    if (t >= 0.0 && plus_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      plus_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { plus_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { plus_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { plus_eg2_key_resp.clearEvents(); });
    }

    if (plus_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = plus_eg2_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _plus_eg2_key_resp_allKeys = _plus_eg2_key_resp_allKeys.concat(theseKeys);
      if (_plus_eg2_key_resp_allKeys.length > 0) {
        plus_eg2_key_resp.keys = _plus_eg2_key_resp_allKeys[_plus_eg2_key_resp_allKeys.length - 1].name;  // just the last key pressed
        plus_eg2_key_resp.rt = _plus_eg2_key_resp_allKeys[_plus_eg2_key_resp_allKeys.length - 1].rt;
      }
    }
    
    
    // *plus_eg2_resp_txt* updates
    if (t >= 0.0 && plus_eg2_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_eg2_resp_txt.tStart = t;  // (not accounting for frame time here)
      plus_eg2_resp_txt.frameNStart = frameN;  // exact frame index
      
      plus_eg2_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    plus_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'plus_eg2'-------
    plus_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "plus_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_train_start_key_resp_allKeys;
var pm_train_startComponents;
function pm_train_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_train_start'-------
    t = 0;
    pm_train_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    pm_train_start_key_resp.keys = undefined;
    pm_train_start_key_resp.rt = undefined;
    _pm_train_start_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_train_startComponents = [];
    pm_train_startComponents.push(pm_train_start_txt);
    pm_train_startComponents.push(pm_train_start_key_resp);
    
    pm_train_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_train_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_train_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_train_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pm_train_start_txt* updates
    if (t >= 0.0 && pm_train_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_train_start_txt.tStart = t;  // (not accounting for frame time here)
      pm_train_start_txt.frameNStart = frameN;  // exact frame index
      
      pm_train_start_txt.setAutoDraw(true);
    }

    
    // *pm_train_start_key_resp* updates
    if (t >= 0.0 && pm_train_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_train_start_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_train_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_train_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_train_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_train_start_key_resp.clearEvents(); });
    }

    if (pm_train_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_train_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _pm_train_start_key_resp_allKeys = _pm_train_start_key_resp_allKeys.concat(theseKeys);
      if (_pm_train_start_key_resp_allKeys.length > 0) {
        pm_train_start_key_resp.keys = _pm_train_start_key_resp_allKeys[_pm_train_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_train_start_key_resp.rt = _pm_train_start_key_resp_allKeys[_pm_train_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_train_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var pm_timer;
function pm_train_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_train_start'-------
    pm_train_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    pm_timer = new util.CountdownTimer(30);
    // the Routine "pm_train_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_trial_key_resp_allKeys;
var pm_trialComponents;
function pm_trialRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_trial'-------
    t = 0;
    pm_trialClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    textAdd = '';
    frame_n = 0;
    pm_trial_txt_num.setText(pm_number);
    pm_trial_txt_sym.setText(pm_symbol);
    pm_trial_key_resp.keys = undefined;
    pm_trial_key_resp.rt = undefined;
    _pm_trial_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_trialComponents = [];
    pm_trialComponents.push(pm_trial_fixation);
    pm_trialComponents.push(pm_trial_txt_num);
    pm_trialComponents.push(pm_trial_txt_sym);
    pm_trialComponents.push(pm_trial_key_resp);
    pm_trialComponents.push(pm_trial_resp_txt);
    
    pm_trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_trialRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_trial'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    if (pm_timer.getTime() <= 0) {
        currentLoop.finished = true;
    }
    
    
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        pm_trial_resp_txt.text = pm_trial_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        pm_trial_resp_txt.text = pm_trial_resp_txt.text + textAdd
        textAdd = undefined;
    }
    frame_n = frame_n + 1;
    current_resp = pm_trial_resp_txt.text
    
    // *pm_trial_fixation* updates
    if (t >= 0.0 && pm_trial_fixation.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_trial_fixation.tStart = t;  // (not accounting for frame time here)
      pm_trial_fixation.frameNStart = frameN;  // exact frame index
      
      pm_trial_fixation.setAutoDraw(true);
    }

    frameRemains = 0.0 + 0.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((pm_trial_fixation.status === PsychoJS.Status.STARTED || pm_trial_fixation.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      pm_trial_fixation.setAutoDraw(false);
    }
    
    // *pm_trial_txt_num* updates
    if (t >= 1 && pm_trial_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_trial_txt_num.tStart = t;  // (not accounting for frame time here)
      pm_trial_txt_num.frameNStart = frameN;  // exact frame index
      
      pm_trial_txt_num.setAutoDraw(true);
    }

    
    // *pm_trial_txt_sym* updates
    if (t >= 1.0 && pm_trial_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_trial_txt_sym.tStart = t;  // (not accounting for frame time here)
      pm_trial_txt_sym.frameNStart = frameN;  // exact frame index
      
      pm_trial_txt_sym.setAutoDraw(true);
    }

    
    // *pm_trial_key_resp* updates
    if (t >= 1 && pm_trial_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_trial_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_trial_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_trial_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_trial_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_trial_key_resp.clearEvents(); });
    }

    if (pm_trial_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_trial_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _pm_trial_key_resp_allKeys = _pm_trial_key_resp_allKeys.concat(theseKeys);
      if (_pm_trial_key_resp_allKeys.length > 0) {
        pm_trial_key_resp.keys = _pm_trial_key_resp_allKeys.map((key) => key.name);  // storing all keys
        pm_trial_key_resp.rt = _pm_trial_key_resp_allKeys.map((key) => key.rt);
      }
    }
    
    
    // *pm_trial_resp_txt* updates
    if (t >= 1 && pm_trial_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_trial_resp_txt.tStart = t;  // (not accounting for frame time here)
      pm_trial_resp_txt.frameNStart = frameN;  // exact frame index
      
      pm_trial_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


var pm_feedback_color;
var pm_feedback_message;
function pm_trialRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_trial'-------
    pm_trialComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    if (Number(current_resp) === pm_correct) {
        pm_feedback_color = 'green';
        pm_feedback_message = "Correct";
    } else {
        pm_feedback_color = 'red';
        pm_feedback_message = "Incorrect";
    }
    //psychoJS.experiment.addData("response", current_resp);
    pm_trial_resp_txt.text = '';
    psychoJS.experiment.addData('pm_trial_key_resp.keys', pm_trial_key_resp.keys);
    if (typeof pm_trial_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('pm_trial_key_resp.rt', pm_trial_key_resp.rt);
        }
    
    pm_trial_key_resp.stop();
    // the Routine "pm_trial" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var pm_feedbackComponents;
function pm_feedbackRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_feedback'-------
    t = 0;
    pm_feedbackClock.reset(); // clock
    frameN = -1;
    routineTimer.add(1.000000);
    // update component parameters for each repeat
    pm_feedback_txt.setColor(new util.Color(pm_feedback_color));
    pm_feedback_txt.setText(pm_feedback_message);
    // keep track of which components have finished
    pm_feedbackComponents = [];
    pm_feedbackComponents.push(pm_feedback_txt);
    
    pm_feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_feedbackRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_feedback'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_feedbackClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pm_feedback_txt* updates
    if (t >= 0.0 && pm_feedback_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_feedback_txt.tStart = t;  // (not accounting for frame time here)
      pm_feedback_txt.frameNStart = frameN;  // exact frame index
      
      pm_feedback_txt.setAutoDraw(true);
    }

    frameRemains = 0.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((pm_feedback_txt.status === PsychoJS.Status.STARTED || pm_feedback_txt.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      pm_feedback_txt.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_feedbackComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_feedbackRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_feedback'-------
    pm_feedbackComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    return Scheduler.Event.NEXT;
  };
}


var _plus_test_start_key_resp_allKeys;
var plus_test_startComponents;
function plus_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'plus_test_start'-------
    t = 0;
    plus_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    plus_test_start_key_resp.keys = undefined;
    plus_test_start_key_resp.rt = undefined;
    _plus_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    plus_test_startComponents = [];
    plus_test_startComponents.push(plus_test_start_txt);
    plus_test_startComponents.push(plus_test_start_key_resp);
    
    plus_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'plus_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = plus_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *plus_test_start_txt* updates
    if (t >= 0.0 && plus_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_test_start_txt.tStart = t;  // (not accounting for frame time here)
      plus_test_start_txt.frameNStart = frameN;  // exact frame index
      
      plus_test_start_txt.setAutoDraw(true);
    }

    
    // *plus_test_start_key_resp* updates
    if (t >= 0.0 && plus_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      plus_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      plus_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { plus_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { plus_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { plus_test_start_key_resp.clearEvents(); });
    }

    if (plus_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = plus_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _plus_test_start_key_resp_allKeys = _plus_test_start_key_resp_allKeys.concat(theseKeys);
      if (_plus_test_start_key_resp_allKeys.length > 0) {
        plus_test_start_key_resp.keys = _plus_test_start_key_resp_allKeys[_plus_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        plus_test_start_key_resp.rt = _plus_test_start_key_resp_allKeys[_plus_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    plus_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function plus_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'plus_test_start'-------
    plus_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    pm_timer = new util.CountdownTimer(120);
    // the Routine "plus_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _minus_intro_key_resp_allKeys;
var minus_introComponents;
function minus_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'minus_intro'-------
    t = 0;
    minus_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    minus_intro_key_resp.keys = undefined;
    minus_intro_key_resp.rt = undefined;
    _minus_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    minus_introComponents = [];
    minus_introComponents.push(minus_intro_txt_top);
    minus_introComponents.push(minus_intro_txt_bot);
    minus_introComponents.push(minus_intro_key_resp);
    
    minus_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'minus_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = minus_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *minus_intro_txt_top* updates
    if (t >= 0.0 && minus_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      minus_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      minus_intro_txt_top.setAutoDraw(true);
    }

    
    // *minus_intro_txt_bot* updates
    if (t >= 0.0 && minus_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      minus_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      minus_intro_txt_bot.setAutoDraw(true);
    }

    
    // *minus_intro_key_resp* updates
    if (t >= 0.0 && minus_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      minus_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { minus_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { minus_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { minus_intro_key_resp.clearEvents(); });
    }

    if (minus_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = minus_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _minus_intro_key_resp_allKeys = _minus_intro_key_resp_allKeys.concat(theseKeys);
      if (_minus_intro_key_resp_allKeys.length > 0) {
        minus_intro_key_resp.keys = _minus_intro_key_resp_allKeys[_minus_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        minus_intro_key_resp.rt = _minus_intro_key_resp_allKeys[_minus_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    minus_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'minus_intro'-------
    minus_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "minus_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _minus_eg1_key_resp_allKeys;
var minus_eg1Components;
function minus_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'minus_eg1'-------
    t = 0;
    minus_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    minus_eg1_key_resp.keys = undefined;
    minus_eg1_key_resp.rt = undefined;
    _minus_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    minus_eg1Components = [];
    minus_eg1Components.push(minus_eg1_txt_top);
    minus_eg1Components.push(minus_eg1_txt_num);
    minus_eg1Components.push(minus_eg1_txt_sym);
    minus_eg1Components.push(minus_eg1_txt_bot);
    minus_eg1Components.push(minus_eg1_key_resp);
    minus_eg1Components.push(minus_eg1_resp_txt);
    
    minus_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'minus_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = minus_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        minus_eg1_resp_txt.text = minus_eg1_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        minus_eg1_resp_txt.text = minus_eg1_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = minus_eg1_resp_txt.text
    
    // *minus_eg1_txt_top* updates
    if (t >= 0.0 && minus_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      minus_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      minus_eg1_txt_top.setAutoDraw(true);
    }

    
    // *minus_eg1_txt_num* updates
    if (t >= 0.0 && minus_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      minus_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      minus_eg1_txt_num.setAutoDraw(true);
    }

    
    // *minus_eg1_txt_sym* updates
    if (t >= 0.0 && minus_eg1_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_txt_sym.tStart = t;  // (not accounting for frame time here)
      minus_eg1_txt_sym.frameNStart = frameN;  // exact frame index
      
      minus_eg1_txt_sym.setAutoDraw(true);
    }

    
    // *minus_eg1_txt_bot* updates
    if (t >= 0.0 && minus_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      minus_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      minus_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *minus_eg1_key_resp* updates
    if (t >= 0.0 && minus_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      minus_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { minus_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { minus_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { minus_eg1_key_resp.clearEvents(); });
    }

    if (minus_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = minus_eg1_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _minus_eg1_key_resp_allKeys = _minus_eg1_key_resp_allKeys.concat(theseKeys);
      if (_minus_eg1_key_resp_allKeys.length > 0) {
        minus_eg1_key_resp.keys = _minus_eg1_key_resp_allKeys.map((key) => key.name);  // storing all keys
        minus_eg1_key_resp.rt = _minus_eg1_key_resp_allKeys.map((key) => key.rt);
      }
    }
    
    
    // *minus_eg1_resp_txt* updates
    if (t >= 0.0 && minus_eg1_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg1_resp_txt.tStart = t;  // (not accounting for frame time here)
      minus_eg1_resp_txt.frameNStart = frameN;  // exact frame index
      
      minus_eg1_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    minus_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'minus_eg1'-------
    minus_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('minus_eg1_key_resp.keys', minus_eg1_key_resp.keys);
    if (typeof minus_eg1_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('minus_eg1_key_resp.rt', minus_eg1_key_resp.rt);
        }
    
    minus_eg1_key_resp.stop();
    // the Routine "minus_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _minus_eg2_key_resp_allKeys;
var minus_eg2Components;
function minus_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'minus_eg2'-------
    t = 0;
    minus_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    minus_eg2_key_resp.keys = undefined;
    minus_eg2_key_resp.rt = undefined;
    _minus_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    minus_eg2Components = [];
    minus_eg2Components.push(minus_eg2_txt_top);
    minus_eg2Components.push(minus_eg2_txt_num);
    minus_eg2Components.push(minus_eg2_txt_sym);
    minus_eg2Components.push(minus_eg2_txt_bot);
    minus_eg2Components.push(minus_eg2_key_resp);
    minus_eg2Components.push(minus_eg2_resp_txt);
    
    minus_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'minus_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = minus_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        minus_eg2_resp_txt.text = minus_eg2_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        minus_eg2_resp_txt.text = minus_eg2_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = minus_eg2_resp_txt.text
    
    // *minus_eg2_txt_top* updates
    if (t >= 0.0 && minus_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      minus_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      minus_eg2_txt_top.setAutoDraw(true);
    }

    
    // *minus_eg2_txt_num* updates
    if (t >= 0.0 && minus_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      minus_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      minus_eg2_txt_num.setAutoDraw(true);
    }

    
    // *minus_eg2_txt_sym* updates
    if (t >= 0.0 && minus_eg2_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_txt_sym.tStart = t;  // (not accounting for frame time here)
      minus_eg2_txt_sym.frameNStart = frameN;  // exact frame index
      
      minus_eg2_txt_sym.setAutoDraw(true);
    }

    
    // *minus_eg2_txt_bot* updates
    if (t >= 0.0 && minus_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      minus_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      minus_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *minus_eg2_key_resp* updates
    if (t >= 0.0 && minus_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      minus_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { minus_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { minus_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { minus_eg2_key_resp.clearEvents(); });
    }

    if (minus_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = minus_eg2_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _minus_eg2_key_resp_allKeys = _minus_eg2_key_resp_allKeys.concat(theseKeys);
      if (_minus_eg2_key_resp_allKeys.length > 0) {
        minus_eg2_key_resp.keys = _minus_eg2_key_resp_allKeys.map((key) => key.name);  // storing all keys
        minus_eg2_key_resp.rt = _minus_eg2_key_resp_allKeys.map((key) => key.rt);
      }
    }
    
    
    // *minus_eg2_resp_txt* updates
    if (t >= 0.0 && minus_eg2_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_eg2_resp_txt.tStart = t;  // (not accounting for frame time here)
      minus_eg2_resp_txt.frameNStart = frameN;  // exact frame index
      
      minus_eg2_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    minus_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'minus_eg2'-------
    minus_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    psychoJS.experiment.addData('minus_eg2_key_resp.keys', minus_eg2_key_resp.keys);
    if (typeof minus_eg2_key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('minus_eg2_key_resp.rt', minus_eg2_key_resp.rt);
        }
    
    minus_eg2_key_resp.stop();
    // the Routine "minus_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _minus_test_start_key_resp_allKeys;
var minus_test_startComponents;
function minus_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'minus_test_start'-------
    t = 0;
    minus_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    minus_test_start_key_resp.keys = undefined;
    minus_test_start_key_resp.rt = undefined;
    _minus_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    minus_test_startComponents = [];
    minus_test_startComponents.push(minus_test_start_txt);
    minus_test_startComponents.push(minus_test_start_key_resp);
    
    minus_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'minus_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = minus_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *minus_test_start_txt* updates
    if (t >= 0.0 && minus_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_test_start_txt.tStart = t;  // (not accounting for frame time here)
      minus_test_start_txt.frameNStart = frameN;  // exact frame index
      
      minus_test_start_txt.setAutoDraw(true);
    }

    
    // *minus_test_start_key_resp* updates
    if (t >= 0.0 && minus_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      minus_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      minus_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { minus_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { minus_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { minus_test_start_key_resp.clearEvents(); });
    }

    if (minus_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = minus_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _minus_test_start_key_resp_allKeys = _minus_test_start_key_resp_allKeys.concat(theseKeys);
      if (_minus_test_start_key_resp_allKeys.length > 0) {
        minus_test_start_key_resp.keys = _minus_test_start_key_resp_allKeys[_minus_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        minus_test_start_key_resp.rt = _minus_test_start_key_resp_allKeys[_minus_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    minus_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function minus_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'minus_test_start'-------
    minus_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    pm_timer = new util.CountdownTimer(120);
    // the Routine "minus_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_intro_key_resp_allKeys;
var pm_introComponents;
function pm_introRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_intro'-------
    t = 0;
    pm_introClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    pm_intro_key_resp.keys = undefined;
    pm_intro_key_resp.rt = undefined;
    _pm_intro_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_introComponents = [];
    pm_introComponents.push(pm_intro_txt_top);
    pm_introComponents.push(pm_intro_txt_bot);
    pm_introComponents.push(pm_intro_key_resp);
    
    pm_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_introRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_intro'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_introClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pm_intro_txt_top* updates
    if (t >= 0.0 && pm_intro_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_intro_txt_top.tStart = t;  // (not accounting for frame time here)
      pm_intro_txt_top.frameNStart = frameN;  // exact frame index
      
      pm_intro_txt_top.setAutoDraw(true);
    }

    
    // *pm_intro_txt_bot* updates
    if (t >= 0.0 && pm_intro_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_intro_txt_bot.tStart = t;  // (not accounting for frame time here)
      pm_intro_txt_bot.frameNStart = frameN;  // exact frame index
      
      pm_intro_txt_bot.setAutoDraw(true);
    }

    
    // *pm_intro_key_resp* updates
    if (t >= 0.0 && pm_intro_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_intro_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_intro_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_intro_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_intro_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_intro_key_resp.clearEvents(); });
    }

    if (pm_intro_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_intro_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _pm_intro_key_resp_allKeys = _pm_intro_key_resp_allKeys.concat(theseKeys);
      if (_pm_intro_key_resp_allKeys.length > 0) {
        pm_intro_key_resp.keys = _pm_intro_key_resp_allKeys[_pm_intro_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_intro_key_resp.rt = _pm_intro_key_resp_allKeys[_pm_intro_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_introComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_introRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_intro'-------
    pm_introComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "pm_intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_eg1_key_resp_allKeys;
var pm_eg1Components;
function pm_eg1RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_eg1'-------
    t = 0;
    pm_eg1Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    pm_eg1_key_resp.keys = undefined;
    pm_eg1_key_resp.rt = undefined;
    _pm_eg1_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_eg1Components = [];
    pm_eg1Components.push(pm_eg1_txt_top);
    pm_eg1Components.push(pm_eg1_txt_num);
    pm_eg1Components.push(pm_eg1_txt_sym);
    pm_eg1Components.push(pm_eg1_txt_bot);
    pm_eg1Components.push(pm_eg1_key_resp);
    pm_eg1Components.push(pm_eg1_resp_txt);
    
    pm_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_eg1RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_eg1'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_eg1Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        pm_eg1_resp_txt.text = pm_eg1_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        pm_eg1_resp_txt.text = pm_eg1_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = pm_eg1_resp_txt.text
    
    // *pm_eg1_txt_top* updates
    if (t >= 0.0 && pm_eg1_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_txt_top.tStart = t;  // (not accounting for frame time here)
      pm_eg1_txt_top.frameNStart = frameN;  // exact frame index
      
      pm_eg1_txt_top.setAutoDraw(true);
    }

    
    // *pm_eg1_txt_num* updates
    if (t >= 0.0 && pm_eg1_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_txt_num.tStart = t;  // (not accounting for frame time here)
      pm_eg1_txt_num.frameNStart = frameN;  // exact frame index
      
      pm_eg1_txt_num.setAutoDraw(true);
    }

    
    // *pm_eg1_txt_sym* updates
    if (t >= 0.0 && pm_eg1_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_txt_sym.tStart = t;  // (not accounting for frame time here)
      pm_eg1_txt_sym.frameNStart = frameN;  // exact frame index
      
      pm_eg1_txt_sym.setAutoDraw(true);
    }

    
    // *pm_eg1_txt_bot* updates
    if (t >= 0.0 && pm_eg1_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_txt_bot.tStart = t;  // (not accounting for frame time here)
      pm_eg1_txt_bot.frameNStart = frameN;  // exact frame index
      
      pm_eg1_txt_bot.setAutoDraw(true);
    }

    
    // *pm_eg1_key_resp* updates
    if (t >= 0.0 && pm_eg1_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_eg1_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_eg1_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_eg1_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_eg1_key_resp.clearEvents(); });
    }

    if (pm_eg1_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_eg1_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _pm_eg1_key_resp_allKeys = _pm_eg1_key_resp_allKeys.concat(theseKeys);
      if (_pm_eg1_key_resp_allKeys.length > 0) {
        pm_eg1_key_resp.keys = _pm_eg1_key_resp_allKeys[_pm_eg1_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_eg1_key_resp.rt = _pm_eg1_key_resp_allKeys[_pm_eg1_key_resp_allKeys.length - 1].rt;
      }
    }
    
    
    // *pm_eg1_resp_txt* updates
    if (t >= 0.0 && pm_eg1_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg1_resp_txt.tStart = t;  // (not accounting for frame time here)
      pm_eg1_resp_txt.frameNStart = frameN;  // exact frame index
      
      pm_eg1_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_eg1Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_eg1RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_eg1'-------
    pm_eg1Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "pm_eg1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_eg2_key_resp_allKeys;
var pm_eg2Components;
function pm_eg2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_eg2'-------
    t = 0;
    pm_eg2Clock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    frame_n = 0;
    textAdd = '';
    pm_eg2_key_resp.keys = undefined;
    pm_eg2_key_resp.rt = undefined;
    _pm_eg2_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_eg2Components = [];
    pm_eg2Components.push(pm_eg2_txt_top);
    pm_eg2Components.push(pm_eg2_txt_num);
    pm_eg2Components.push(pm_eg2_txt_sym);
    pm_eg2Components.push(pm_eg2_txt_bot);
    pm_eg2Components.push(pm_eg2_key_resp);
    pm_eg2Components.push(pm_eg2_resp_txt);
    
    pm_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_eg2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_eg2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_eg2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    let theseKeys = psychoJS.eventManager.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace','return'], waitRelease: false});
    if (theseKeys.length > 0) {  // at least one key was pressed
      textAdd = theseKeys[theseKeys.length-1]; 
      }
    if (frame_n < 1){
        textAdd = '';
    }
    if (textAdd === 'return') {
        textAdd = '';  // Add nothing
        continueRoutine = false;  // End routine (if that is what you want)
    } else if (textAdd === 'backspace') {
        pm_eg2_resp_txt.text = pm_eg2_resp_txt.text.slice(0, -1);
        textAdd = undefined;
    } else if (textAdd !== undefined) {
        pm_eg2_resp_txt.text = pm_eg2_resp_txt.text + textAdd
        textAdd = undefined;
    }
    
    frame_n = frame_n + 1;
    current_resp = pm_eg2_resp_txt.text
    
    // *pm_eg2_txt_top* updates
    if (t >= 0.0 && pm_eg2_txt_top.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_txt_top.tStart = t;  // (not accounting for frame time here)
      pm_eg2_txt_top.frameNStart = frameN;  // exact frame index
      
      pm_eg2_txt_top.setAutoDraw(true);
    }

    
    // *pm_eg2_txt_num* updates
    if (t >= 0.0 && pm_eg2_txt_num.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_txt_num.tStart = t;  // (not accounting for frame time here)
      pm_eg2_txt_num.frameNStart = frameN;  // exact frame index
      
      pm_eg2_txt_num.setAutoDraw(true);
    }

    
    // *pm_eg2_txt_sym* updates
    if (t >= 0.0 && pm_eg2_txt_sym.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_txt_sym.tStart = t;  // (not accounting for frame time here)
      pm_eg2_txt_sym.frameNStart = frameN;  // exact frame index
      
      pm_eg2_txt_sym.setAutoDraw(true);
    }

    
    // *pm_eg2_txt_bot* updates
    if (t >= 0.0 && pm_eg2_txt_bot.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_txt_bot.tStart = t;  // (not accounting for frame time here)
      pm_eg2_txt_bot.frameNStart = frameN;  // exact frame index
      
      pm_eg2_txt_bot.setAutoDraw(true);
    }

    
    // *pm_eg2_key_resp* updates
    if (t >= 0.0 && pm_eg2_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_eg2_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_eg2_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_eg2_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_eg2_key_resp.clearEvents(); });
    }

    if (pm_eg2_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_eg2_key_resp.getKeys({keyList: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'backspace', 'return'], waitRelease: false});
      _pm_eg2_key_resp_allKeys = _pm_eg2_key_resp_allKeys.concat(theseKeys);
      if (_pm_eg2_key_resp_allKeys.length > 0) {
        pm_eg2_key_resp.keys = _pm_eg2_key_resp_allKeys[_pm_eg2_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_eg2_key_resp.rt = _pm_eg2_key_resp_allKeys[_pm_eg2_key_resp_allKeys.length - 1].rt;
      }
    }
    
    
    // *pm_eg2_resp_txt* updates
    if (t >= 0.0 && pm_eg2_resp_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_eg2_resp_txt.tStart = t;  // (not accounting for frame time here)
      pm_eg2_resp_txt.frameNStart = frameN;  // exact frame index
      
      pm_eg2_resp_txt.setAutoDraw(true);
    }

    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_eg2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_eg2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_eg2'-------
    pm_eg2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    // the Routine "pm_eg2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var _pm_test_start_key_resp_allKeys;
var pm_test_startComponents;
function pm_test_startRoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'pm_test_start'-------
    t = 0;
    pm_test_startClock.reset(); // clock
    frameN = -1;
    // update component parameters for each repeat
    pm_test_start_key_resp.keys = undefined;
    pm_test_start_key_resp.rt = undefined;
    _pm_test_start_key_resp_allKeys = [];
    // keep track of which components have finished
    pm_test_startComponents = [];
    pm_test_startComponents.push(pm_test_start_txt);
    pm_test_startComponents.push(pm_test_start_key_resp);
    
    pm_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_test_startRoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'pm_test_start'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = pm_test_startClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *pm_test_start_txt* updates
    if (t >= 0.0 && pm_test_start_txt.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_test_start_txt.tStart = t;  // (not accounting for frame time here)
      pm_test_start_txt.frameNStart = frameN;  // exact frame index
      
      pm_test_start_txt.setAutoDraw(true);
    }

    
    // *pm_test_start_key_resp* updates
    if (t >= 0.0 && pm_test_start_key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      pm_test_start_key_resp.tStart = t;  // (not accounting for frame time here)
      pm_test_start_key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { pm_test_start_key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { pm_test_start_key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { pm_test_start_key_resp.clearEvents(); });
    }

    if (pm_test_start_key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = pm_test_start_key_resp.getKeys({keyList: ['space'], waitRelease: false});
      _pm_test_start_key_resp_allKeys = _pm_test_start_key_resp_allKeys.concat(theseKeys);
      if (_pm_test_start_key_resp_allKeys.length > 0) {
        pm_test_start_key_resp.keys = _pm_test_start_key_resp_allKeys[_pm_test_start_key_resp_allKeys.length - 1].name;  // just the last key pressed
        pm_test_start_key_resp.rt = _pm_test_start_key_resp_allKeys[_pm_test_start_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    pm_test_startComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function pm_test_startRoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'pm_test_start'-------
    pm_test_startComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    pm_timer = new util.CountdownTimer(120);
    // the Routine "pm_test_start" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset();
    
    return Scheduler.Event.NEXT;
  };
}


var End_2Components;
function End_2RoutineBegin(snapshot) {
  return function () {
    //------Prepare to start Routine 'End_2'-------
    t = 0;
    End_2Clock.reset(); // clock
    frameN = -1;
    routineTimer.add(10.000000);
    // update component parameters for each repeat
    // keep track of which components have finished
    End_2Components = [];
    End_2Components.push(thank_you_2);
    End_2Components.push(end);
    End_2Components.push(image_16);
    
    End_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
  };
}


function End_2RoutineEachFrame(snapshot) {
  return function () {
    //------Loop for each frame of Routine 'End_2'-------
    let continueRoutine = true; // until we're told otherwise
    // get current time
    t = End_2Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    
    // *thank_you_2* updates
    if (t >= 0.0 && thank_you_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      thank_you_2.tStart = t;  // (not accounting for frame time here)
      thank_you_2.frameNStart = frameN;  // exact frame index
      
      thank_you_2.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((thank_you_2.status === PsychoJS.Status.STARTED || thank_you_2.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      thank_you_2.setAutoDraw(false);
    }
    
    // *end* updates
    if (t >= 0.0 && end.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      end.tStart = t;  // (not accounting for frame time here)
      end.frameNStart = frameN;  // exact frame index
      
      end.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((end.status === PsychoJS.Status.STARTED || end.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      end.setAutoDraw(false);
    }
    
    // *image_16* updates
    if (t >= 0.0 && image_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      image_16.tStart = t;  // (not accounting for frame time here)
      image_16.frameNStart = frameN;  // exact frame index
      
      image_16.setAutoDraw(true);
    }

    frameRemains = 0.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if ((image_16.status === PsychoJS.Status.STARTED || image_16.status === PsychoJS.Status.FINISHED) && t >= frameRemains) {
      image_16.setAutoDraw(false);
    }
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    End_2Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function End_2RoutineEnd(snapshot) {
  return function () {
    //------Ending Routine 'End_2'-------
    End_2Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    var end_exp = timer_exp.getTime();
    var time_exp = (end_exp - beginning_exp2);
    console.log(time_exp);
    psychoJS.experiment.addData("totaltime_exp", time_exp);
    return Scheduler.Event.NEXT;
  };
}


function endLoopIteration(scheduler, snapshot) {
  // ------Prepare for next entry------
  return function () {
    if (typeof snapshot !== 'undefined') {
      // ------Check if user ended loop early------
      if (snapshot.finished) {
        // Check for and save orphaned data
        if (psychoJS.experiment.isEntryEmpty()) {
          psychoJS.experiment.nextEntry(snapshot);
        }
        scheduler.stop();
      } else {
        const thisTrial = snapshot.getCurrentTrial();
        if (typeof thisTrial === 'undefined' || !('isTrials' in thisTrial) || thisTrial.isTrials) {
          psychoJS.experiment.nextEntry(snapshot);
        }
      }
    return Scheduler.Event.NEXT;
    }
  };
}


function importConditions(currentLoop) {
  return function () {
    psychoJS.importAttributes(currentLoop.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}


function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
